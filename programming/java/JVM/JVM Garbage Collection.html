<!doctype html>
<html lang="en-US" data-theme="light">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <meta name="generator" content="VuePress 2.0.0-rc.12" />
    <meta name="theme" content="VuePress Theme Hope 2.0.0-rc.46" />
    <style>
      html {
        background: var(--bg-color, #fff);
      }

      html[data-theme="dark"] {
        background: var(--bg-color, #1d1e1f);
      }

      body {
        background: var(--bg-color);
      }
    </style>
    <script>
      const userMode = localStorage.getItem("vuepress-theme-hope-scheme");
      const systemDarkMode =
        window.matchMedia &&
        window.matchMedia("(prefers-color-scheme: dark)").matches;

      if (userMode === "dark" || (userMode !== "light" && systemDarkMode)) {
        document.documentElement.setAttribute("data-theme", "dark");
      }
    </script>
    <meta property="og:url" content="https://vanhung4499.github.io/programming/java/JVM/JVM%20Garbage%20Collection.html"><meta property="og:site_name" content="VanHung4499"><meta property="og:title" content="JVM Garbage Collection"><meta property="og:description" content="Thu gom rác trong JVM Các vùng nhớ như bộ đếm chương trình, ngăn xếp ảo và ngăn xếp phương thức cùng với các vùng nhớ này đều thuộc về từng luồng riêng biệt và chỉ tồn tại trong..."><meta property="og:type" content="article"><meta property="og:image" content="https://raw.githubusercontent.com/vanhung4499/images/master/snap/20230718153129.png"><meta property="og:locale" content="en-US"><meta property="og:updated_time" content="2024-06-28T15:54:38.000Z"><meta property="article:author" content="Hung Nguyen"><meta property="article:tag" content="java"><meta property="article:tag" content="javase"><meta property="article:tag" content="jvm"><meta property="article:tag" content="gc"><meta property="article:modified_time" content="2024-06-28T15:54:38.000Z"><script type="application/ld+json">{"@context":"https://schema.org","@type":"Article","headline":"JVM Garbage Collection","image":["https://raw.githubusercontent.com/vanhung4499/images/master/snap/20230718153129.png","https://raw.githubusercontent.com/vanhung4499/images/master/snap/20230718172452.png","https://raw.githubusercontent.com/vanhung4499/images/master/snap/20230718172523.png","https://raw.githubusercontent.com/vanhung4499/images/master/snap/20230718172532.png","https://raw.githubusercontent.com/vanhung4499/images/master/snap/20230718201633.png","https://raw.githubusercontent.com/vanhung4499/images/master/snap/20230718202918.png","https://raw.githubusercontent.com/vanhung4499/images/master/snap/20230718203540.png","https://raw.githubusercontent.com/vanhung4499/images/master/snap/slide1.png","https://raw.githubusercontent.com/vanhung4499/images/master/snap/slide2.png","https://raw.githubusercontent.com/vanhung4499/images/master/snap/slide3.png","https://raw.githubusercontent.com/vanhung4499/images/master/snap/slide4.png","https://raw.githubusercontent.com/vanhung4499/images/master/snap/slide5.png","https://raw.githubusercontent.com/vanhung4499/images/master/snap/slide6.png","https://raw.githubusercontent.com/vanhung4499/images/master/snap/slide7.png","https://raw.githubusercontent.com/vanhung4499/images/master/snap/slide8.png","https://raw.githubusercontent.com/vanhung4499/images/master/snap/slide9.png","https://raw.githubusercontent.com/vanhung4499/images/master/snap/slide10.png","https://raw.githubusercontent.com/vanhung4499/images/master/snap/slide11.png","https://raw.githubusercontent.com/vanhung4499/images/master/snap/slide12.png","https://raw.githubusercontent.com/vanhung4499/images/master/snap/slide13.png","https://raw.githubusercontent.com/vanhung4499/images/master/snap/slide14.png","https://raw.githubusercontent.com/vanhung4499/images/master/snap/slide15.png","https://raw.githubusercontent.com/vanhung4499/images/master/snap/slide16.png","https://raw.githubusercontent.com/vanhung4499/images/master/snap/slide17.png"],"dateModified":"2024-06-28T15:54:38.000Z","author":[{"@type":"Person","name":"Hung Nguyen","url":"https://vanhung4499.github.io"}]}</script><meta name="referrer" content="no-referrer-when-downgrade"><link rel="alternate" type="application/rss+xml" href="https://vanhung4499.github.io/rss.xml" title="VanHung4499 RSS Feed"><title>JVM Garbage Collection | VanHung4499</title><meta name="description" content="Thu gom rác trong JVM Các vùng nhớ như bộ đếm chương trình, ngăn xếp ảo và ngăn xếp phương thức cùng với các vùng nhớ này đều thuộc về từng luồng riêng biệt và chỉ tồn tại trong...">
    <link rel="preload" href="/assets/style-BqjKxtxe.css" as="style"><link rel="stylesheet" href="/assets/style-BqjKxtxe.css">
    <link rel="modulepreload" href="/assets/app-BG8AAbz2.js"><link rel="modulepreload" href="/assets/JVM Garbage Collection.html-aAmzE_wk.js">
    
  </head>
  <body>
    <div id="app"><!--[--><!--[--><!--[--><span tabindex="-1"></span><a href="#main-content" class="vp-skip-link sr-only">Skip to main content</a><!--]--><div class="theme-container external-link-icon has-toc"><!--[--><header id="navbar" class="vp-navbar"><div class="vp-navbar-start"><button type="button" class="vp-toggle-sidebar-button" title="Toggle Sidebar"><span class="icon"></span></button><!----><!--[--><a class="route-link vp-brand" href="/"><img class="vp-nav-logo" src="/logo.svg" alt><!----><span class="vp-site-name hide-in-pad">VanHung4499</span></a><!--]--><!----></div><div class="vp-navbar-center"><!----><!--[--><nav class="vp-nav-links"><div class="vp-nav-item hide-in-mobile"><a class="route-link auto-link" href="/" aria-label="Home"><!--[--><iconify-icon class="font-icon icon" style="" mode="style" inline icon="mdi:home" width="1em" height="1em"></iconify-icon><!--]-->Home<!----></a></div><div class="vp-nav-item hide-in-mobile"><a class="route-link auto-link" href="/wiki.html" aria-label="Wiki"><!--[--><iconify-icon class="font-icon icon" style="" mode="style" inline icon="carbon:wikis" width="1em" height="1em"></iconify-icon><!--]-->Wiki<!----></a></div><div class="vp-nav-item hide-in-mobile"><a class="route-link auto-link" href="/dsa/" aria-label="Algorithms"><!--[--><iconify-icon class="font-icon icon" style="" mode="style" inline icon="hugeicons:algorithm" width="1em" height="1em"></iconify-icon><!--]-->Algorithms<!----></a></div><div class="vp-nav-item hide-in-mobile"><div class="vp-dropdown-wrapper"><button type="button" class="vp-dropdown-title" aria-label="Programming"><!--[--><iconify-icon class="font-icon icon" style="" mode="style" inline icon="mdi:code" width="1em" height="1em"></iconify-icon>Programming<!--]--><span class="arrow"></span><ul class="vp-dropdown"><li class="vp-dropdown-item"><a class="route-link route-link-active auto-link" href="/programming/java/" aria-label="Java"><!--[--><iconify-icon class="font-icon icon" style="" mode="style" inline icon="devicon:java" width="1em" height="1em"></iconify-icon><!--]-->Java<!----></a></li><li class="vp-dropdown-item"><a class="route-link auto-link" href="/programming/golang/" aria-label="Golang"><!--[--><iconify-icon class="font-icon icon" style="" mode="style" inline icon="devicon:go" width="1em" height="1em"></iconify-icon><!--]-->Golang<!----></a></li><li class="vp-dropdown-item"><a class="route-link auto-link" href="/programming/js/" aria-label="JavaScript"><!--[--><iconify-icon class="font-icon icon" style="" mode="style" inline icon="devicon:javascript" width="1em" height="1em"></iconify-icon><!--]-->JavaScript<!----></a></li><li class="vp-dropdown-item"><a class="route-link auto-link" href="/programming/ts/" aria-label="TypeScript"><!--[--><iconify-icon class="font-icon icon" style="" mode="style" inline icon="devicon:typescript" width="1em" height="1em"></iconify-icon><!--]-->TypeScript<!----></a></li><li class="vp-dropdown-item"><a class="route-link auto-link" href="/programming/python/" aria-label="Python"><!--[--><iconify-icon class="font-icon icon" style="" mode="style" inline icon="devicon:python" width="1em" height="1em"></iconify-icon><!--]-->Python<!----></a></li></ul></button></div></div><div class="vp-nav-item hide-in-mobile"><div class="vp-dropdown-wrapper"><button type="button" class="vp-dropdown-title" aria-label="Database"><!--[--><iconify-icon class="font-icon icon" style="" mode="style" inline icon="mdi:database" width="1em" height="1em"></iconify-icon>Database<!--]--><span class="arrow"></span><ul class="vp-dropdown"><li class="vp-dropdown-item"><a class="route-link auto-link" href="/database/sql/" aria-label="SQL"><!--[--><iconify-icon class="font-icon icon" style="" mode="style" inline icon="mdi:sql-query" width="1em" height="1em"></iconify-icon><!--]-->SQL<!----></a></li><li class="vp-dropdown-item"><a class="route-link auto-link" href="/database/mysql/" aria-label="MySQL"><!--[--><iconify-icon class="font-icon icon" style="" mode="style" inline icon="devicon:mysql" width="1em" height="1em"></iconify-icon><!--]-->MySQL<!----></a></li><li class="vp-dropdown-item"><a class="route-link auto-link" href="/database/mongodb/" aria-label="MongoDB"><!--[--><iconify-icon class="font-icon icon" style="" mode="style" inline icon="devicon:mongodb" width="1em" height="1em"></iconify-icon><!--]-->MongoDB<!----></a></li><li class="vp-dropdown-item"><a class="route-link auto-link" href="/database/redis/" aria-label="Redis"><!--[--><iconify-icon class="font-icon icon" style="" mode="style" inline icon="devicon:redis" width="1em" height="1em"></iconify-icon><!--]-->Redis<!----></a></li><li class="vp-dropdown-item"><a class="route-link auto-link" href="/database/elasticsearch/" aria-label="Elasticsearch"><!--[--><iconify-icon class="font-icon icon" style="" mode="style" inline icon="devicon:elasticsearch" width="1em" height="1em"></iconify-icon><!--]-->Elasticsearch<!----></a></li><li class="vp-dropdown-item"><a class="route-link auto-link" href="/database/elastic/" aria-label="Elastic Stack"><!--[--><iconify-icon class="font-icon icon" style="" mode="style" inline icon="cib:elastic-stack" width="1em" height="1em"></iconify-icon><!--]-->Elastic Stack<!----></a></li></ul></button></div></div><div class="vp-nav-item hide-in-mobile"><div class="vp-dropdown-wrapper"><button type="button" class="vp-dropdown-title" aria-label="Framework"><!--[--><iconify-icon class="font-icon icon" style="" mode="style" inline icon="simple-icons:framework" width="1em" height="1em"></iconify-icon>Framework<!--]--><span class="arrow"></span><ul class="vp-dropdown"><li class="vp-dropdown-item"><a class="route-link auto-link" href="/framework/spring/" aria-label="Spring"><!--[--><iconify-icon class="font-icon icon" style="" mode="style" inline icon="devicon:spring" width="1em" height="1em"></iconify-icon><!--]-->Spring<!----></a></li><li class="vp-dropdown-item"><a class="route-link auto-link" href="/framework/spring-boot/" aria-label="Spring Boot"><!--[--><iconify-icon class="font-icon icon" style="" mode="style" inline icon="devicon:spring" width="1em" height="1em"></iconify-icon><!--]-->Spring Boot<!----></a></li><li class="vp-dropdown-item"><a class="route-link auto-link" href="/framework/nestjs/" aria-label="NestJS"><!--[--><iconify-icon class="font-icon icon" style="" mode="style" inline icon="devicon:nestjs" width="1em" height="1em"></iconify-icon><!--]-->NestJS<!----></a></li><li class="vp-dropdown-item"><a class="route-link auto-link" href="/framework/gin/" aria-label="Gin"><!--[--><iconify-icon class="font-icon icon" style="" mode="style" inline icon="logos:gin" width="1em" height="1em"></iconify-icon><!--]-->Gin<!----></a></li></ul></button></div></div><div class="vp-nav-item hide-in-mobile"><div class="vp-dropdown-wrapper"><button type="button" class="vp-dropdown-title" aria-label="DevOps"><!--[--><iconify-icon class="font-icon icon" style="" mode="style" inline icon="devicon-plain:azuredevops" width="1em" height="1em"></iconify-icon>DevOps<!--]--><span class="arrow"></span><ul class="vp-dropdown"><li class="vp-dropdown-item"><a class="route-link auto-link" href="/devops/docker/" aria-label="Docker"><!--[--><iconify-icon class="font-icon icon" style="" mode="style" inline icon="devicon:docker" width="1em" height="1em"></iconify-icon><!--]-->Docker<!----></a></li><li class="vp-dropdown-item"><a class="route-link auto-link" href="/devops/kubernetes/" aria-label="Kubernetes"><!--[--><iconify-icon class="font-icon icon" style="" mode="style" inline icon="devicon:kubernetes" width="1em" height="1em"></iconify-icon><!--]-->Kubernetes<!----></a></li><li class="vp-dropdown-item"><a class="route-link auto-link" href="/devops/jenkins/" aria-label="Jenkins"><!--[--><iconify-icon class="font-icon icon" style="" mode="style" inline icon="devicon:jenkins" width="1em" height="1em"></iconify-icon><!--]-->Jenkins<!----></a></li><li class="vp-dropdown-item"><a class="route-link auto-link" href="/devops/git/" aria-label="Git"><!--[--><iconify-icon class="font-icon icon" style="" mode="style" inline icon="devicon:git" width="1em" height="1em"></iconify-icon><!--]-->Git<!----></a></li><li class="vp-dropdown-item"><a class="route-link auto-link" href="/devops/linux/" aria-label="Linux"><!--[--><iconify-icon class="font-icon icon" style="" mode="style" inline icon="devicon:linux" width="1em" height="1em"></iconify-icon><!--]-->Linux<!----></a></li></ul></button></div></div><div class="vp-nav-item hide-in-mobile"><div class="vp-dropdown-wrapper"><button type="button" class="vp-dropdown-title" aria-label="Design"><!--[--><iconify-icon class="font-icon icon" style="" mode="style" inline icon="tdesign:system-sum" width="1em" height="1em"></iconify-icon>Design<!--]--><span class="arrow"></span><ul class="vp-dropdown"><li class="vp-dropdown-item"><a class="route-link auto-link" href="/design/design-pattern/" aria-label="Design Pattern"><!--[--><iconify-icon class="font-icon icon" style="" mode="style" inline icon="tabler:grid-pattern" width="1em" height="1em"></iconify-icon><!--]-->Design Pattern<!----></a></li><li class="vp-dropdown-item"><a class="route-link auto-link" href="/design/system-design/" aria-label="System Design"><!--[--><iconify-icon class="font-icon icon" style="" mode="style" inline icon="icon-park-outline:system" width="1em" height="1em"></iconify-icon><!--]-->System Design<!----></a></li></ul></button></div></div><div class="vp-nav-item hide-in-mobile"><a class="route-link auto-link" href="/project/" aria-label="Project"><!--[--><iconify-icon class="font-icon icon" style="" mode="style" inline icon="ant-design:project-outlined" width="1em" height="1em"></iconify-icon><!--]-->Project<!----></a></div><div class="vp-nav-item hide-in-mobile"><a class="route-link auto-link" href="/interview/" aria-label="Interview"><!--[--><iconify-icon class="font-icon icon" style="" mode="style" inline icon="mdi:account-tie" width="1em" height="1em"></iconify-icon><!--]-->Interview<!----></a></div><div class="vp-nav-item hide-in-mobile"><div class="vp-dropdown-wrapper"><button type="button" class="vp-dropdown-title" aria-label="About"><!--[--><iconify-icon class="font-icon icon" style="" mode="style" inline icon="mdi:about" width="1em" height="1em"></iconify-icon>About<!--]--><span class="arrow"></span><ul class="vp-dropdown"><li class="vp-dropdown-item"><a class="route-link auto-link" href="/about-me.html" aria-label="About me"><!--[--><iconify-icon class="font-icon icon" style="" mode="style" inline icon="cib:about-me" width="1em" height="1em"></iconify-icon><!--]-->About me<!----></a></li><li class="vp-dropdown-item"><a class="route-link auto-link" href="/about.html" aria-label="About"><!--[--><iconify-icon class="font-icon icon" style="" mode="style" inline icon="mdi:about" width="1em" height="1em"></iconify-icon><!--]-->About<!----></a></li></ul></button></div></div></nav><!--]--><!----></div><div class="vp-navbar-end"><!----><!--[--><!----><div class="vp-nav-item vp-action"><a class="vp-action-link" href="https://github.com/vanhung4499/my-wiki" target="_blank" rel="noopener noreferrer" aria-label="GitHub"><svg xmlns="http://www.w3.org/2000/svg" class="icon github-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="github icon" name="github" style="width:1.25rem;height:1.25rem;vertical-align:middle;"><path d="M511.957 21.333C241.024 21.333 21.333 240.981 21.333 512c0 216.832 140.544 400.725 335.574 465.664 24.49 4.395 32.256-10.07 32.256-23.083 0-11.69.256-44.245 0-85.205-136.448 29.61-164.736-64.64-164.736-64.64-22.315-56.704-54.4-71.765-54.4-71.765-44.587-30.464 3.285-29.824 3.285-29.824 49.195 3.413 75.179 50.517 75.179 50.517 43.776 75.008 114.816 53.333 142.762 40.79 4.523-31.66 17.152-53.377 31.19-65.537-108.971-12.458-223.488-54.485-223.488-242.602 0-53.547 19.114-97.323 50.517-131.67-5.035-12.33-21.93-62.293 4.779-129.834 0 0 41.258-13.184 134.912 50.346a469.803 469.803 0 0 1 122.88-16.554c41.642.213 83.626 5.632 122.88 16.554 93.653-63.488 134.784-50.346 134.784-50.346 26.752 67.541 9.898 117.504 4.864 129.834 31.402 34.347 50.474 78.123 50.474 131.67 0 188.586-114.73 230.016-224.042 242.09 17.578 15.232 33.578 44.672 33.578 90.454v135.85c0 13.142 7.936 27.606 32.854 22.87C862.25 912.597 1002.667 728.747 1002.667 512c0-271.019-219.648-490.667-490.71-490.667z"></path></svg></a></div><div class="vp-nav-item hide-in-mobile"><button type="button" class="vp-outlook-button" tabindex="-1" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" class="icon outlook-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="outlook icon" name="outlook"><path d="M224 800c0 9.6 3.2 44.8 6.4 54.4 6.4 48-48 76.8-48 76.8s80 41.6 147.2 0 134.4-134.4 38.4-195.2c-22.4-12.8-41.6-19.2-57.6-19.2C259.2 716.8 227.2 761.6 224 800zM560 675.2l-32 51.2c-51.2 51.2-83.2 32-83.2 32 25.6 67.2 0 112-12.8 128 25.6 6.4 51.2 9.6 80 9.6 54.4 0 102.4-9.6 150.4-32l0 0c3.2 0 3.2-3.2 3.2-3.2 22.4-16 12.8-35.2 6.4-44.8-9.6-12.8-12.8-25.6-12.8-41.6 0-54.4 60.8-99.2 137.6-99.2 6.4 0 12.8 0 22.4 0 12.8 0 38.4 9.6 48-25.6 0-3.2 0-3.2 3.2-6.4 0-3.2 3.2-6.4 3.2-6.4 6.4-16 6.4-16 6.4-19.2 9.6-35.2 16-73.6 16-115.2 0-105.6-41.6-198.4-108.8-268.8C704 396.8 560 675.2 560 675.2zM224 419.2c0-28.8 22.4-51.2 51.2-51.2 28.8 0 51.2 22.4 51.2 51.2 0 28.8-22.4 51.2-51.2 51.2C246.4 470.4 224 448 224 419.2zM320 284.8c0-22.4 19.2-41.6 41.6-41.6 22.4 0 41.6 19.2 41.6 41.6 0 22.4-19.2 41.6-41.6 41.6C339.2 326.4 320 307.2 320 284.8zM457.6 208c0-12.8 12.8-25.6 25.6-25.6 12.8 0 25.6 12.8 25.6 25.6 0 12.8-12.8 25.6-25.6 25.6C470.4 233.6 457.6 220.8 457.6 208zM128 505.6C128 592 153.6 672 201.6 736c28.8-60.8 112-60.8 124.8-60.8-16-51.2 16-99.2 16-99.2l316.8-422.4c-48-19.2-99.2-32-150.4-32C297.6 118.4 128 291.2 128 505.6zM764.8 86.4c-22.4 19.2-390.4 518.4-390.4 518.4-22.4 28.8-12.8 76.8 22.4 99.2l9.6 6.4c35.2 22.4 80 12.8 99.2-25.6 0 0 6.4-12.8 9.6-19.2 54.4-105.6 275.2-524.8 288-553.6 6.4-19.2-3.2-32-19.2-32C777.6 76.8 771.2 80 764.8 86.4z"></path></svg><div class="vp-outlook-dropdown"><!----></div></button></div><!--[--><button type="button" class="search-pro-button" aria-label="Search"><svg xmlns="http://www.w3.org/2000/svg" class="icon search-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="search icon" name="search"><path d="M192 480a256 256 0 1 1 512 0 256 256 0 0 1-512 0m631.776 362.496-143.2-143.168A318.464 318.464 0 0 0 768 480c0-176.736-143.264-320-320-320S128 303.264 128 480s143.264 320 320 320a318.016 318.016 0 0 0 184.16-58.592l146.336 146.368c12.512 12.48 32.768 12.48 45.28 0 12.48-12.512 12.48-32.768 0-45.28"></path></svg><div class="search-pro-placeholder">Search</div><div class="search-pro-key-hints"><kbd class="search-pro-key">Ctrl</kbd><kbd class="search-pro-key">K</kbd></div></button><!--]--><!--]--><!----><button type="button" class="vp-toggle-navbar-button" aria-label="Toggle Navbar" aria-expanded="false" aria-controls="nav-screen"><span><span class="vp-top"></span><span class="vp-middle"></span><span class="vp-bottom"></span></span></button></div></header><!----><!--]--><!----><div class="toggle-sidebar-wrapper"><span class="arrow start"></span></div><aside id="sidebar" class="vp-sidebar"><!----><ul class="vp-sidebar-links"><li><a class="route-link auto-link vp-sidebar-link vp-sidebar-page" href="/programming/java/" aria-label="Java"><!--[--><iconify-icon class="font-icon icon" style="" mode="style" inline icon="devicon:java" width="1em" height="1em"></iconify-icon><!--]-->Java<!----></a></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-header clickable" type="button"><!----><span class="vp-sidebar-title">Basic</span><span class="vp-arrow end"></span></button><!----></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-header clickable" type="button"><!----><span class="vp-sidebar-title">Array</span><span class="vp-arrow end"></span></button><!----></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-header clickable" type="button"><!----><span class="vp-sidebar-title">String</span><span class="vp-arrow end"></span></button><!----></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-header clickable" type="button"><!----><span class="vp-sidebar-title">OOP</span><span class="vp-arrow end"></span></button><!----></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-header clickable" type="button"><!----><span class="vp-sidebar-title">Extra</span><span class="vp-arrow end"></span></button><!----></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-header clickable" type="button"><!----><span class="vp-sidebar-title">Collection</span><span class="vp-arrow end"></span></button><!----></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-header clickable" type="button"><!----><span class="vp-sidebar-title">Common Tools</span><span class="vp-arrow end"></span></button><!----></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-header clickable" type="button"><!----><span class="vp-sidebar-title">IO</span><span class="vp-arrow end"></span></button><!----></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-header clickable" type="button"><!----><span class="vp-sidebar-title">Exception</span><span class="vp-arrow end"></span></button><!----></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-header clickable" type="button"><!----><span class="vp-sidebar-title">New Features</span><span class="vp-arrow end"></span></button><!----></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-header clickable" type="button"><!----><span class="vp-sidebar-title">NIO</span><span class="vp-arrow end"></span></button><!----></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-header clickable" type="button"><!----><span class="vp-sidebar-title">Advanced</span><span class="vp-arrow end"></span></button><!----></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-header clickable" type="button"><!----><span class="vp-sidebar-title">Concurrency</span><span class="vp-arrow end"></span></button><!----></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-header clickable active" type="button"><!----><span class="vp-sidebar-title">JVM</span><span class="vp-arrow down"></span></button><ul class="vp-sidebar-links"><li><a class="route-link auto-link vp-sidebar-link vp-sidebar-page" href="/programming/java/JVM/Java%20Bytecode.html" aria-label="Java Bytecode"><!---->Java Bytecode<!----></a></li><li><a class="route-link auto-link vp-sidebar-link vp-sidebar-page" href="/programming/java/JVM/JVM%20Architecture.html" aria-label="JVM Architecture"><!---->JVM Architecture<!----></a></li><li><a class="route-link auto-link vp-sidebar-link vp-sidebar-page" href="/programming/java/JVM/JVM%20Class%20Loader.html" aria-label="JVM Class Loader"><!---->JVM Class Loader<!----></a></li><li><a class="route-link auto-link vp-sidebar-link vp-sidebar-page" href="/programming/java/JVM/JVM%20Command%20Line%20Tools.html" aria-label="JVM Command Line Tools"><!---->JVM Command Line Tools<!----></a></li><li><a class="route-link route-link-active auto-link vp-sidebar-link vp-sidebar-page active" href="/programming/java/JVM/JVM%20Garbage%20Collection.html" aria-label="JVM Garbage Collection"><!---->JVM Garbage Collection<!----></a></li><li><a class="route-link auto-link vp-sidebar-link vp-sidebar-page" href="/programming/java/JVM/JVM%20GUI%20Tools.html" aria-label="JVM GUI Tools"><!---->JVM GUI Tools<!----></a></li><li><a class="route-link auto-link vp-sidebar-link vp-sidebar-page" href="/programming/java/JVM/JVM%20In%20Action.html" aria-label="JVM In Action"><!---->JVM In Action<!----></a></li><li><a class="route-link auto-link vp-sidebar-link vp-sidebar-page" href="/programming/java/JVM/JVM%20Memory%20Managment.html" aria-label="JVM Memory Managment"><!---->JVM Memory Managment<!----></a></li></ul></section></li></ul><!----></aside><!--[--><main id="main-content" class="vp-page"><!--[--><!----><!----><nav class="vp-breadcrumb disable"></nav><div class="vp-page-title"><h1><!---->JVM Garbage Collection</h1><div class="page-info"><span class="page-author-info" aria-label="Author🖊" data-balloon-pos="up"><svg xmlns="http://www.w3.org/2000/svg" class="icon author-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="author icon" name="author"><path d="M649.6 633.6c86.4-48 147.2-144 147.2-249.6 0-160-128-288-288-288s-288 128-288 288c0 108.8 57.6 201.6 147.2 249.6-121.6 48-214.4 153.6-240 288-3.2 9.6 0 19.2 6.4 25.6 3.2 9.6 12.8 12.8 22.4 12.8h704c9.6 0 19.2-3.2 25.6-12.8 6.4-6.4 9.6-16 6.4-25.6-25.6-134.4-121.6-240-243.2-288z"></path></svg><span><a class="page-author-item" href="https://vanhung4499.github.io" target="_blank" rel="noopener noreferrer">Hung Nguyen</a></span><span property="author" content="Hung Nguyen"></span></span><!----><span class="page-date-info" aria-label="Writing Date📅" data-balloon-pos="up"><svg xmlns="http://www.w3.org/2000/svg" class="icon calendar-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="calendar icon" name="calendar"><path d="M716.4 110.137c0-18.753-14.72-33.473-33.472-33.473-18.753 0-33.473 14.72-33.473 33.473v33.473h66.993v-33.473zm-334.87 0c0-18.753-14.72-33.473-33.473-33.473s-33.52 14.72-33.52 33.473v33.473h66.993v-33.473zm468.81 33.52H716.4v100.465c0 18.753-14.72 33.473-33.472 33.473a33.145 33.145 0 01-33.473-33.473V143.657H381.53v100.465c0 18.753-14.72 33.473-33.473 33.473a33.145 33.145 0 01-33.473-33.473V143.657H180.6A134.314 134.314 0 0046.66 277.595v535.756A134.314 134.314 0 00180.6 947.289h669.74a134.36 134.36 0 00133.94-133.938V277.595a134.314 134.314 0 00-133.94-133.938zm33.473 267.877H147.126a33.145 33.145 0 01-33.473-33.473c0-18.752 14.72-33.473 33.473-33.473h736.687c18.752 0 33.472 14.72 33.472 33.473a33.145 33.145 0 01-33.472 33.473z"></path></svg><span><!----></span><meta property="datePublished" content="2024-06-28T15:54:38.000Z"></span><!----><span class="page-reading-time-info" aria-label="Reading Time⌛" data-balloon-pos="up"><svg xmlns="http://www.w3.org/2000/svg" class="icon timer-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="timer icon" name="timer"><path d="M799.387 122.15c4.402-2.978 7.38-7.897 7.38-13.463v-1.165c0-8.933-7.38-16.312-16.312-16.312H256.33c-8.933 0-16.311 7.38-16.311 16.312v1.165c0 5.825 2.977 10.874 7.637 13.592 4.143 194.44 97.22 354.963 220.201 392.763-122.204 37.542-214.893 196.511-220.2 389.397-4.661 5.049-7.638 11.651-7.638 19.03v5.825h566.49v-5.825c0-7.379-2.849-13.981-7.509-18.9-5.049-193.016-97.867-351.985-220.2-389.527 123.24-37.67 216.446-198.453 220.588-392.892zM531.16 450.445v352.632c117.674 1.553 211.787 40.778 211.787 88.676H304.097c0-48.286 95.149-87.382 213.728-88.676V450.445c-93.077-3.107-167.901-81.297-167.901-177.093 0-8.803 6.99-15.793 15.793-15.793 8.803 0 15.794 6.99 15.794 15.793 0 80.261 63.69 145.635 142.01 145.635s142.011-65.374 142.011-145.635c0-8.803 6.99-15.793 15.794-15.793s15.793 6.99 15.793 15.793c0 95.019-73.789 172.82-165.96 177.093z"></path></svg><span>About 35 min</span><meta property="timeRequired" content="PT35M"></span><span class="page-category-info" aria-label="Category🌈" data-balloon-pos="up"><svg xmlns="http://www.w3.org/2000/svg" class="icon category-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="category icon" name="category"><path d="M148.41 106.992h282.176c22.263 0 40.31 18.048 40.31 40.31V429.48c0 22.263-18.047 40.31-40.31 40.31H148.41c-22.263 0-40.311-18.047-40.311-40.31V147.302c0-22.263 18.048-40.31 40.311-40.31zM147.556 553.478H429.73c22.263 0 40.311 18.048 40.311 40.31v282.176c0 22.263-18.048 40.312-40.31 40.312H147.555c-22.263 0-40.311-18.049-40.311-40.312V593.79c0-22.263 18.048-40.311 40.31-40.311zM593.927 106.992h282.176c22.263 0 40.31 18.048 40.31 40.31V429.48c0 22.263-18.047 40.31-40.31 40.31H593.927c-22.263 0-40.311-18.047-40.311-40.31V147.302c0-22.263 18.048-40.31 40.31-40.31zM730.22 920.502H623.926c-40.925 0-74.22-33.388-74.22-74.425V623.992c0-41.038 33.387-74.424 74.425-74.424h222.085c41.038 0 74.424 33.226 74.424 74.067v114.233c0 10.244-8.304 18.548-18.547 18.548s-18.548-8.304-18.548-18.548V623.635c0-20.388-16.746-36.974-37.33-36.974H624.13c-20.585 0-37.331 16.747-37.331 37.33v222.086c0 20.585 16.654 37.331 37.126 37.331H730.22c10.243 0 18.547 8.304 18.547 18.547 0 10.244-8.304 18.547-18.547 18.547z"></path></svg><!--[--><span class="page-category-item color8 clickable" role="navigation">java</span><span class="page-category-item color1 clickable" role="navigation">javase</span><span class="page-category-item color5 clickable" role="navigation">jvm</span><!--]--><meta property="articleSection" content="java,javase,jvm"></span><span class="page-tag-info" aria-label="Tag🏷" data-balloon-pos="up"><svg xmlns="http://www.w3.org/2000/svg" class="icon tag-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="tag icon" name="tag"><path d="M939.902 458.563L910.17 144.567c-1.507-16.272-14.465-29.13-30.737-30.737L565.438 84.098h-.402c-3.215 0-5.726 1.005-7.634 2.913l-470.39 470.39a10.004 10.004 0 000 14.164l365.423 365.424c1.909 1.908 4.42 2.913 7.132 2.913s5.223-1.005 7.132-2.913l470.39-470.39c2.01-2.11 3.014-5.023 2.813-8.036zm-240.067-72.121c-35.458 0-64.286-28.828-64.286-64.286s28.828-64.285 64.286-64.285 64.286 28.828 64.286 64.285-28.829 64.286-64.286 64.286z"></path></svg><!--[--><span class="page-tag-item color8 clickable" role="navigation">java</span><span class="page-tag-item color1 clickable" role="navigation">javase</span><span class="page-tag-item color5 clickable" role="navigation">jvm</span><span class="page-tag-item color7 clickable" role="navigation">gc</span><!--]--><meta property="keywords" content="java,javase,jvm,gc"></span></div><hr></div><div class="vp-toc-placeholder"><aside id="toc"><!----><div class="vp-toc-header">On This Page<button type="button" class="print-button" title="Print"><svg xmlns="http://www.w3.org/2000/svg" class="icon print-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="print icon" name="print"><path d="M819.2 364.8h-44.8V128c0-17.067-14.933-32-32-32H281.6c-17.067 0-32 14.933-32 32v236.8h-44.8C145.067 364.8 96 413.867 96 473.6v192c0 59.733 49.067 108.8 108.8 108.8h44.8V896c0 17.067 14.933 32 32 32h460.8c17.067 0 32-14.933 32-32V774.4h44.8c59.733 0 108.8-49.067 108.8-108.8v-192c0-59.733-49.067-108.8-108.8-108.8zM313.6 160h396.8v204.8H313.6V160zm396.8 704H313.6V620.8h396.8V864zM864 665.6c0 25.6-19.2 44.8-44.8 44.8h-44.8V588.8c0-17.067-14.933-32-32-32H281.6c-17.067 0-32 14.933-32 32v121.6h-44.8c-25.6 0-44.8-19.2-44.8-44.8v-192c0-25.6 19.2-44.8 44.8-44.8h614.4c25.6 0 44.8 19.2 44.8 44.8v192z"></path></svg></button><div class="arrow end"></div></div><div class="vp-toc-wrapper"><ul class="vp-toc-list"><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level2" href="#đoi-tuong-con-song-hay-đa-chet">Đối tượng còn sống hay đã chết</a></li><li><ul class="vp-toc-list"><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#thuat-toan-đem-tham-chieu">Thuật toán đếm tham chiếu</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#thuat-toan-phan-tich-kha-nang-tiep-can">Thuật toán phân tích khả năng tiếp cận</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#loai-tham-chieu">Loại tham chiếu</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#thu-gom-vung-phuong-thuc">Thu gom vùng phương thức</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#thu-gom-vung-phuong-thuc-1">Thu gom vùng phương thức</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#finalize">finalize()</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level2" href="#thuat-toan-thu-gom-rac">Thuật toán thu gom rác</a></li><li><ul class="vp-toc-list"><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#hieu-suat-thu-gom-rac">Hiệu suất thu gom rác</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#đanh-dau-don-dep-mark-sweep">Đánh dấu - Dọn dẹp (Mark-Sweep)</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#đanh-dau-sap-xep-mark-compact">Đánh dấu - Sắp xếp (Mark-Compact)</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#sao-chep-copying">Sao chép (Copying)</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level2" href="#thuat-toan-thu-gom-rac-theo-the-he">Thuật toán thu gom rác theo thế hệ</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level2" href="#bo-thu-gom-rac">Bộ thu gom rác</a></li><li><ul class="vp-toc-list"><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#bo-thu-gom-rac-tuan-tu">Bộ thu gom rác tuần tự</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#bo-thu-gom-rac-song-song">Bộ thu gom rác song song</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#bo-thu-gom-rac-đong-thoi-đanh-dau-xoa">Bộ thu gom rác đồng thời đánh dấu-xóa</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#bo-thu-gom-g1">Bộ thu gom G1</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#tong-ket">Tổng kết</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level2" href="#chien-luoc-cap-phat-va-thu-gom-bo-nho">Chiến lược cấp phát và thu gom bộ nhớ</a></li><li><ul class="vp-toc-list"><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#minor-gc">Minor GC</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#full-gc">Full GC</a></li><!----><!--]--></ul></li><!--]--></ul><div class="vp-toc-marker" style="top:-1.7rem;"></div></div><!----></aside></div><!----><div class="theme-hope-content"><h1 id="thu-gom-rac-trong-jvm" tabindex="-1"><a class="header-anchor" href="#thu-gom-rac-trong-jvm"><span>Thu gom rác trong JVM</span></a></h1><blockquote><p>Các vùng nhớ như bộ đếm chương trình, ngăn xếp ảo và ngăn xếp phương thức cùng với các vùng nhớ này đều thuộc về từng luồng riêng biệt và chỉ tồn tại trong suốt vòng đời của luồng. Sau khi luồng kết thúc, các vùng nhớ này cũng sẽ biến mất, do đó không cần thu gom rác cho các vùng nhớ này. <strong>Thu gom rác chủ yếu được thực hiện trên Java Heap và Method Area</strong>.</p></blockquote><h2 id="đoi-tuong-con-song-hay-đa-chet" tabindex="-1"><a class="header-anchor" href="#đoi-tuong-con-song-hay-đa-chet"><span>Đối tượng còn sống hay đã chết</span></a></h2><h3 id="thuat-toan-đem-tham-chieu" tabindex="-1"><a class="header-anchor" href="#thuat-toan-đem-tham-chieu"><span>Thuật toán đếm tham chiếu</span></a></h3><p>Thêm một bộ đếm tham chiếu cho đối tượng, khi đối tượng được tham chiếu thì bộ đếm tăng lên 1, khi tham chiếu mất hiệu lực thì bộ đếm giảm đi 1. Đối tượng có bộ đếm tham chiếu bằng 0 có thể bị thu gom.</p><p>Tuy nhiên, trong trường hợp hai đối tượng tham chiếu lẫn nhau, bộ đếm tham chiếu sẽ không bao giờ bằng 0, dẫn đến không thể thu gom được các đối tượng này.</p><div class="language-java" data-ext="java" data-title="java"><pre class="shiki shiki-themes one-dark-pro one-dark-pro vp-code" style="background-color:#282c34;--shiki-dark-bg:#282c34;color:#abb2bf;--shiki-dark:#abb2bf;" tabindex="0"><code><span class="line"><span style="color:#C678DD;--shiki-dark:#C678DD;">public</span><span style="color:#C678DD;--shiki-dark:#C678DD;"> class</span><span style="color:#E5C07B;--shiki-dark:#E5C07B;"> ReferenceCountingGC</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="color:#C678DD;--shiki-dark:#C678DD;">    public</span><span style="color:#E5C07B;--shiki-dark:#E5C07B;"> Object</span><span style="color:#E06C75;--shiki-dark:#E06C75;"> instance </span><span style="color:#56B6C2;--shiki-dark:#56B6C2;">=</span><span style="color:#D19A66;--shiki-dark:#D19A66;"> null</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#C678DD;--shiki-dark:#C678DD;">    public</span><span style="color:#C678DD;--shiki-dark:#C678DD;"> static</span><span style="color:#C678DD;--shiki-dark:#C678DD;"> void</span><span style="color:#61AFEF;--shiki-dark:#61AFEF;"> main</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">(</span><span style="color:#E5C07B;--shiki-dark:#E5C07B;">String</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">[] </span><span style="color:#E06C75;--shiki-dark:#E06C75;font-style:italic;--shiki-dark-font-style:italic;">args</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">)</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="color:#E5C07B;--shiki-dark:#E5C07B;">        ReferenceCountingGC</span><span style="color:#E06C75;--shiki-dark:#E06C75;"> objectA</span><span style="color:#56B6C2;--shiki-dark:#56B6C2;"> =</span><span style="color:#C678DD;--shiki-dark:#C678DD;"> new</span><span style="color:#61AFEF;--shiki-dark:#61AFEF;"> ReferenceCountingGC</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">();</span></span>
<span class="line"><span style="color:#E5C07B;--shiki-dark:#E5C07B;">        ReferenceCountingGC</span><span style="color:#E06C75;--shiki-dark:#E06C75;"> objectB</span><span style="color:#56B6C2;--shiki-dark:#56B6C2;"> =</span><span style="color:#C678DD;--shiki-dark:#C678DD;"> new</span><span style="color:#61AFEF;--shiki-dark:#61AFEF;"> ReferenceCountingGC</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">();</span></span>
<span class="line"><span style="color:#E5C07B;--shiki-dark:#E5C07B;">        objectA</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">.</span><span style="color:#E5C07B;--shiki-dark:#E5C07B;">instance</span><span style="color:#56B6C2;--shiki-dark:#56B6C2;"> =</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;"> objectB;</span></span>
<span class="line"><span style="color:#E5C07B;--shiki-dark:#E5C07B;">        objectB</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">.</span><span style="color:#E5C07B;--shiki-dark:#E5C07B;">instance</span><span style="color:#56B6C2;--shiki-dark:#56B6C2;"> =</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;"> objectA;</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">    }</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">}</span></span></code></pre></div><p>Vì sự tồn tại của tham chiếu lẫn nhau, nên <strong>Java Virtual Machine không sử dụng thuật toán đếm tham chiếu</strong>.</p><h3 id="thuat-toan-phan-tich-kha-nang-tiep-can" tabindex="-1"><a class="header-anchor" href="#thuat-toan-phan-tich-kha-nang-tiep-can"><span>Thuật toán phân tích khả năng tiếp cận</span></a></h3><p>Dựa trên các <strong>GC Roots</strong> làm điểm bắt đầu để tìm kiếm, JVM coi các đối tượng mà có thể tiếp cận được từ GC Roots là <strong>còn sống</strong>, các đối tượng không thể tiếp cận được là <strong>đã chết</strong>.</p><figure><img src="https://raw.githubusercontent.com/vanhung4499/images/master/snap/20230718153129.png" alt="image.png" tabindex="0" loading="lazy"><figcaption>image.png</figcaption></figure><p><strong>Các đối tượng có thể là GC Roots</strong> bao gồm:</p><ul><li>Đối tượng được tham chiếu trong ngăn xếp ảo</li><li>Đối tượng được tham chiếu trong ngăn xếp phương thức (phương thức Native)</li><li>Đối tượng được tham chiếu trong vùng nhớ phương thức, thuộc tính tĩnh của lớp</li><li>Đối tượng được tham chiếu trong vùng nhớ phương thức, hằng số</li></ul><h3 id="loai-tham-chieu" tabindex="-1"><a class="header-anchor" href="#loai-tham-chieu"><span>Loại tham chiếu</span></a></h3><p>Dù sử dụng thuật toán đếm tham chiếu để xác định số lượng tham chiếu của đối tượng, hay sử dụng thuật toán phân tích khả năng tiếp cận để xác định xem chuỗi tham chiếu có thể tiếp cận được hay không, việc xác định xem đối tượng có thể bị thu gom hay không đều liên quan đến tham chiếu.</p><p>Java có bốn loại tham chiếu với mức độ mạnh yếu khác nhau.</p><h4 id="tham-chieu-manh-strong-reference" tabindex="-1"><a class="header-anchor" href="#tham-chieu-manh-strong-reference"><span>Tham chiếu mạnh (Strong Reference)</span></a></h4><p><strong>Đối tượng được tham chiếu mạnh (Strong Reference) sẽ không bị thu gom bởi bộ thu gom rác.</strong></p><p>Tham chiếu mạnh: Sử dụng cách tạo một đối tượng mới bằng từ khóa <code>new</code>.</p><div class="language-java" data-ext="java" data-title="java"><pre class="shiki shiki-themes one-dark-pro one-dark-pro vp-code" style="background-color:#282c34;--shiki-dark-bg:#282c34;color:#abb2bf;--shiki-dark:#abb2bf;" tabindex="0"><code><span class="line"><span style="color:#E5C07B;--shiki-dark:#E5C07B;">Object</span><span style="color:#E06C75;--shiki-dark:#E06C75;"> obj </span><span style="color:#56B6C2;--shiki-dark:#56B6C2;">=</span><span style="color:#C678DD;--shiki-dark:#C678DD;"> new</span><span style="color:#61AFEF;--shiki-dark:#61AFEF;"> Object</span><span style="color:#E06C75;--shiki-dark:#E06C75;">()</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">;</span></span></code></pre></div><h4 id="tham-chieu-mem-soft-reference" tabindex="-1"><a class="header-anchor" href="#tham-chieu-mem-soft-reference"><span>Tham chiếu mềm (Soft Reference)</span></a></h4><p><strong>Đối tượng được tham chiếu mềm (Soft Reference) chỉ bị thu gom khi bộ nhớ không đủ.</strong></p><p>Tham chiếu mềm: Sử dụng lớp <code>SoftReference</code> để tạo tham chiếu mềm.</p><div class="language-java" data-ext="java" data-title="java"><pre class="shiki shiki-themes one-dark-pro one-dark-pro vp-code" style="background-color:#282c34;--shiki-dark-bg:#282c34;color:#abb2bf;--shiki-dark:#abb2bf;" tabindex="0"><code><span class="line"><span style="color:#E5C07B;--shiki-dark:#E5C07B;">Object</span><span style="color:#E06C75;--shiki-dark:#E06C75;"> obj </span><span style="color:#56B6C2;--shiki-dark:#56B6C2;">=</span><span style="color:#C678DD;--shiki-dark:#C678DD;"> new</span><span style="color:#61AFEF;--shiki-dark:#61AFEF;"> Object</span><span style="color:#E06C75;--shiki-dark:#E06C75;">()</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#E5C07B;--shiki-dark:#E5C07B;">SoftReference</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">&lt;</span><span style="color:#E5C07B;--shiki-dark:#E5C07B;">Object</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">&gt;</span><span style="color:#E06C75;--shiki-dark:#E06C75;"> sf </span><span style="color:#56B6C2;--shiki-dark:#56B6C2;">=</span><span style="color:#C678DD;--shiki-dark:#C678DD;"> new</span><span style="color:#E5C07B;--shiki-dark:#E5C07B;"> SoftReference</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">&lt;</span><span style="color:#E5C07B;--shiki-dark:#E5C07B;">Object</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">&gt;</span><span style="color:#E06C75;--shiki-dark:#E06C75;">(obj)</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#E06C75;--shiki-dark:#E06C75;">obj </span><span style="color:#56B6C2;--shiki-dark:#56B6C2;">=</span><span style="color:#D19A66;--shiki-dark:#D19A66;"> null</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">;</span><span style="color:#7F848E;--shiki-dark:#7F848E;font-style:italic;--shiki-dark-font-style:italic;"> // Đối tượng chỉ được tham chiếu mềm</span></span></code></pre></div><h4 id="tham-chieu-yeu-weak-reference" tabindex="-1"><a class="header-anchor" href="#tham-chieu-yeu-weak-reference"><span>Tham chiếu yếu (Weak Reference)</span></a></h4><p><strong>Đối tượng được tham chiếu yếu (Weak Reference) sẽ bị thu gom chắc chắn, tức là chỉ tồn tại đến lần thu gom rác tiếp theo.</strong></p><p>Sử dụng lớp <code>WeakReference</code> để tạo tham chiếu yếu.</p><div class="language-java" data-ext="java" data-title="java"><pre class="shiki shiki-themes one-dark-pro one-dark-pro vp-code" style="background-color:#282c34;--shiki-dark-bg:#282c34;color:#abb2bf;--shiki-dark:#abb2bf;" tabindex="0"><code><span class="line"><span style="color:#E5C07B;--shiki-dark:#E5C07B;">Object</span><span style="color:#E06C75;--shiki-dark:#E06C75;"> obj </span><span style="color:#56B6C2;--shiki-dark:#56B6C2;">=</span><span style="color:#C678DD;--shiki-dark:#C678DD;"> new</span><span style="color:#61AFEF;--shiki-dark:#61AFEF;"> Object</span><span style="color:#E06C75;--shiki-dark:#E06C75;">()</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#E5C07B;--shiki-dark:#E5C07B;">WeakReference</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">&lt;</span><span style="color:#E5C07B;--shiki-dark:#E5C07B;">Object</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">&gt;</span><span style="color:#E06C75;--shiki-dark:#E06C75;"> wf </span><span style="color:#56B6C2;--shiki-dark:#56B6C2;">=</span><span style="color:#C678DD;--shiki-dark:#C678DD;"> new</span><span style="color:#E5C07B;--shiki-dark:#E5C07B;"> WeakReference</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">&lt;</span><span style="color:#E5C07B;--shiki-dark:#E5C07B;">Object</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">&gt;</span><span style="color:#E06C75;--shiki-dark:#E06C75;">(obj)</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#E06C75;--shiki-dark:#E06C75;">obj </span><span style="color:#56B6C2;--shiki-dark:#56B6C2;">=</span><span style="color:#D19A66;--shiki-dark:#D19A66;"> null</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">;</span></span></code></pre></div><p><code>Entry</code> trong <code>WeakHashMap</code> kế thừa từ <code>WeakReference</code>, được sử dụng để thực hiện chức năng bộ nhớ đệm.</p><div class="language-java" data-ext="java" data-title="java"><pre class="shiki shiki-themes one-dark-pro one-dark-pro vp-code" style="background-color:#282c34;--shiki-dark-bg:#282c34;color:#abb2bf;--shiki-dark:#abb2bf;" tabindex="0"><code><span class="line"><span style="color:#C678DD;--shiki-dark:#C678DD;">private</span><span style="color:#C678DD;--shiki-dark:#C678DD;"> static</span><span style="color:#C678DD;--shiki-dark:#C678DD;"> class</span><span style="color:#E5C07B;--shiki-dark:#E5C07B;"> Entry</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">&lt;</span><span style="color:#E5C07B;--shiki-dark:#E5C07B;">K</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">,</span><span style="color:#E5C07B;--shiki-dark:#E5C07B;">V</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">&gt;</span><span style="color:#C678DD;--shiki-dark:#C678DD;"> extends</span><span style="color:#E5C07B;--shiki-dark:#E5C07B;"> WeakReference</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">&lt;</span><span style="color:#E5C07B;--shiki-dark:#E5C07B;">Object</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">&gt;</span><span style="color:#C678DD;--shiki-dark:#C678DD;"> implements</span><span style="color:#E5C07B;--shiki-dark:#E5C07B;"> Map</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">.</span><span style="color:#E5C07B;--shiki-dark:#E5C07B;">Entry</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">&lt;</span><span style="color:#E5C07B;--shiki-dark:#E5C07B;">K</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">,</span><span style="color:#E5C07B;--shiki-dark:#E5C07B;">V</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">&gt;</span></span></code></pre></div><p><code>ConcurrentCache</code> trong Tomcat sử dụng <code>WeakHashMap</code> để thực hiện chức năng bộ nhớ đệm. <code>ConcurrentCache</code> sử dụng bộ nhớ đệm theo thế hệ, đối tượng được sử dụng thường xuyên được đặt trong eden, trong khi đối tượng không được sử dụng thường xuyên được đặt trong longterm. Eden sử dụng <code>ConcurrentHashMap</code> để thực hiện, longterm sử dụng <code>WeakHashMap</code>, đảm bảo rằng các đối tượng không được sử dụng thường xuyên dễ dàng bị thu gom.</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="shiki shiki-themes one-dark-pro one-dark-pro vp-code" style="background-color:#282c34;--shiki-dark-bg:#282c34;color:#abb2bf;--shiki-dark:#abb2bf;" tabindex="0"><code><span class="line"><span style="color:#C678DD;--shiki-dark:#C678DD;">public</span><span style="color:#C678DD;--shiki-dark:#C678DD;"> final</span><span style="color:#C678DD;--shiki-dark:#C678DD;"> class</span><span style="color:#E5C07B;--shiki-dark:#E5C07B;"> ConcurrentCache</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">&lt;</span><span style="color:#E5C07B;--shiki-dark:#E5C07B;">K</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">,</span><span style="color:#E5C07B;--shiki-dark:#E5C07B;"> V</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">&gt;</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"></span>
<span class="line"><span style="color:#C678DD;--shiki-dark:#C678DD;">    private</span><span style="color:#C678DD;--shiki-dark:#C678DD;"> final</span><span style="color:#C678DD;--shiki-dark:#C678DD;"> int</span><span style="color:#E06C75;--shiki-dark:#E06C75;"> size</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#C678DD;--shiki-dark:#C678DD;">    private</span><span style="color:#C678DD;--shiki-dark:#C678DD;"> final</span><span style="color:#E5C07B;--shiki-dark:#E5C07B;"> Map</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">&lt;</span><span style="color:#E5C07B;--shiki-dark:#E5C07B;">K</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">,</span><span style="color:#E5C07B;--shiki-dark:#E5C07B;"> V</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">&gt;</span><span style="color:#E06C75;--shiki-dark:#E06C75;"> eden</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#C678DD;--shiki-dark:#C678DD;">    private</span><span style="color:#C678DD;--shiki-dark:#C678DD;"> final</span><span style="color:#E5C07B;--shiki-dark:#E5C07B;"> Map</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">&lt;</span><span style="color:#E5C07B;--shiki-dark:#E5C07B;">K</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">,</span><span style="color:#E5C07B;--shiki-dark:#E5C07B;"> V</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">&gt;</span><span style="color:#E06C75;--shiki-dark:#E06C75;"> longterm</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#C678DD;--shiki-dark:#C678DD;">    public</span><span style="color:#61AFEF;--shiki-dark:#61AFEF;"> ConcurrentCache</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">(</span><span style="color:#C678DD;--shiki-dark:#C678DD;">int</span><span style="color:#E06C75;--shiki-dark:#E06C75;font-style:italic;--shiki-dark-font-style:italic;"> size</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">)</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="color:#E5C07B;--shiki-dark:#E5C07B;">        this</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">.</span><span style="color:#E5C07B;--shiki-dark:#E5C07B;">size</span><span style="color:#56B6C2;--shiki-dark:#56B6C2;"> =</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;"> size;</span></span>
<span class="line"><span style="color:#E5C07B;--shiki-dark:#E5C07B;">        this</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">.</span><span style="color:#E5C07B;--shiki-dark:#E5C07B;">eden</span><span style="color:#56B6C2;--shiki-dark:#56B6C2;"> =</span><span style="color:#C678DD;--shiki-dark:#C678DD;"> new</span><span style="color:#E5C07B;--shiki-dark:#E5C07B;"> ConcurrentHashMap</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">&lt;&gt;(size);</span></span>
<span class="line"><span style="color:#E5C07B;--shiki-dark:#E5C07B;">        this</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">.</span><span style="color:#E5C07B;--shiki-dark:#E5C07B;">longterm</span><span style="color:#56B6C2;--shiki-dark:#56B6C2;"> =</span><span style="color:#C678DD;--shiki-dark:#C678DD;"> new</span><span style="color:#E5C07B;--shiki-dark:#E5C07B;"> WeakHashMap</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">&lt;&gt;(size);</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#C678DD;--shiki-dark:#C678DD;">    public</span><span style="color:#E5C07B;--shiki-dark:#E5C07B;"> V</span><span style="color:#61AFEF;--shiki-dark:#61AFEF;"> get</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">(</span><span style="color:#E5C07B;--shiki-dark:#E5C07B;">K</span><span style="color:#E06C75;--shiki-dark:#E06C75;font-style:italic;--shiki-dark-font-style:italic;"> k</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">)</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="color:#E5C07B;--shiki-dark:#E5C07B;">        V</span><span style="color:#E06C75;--shiki-dark:#E06C75;"> v</span><span style="color:#56B6C2;--shiki-dark:#56B6C2;"> =</span><span style="color:#E5C07B;--shiki-dark:#E5C07B;"> this</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">.</span><span style="color:#E5C07B;--shiki-dark:#E5C07B;">eden</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">.</span><span style="color:#61AFEF;--shiki-dark:#61AFEF;">get</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">(k);</span></span>
<span class="line"><span style="color:#C678DD;--shiki-dark:#C678DD;">        if</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;"> (v </span><span style="color:#56B6C2;--shiki-dark:#56B6C2;">==</span><span style="color:#D19A66;--shiki-dark:#D19A66;"> null</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">) {</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">            v </span><span style="color:#56B6C2;--shiki-dark:#56B6C2;">=</span><span style="color:#E5C07B;--shiki-dark:#E5C07B;"> this</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">.</span><span style="color:#E5C07B;--shiki-dark:#E5C07B;">longterm</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">.</span><span style="color:#61AFEF;--shiki-dark:#61AFEF;">get</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">(k);</span></span>
<span class="line"><span style="color:#C678DD;--shiki-dark:#C678DD;">            if</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;"> (v </span><span style="color:#56B6C2;--shiki-dark:#56B6C2;">!=</span><span style="color:#D19A66;--shiki-dark:#D19A66;"> null</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">)</span></span>
<span class="line"><span style="color:#E5C07B;--shiki-dark:#E5C07B;">                this</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">.</span><span style="color:#E5C07B;--shiki-dark:#E5C07B;">eden</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">.</span><span style="color:#61AFEF;--shiki-dark:#61AFEF;">put</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">(k, v);</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">        }</span></span>
<span class="line"><span style="color:#C678DD;--shiki-dark:#C678DD;">        return</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;"> v;</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#C678DD;--shiki-dark:#C678DD;">    public</span><span style="color:#C678DD;--shiki-dark:#C678DD;"> void</span><span style="color:#61AFEF;--shiki-dark:#61AFEF;"> put</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">(</span><span style="color:#E5C07B;--shiki-dark:#E5C07B;">K</span><span style="color:#E06C75;--shiki-dark:#E06C75;font-style:italic;--shiki-dark-font-style:italic;"> k</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">, </span><span style="color:#E5C07B;--shiki-dark:#E5C07B;">V</span><span style="color:#E06C75;--shiki-dark:#E06C75;font-style:italic;--shiki-dark-font-style:italic;"> v</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">)</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="color:#C678DD;--shiki-dark:#C678DD;">        if</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;"> (</span><span style="color:#E5C07B;--shiki-dark:#E5C07B;">this</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">.</span><span style="color:#E5C07B;--shiki-dark:#E5C07B;">eden</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">.</span><span style="color:#61AFEF;--shiki-dark:#61AFEF;">size</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">() </span><span style="color:#56B6C2;--shiki-dark:#56B6C2;">&gt;=</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;"> size) {</span></span>
<span class="line"><span style="color:#E5C07B;--shiki-dark:#E5C07B;">            this</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">.</span><span style="color:#E5C07B;--shiki-dark:#E5C07B;">longterm</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">.</span><span style="color:#61AFEF;--shiki-dark:#61AFEF;">putAll</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">(</span><span style="color:#E5C07B;--shiki-dark:#E5C07B;">this</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">.</span><span style="color:#E5C07B;--shiki-dark:#E5C07B;">eden</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="color:#E5C07B;--shiki-dark:#E5C07B;">            this</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">.</span><span style="color:#E5C07B;--shiki-dark:#E5C07B;">eden</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">.</span><span style="color:#61AFEF;--shiki-dark:#61AFEF;">clear</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">();</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">        }</span></span>
<span class="line"><span style="color:#E5C07B;--shiki-dark:#E5C07B;">        this</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">.</span><span style="color:#E5C07B;--shiki-dark:#E5C07B;">eden</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">.</span><span style="color:#61AFEF;--shiki-dark:#61AFEF;">put</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">(k, v);</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">    }</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="tham-chieu-ao-phantom-reference" tabindex="-1"><a class="header-anchor" href="#tham-chieu-ao-phantom-reference"><span>Tham chiếu ảo (Phantom Reference)</span></a></h4><p>Còn được gọi là tham chiếu ma hoặc tham chiếu ảo. Sự tồn tại của một tham chiếu ảo không ảnh hưởng đến thời gian sống của một đối tượng, và không thể truy cập được một thể hiện đối tượng.</p><p><strong>Mục đích duy nhất của việc thiết lập một tham chiếu ảo cho một đối tượng là để nhận được một thông báo hệ thống khi đối tượng đó bị thu gom.</strong></p><p>Sử dụng lớp <code>PhantomReference</code> để tạo tham chiếu ảo.</p><div class="language-java" data-ext="java" data-title="java"><pre class="shiki shiki-themes one-dark-pro one-dark-pro vp-code" style="background-color:#282c34;--shiki-dark-bg:#282c34;color:#abb2bf;--shiki-dark:#abb2bf;" tabindex="0"><code><span class="line"><span style="color:#E5C07B;--shiki-dark:#E5C07B;">Object</span><span style="color:#E06C75;--shiki-dark:#E06C75;"> obj </span><span style="color:#56B6C2;--shiki-dark:#56B6C2;">=</span><span style="color:#C678DD;--shiki-dark:#C678DD;"> new</span><span style="color:#61AFEF;--shiki-dark:#61AFEF;"> Object</span><span style="color:#E06C75;--shiki-dark:#E06C75;">()</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#E5C07B;--shiki-dark:#E5C07B;">PhantomReference</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">&lt;</span><span style="color:#E5C07B;--shiki-dark:#E5C07B;">Object</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">&gt;</span><span style="color:#E06C75;--shiki-dark:#E06C75;"> pf </span><span style="color:#56B6C2;--shiki-dark:#56B6C2;">=</span><span style="color:#C678DD;--shiki-dark:#C678DD;"> new</span><span style="color:#E5C07B;--shiki-dark:#E5C07B;"> PhantomReference</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">&lt;</span><span style="color:#E5C07B;--shiki-dark:#E5C07B;">Object</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">&gt;</span><span style="color:#E06C75;--shiki-dark:#E06C75;">(obj)</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#E06C75;--shiki-dark:#E06C75;">obj </span><span style="color:#56B6C2;--shiki-dark:#56B6C2;">=</span><span style="color:#D19A66;--shiki-dark:#D19A66;"> null</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">;</span></span></code></pre></div><h3 id="thu-gom-vung-phuong-thuc" tabindex="-1"><a class="header-anchor" href="#thu-gom-vung-phuong-thuc"><span>Thu gom vùng phương thức</span></a></h3><p>Vì vùng phương thức chủ yếu chứa các đối tượng trong không gian vĩnh viễn, và tỷ lệ thu gom của các đối tượng trong không gian vĩnh viễn thấp hơn so với không gian trẻ, nên việc thu gom rác trên vùng phương thức không hiệu quả.</p><p>Chủ yếu là thu gom rác trong bộ nhớ hằng số và hủy bỏ lớp.</p><p>Có nhiều điều kiện để hủy bỏ một lớp, phải đáp ứng ba điều kiện sau và không đảm bảo rằng lớp sẽ bị hủy bỏ:</p><ul><li>Tất cả các thể hiện của lớp đã được thu gom, nghĩa là không có thể hiện của lớp nào tồn tại trong Java Heap.</li><li><code>ClassLoader</code> tải lớp đã bị thu gom.</li><li>Đối tượng <code>java.lang.Class</code> tương ứng với lớp không được tham chiếu ở bất kỳ đâu, nghĩa là không thể truy cập vào phương thức của lớp đó ở bất kỳ đâu bằng cách phản chiếu.</li></ul><p>Có thể sử dụng tham số <code>-Xnoclassgc</code> để kiểm soát việc hủy bỏ lớp.</p><p>Trong các tình huống sử dụng nhiều phản chiếu, đại diện động, CGLib và tạo JSP động và OSGi, cần có khả năng hủy bỏ lớp trong máy ảo để đảm bảo không xảy ra lỗi tràn bộ nhớ.</p><h3 id="thu-gom-vung-phuong-thuc-1" tabindex="-1"><a class="header-anchor" href="#thu-gom-vung-phuong-thuc-1"><span>Thu gom vùng phương thức</span></a></h3><p>Vì vùng phương thức chủ yếu chứa các đối tượng trong không gian vĩnh viễn, và tỷ lệ thu gom của các đối tượng trong không gian vĩnh viễn thấp hơn so với không gian trẻ, nên việc thu gom rác trên vùng phương thức không hiệu quả.</p><p>Chủ yếu là thu gom rác trong vùng hằng số và hủy bỏ lớp.</p><p>Có nhiều điều kiện để hủy bỏ một lớp, phải đáp ứng ba điều kiện sau và không đảm bảo rằng lớp sẽ bị hủy bỏ:</p><ul><li>Tất cả các thể hiện của lớp đã được thu gom, nghĩa là không có thể hiện của lớp nào tồn tại trong Java Heap.</li><li><code>ClassLoader</code> tải lớp đã bị thu gom.</li><li>Đối tượng <code>java.lang.Class</code> tương ứng với lớp không được tham chiếu ở bất kỳ đâu, nghĩa là không thể truy cập vào phương thức của lớp đó ở bất kỳ đâu bằng cách phản chiếu.</li></ul><p>Có thể sử dụng tham số <code>-Xnoclassgc</code> để kiểm soát việc hủy bỏ lớp.</p><p>Trong các tình huống sử dụng nhiều phản chiếu, đại diện động, CGLib và tạo JSP động và OSGi, cần có khả năng hủy bỏ lớp trong máy ảo để đảm bảo không xảy ra lỗi tràn bộ nhớ.</p><h3 id="finalize" tabindex="-1"><a class="header-anchor" href="#finalize"><span>finalize()</span></a></h3><p><code>finalize()</code> tương tự như hàm hủy trong C++, được sử dụng để thực hiện các công việc như đóng tài nguyên bên ngoài. Tuy nhiên, việc sử dụng <code>try-finally</code> hoặc các cách khác có thể tốt hơn và phương thức này có chi phí thực thi cao, không chắc chắn và không đảm bảo thứ tự gọi của các đối tượng, do đó <strong>không nên sử dụng <code>finalize()</code></strong>.</p><p>Khi một đối tượng có thể được thu gom, nếu cần thực thi phương thức <code>finalize()</code> của đối tượng đó, có thể làm cho đối tượng được tham chiếu lại và tự cứu mình.</p><h2 id="thuat-toan-thu-gom-rac" tabindex="-1"><a class="header-anchor" href="#thuat-toan-thu-gom-rac"><span>Thuật toán thu gom rác</span></a></h2><h3 id="hieu-suat-thu-gom-rac" tabindex="-1"><a class="header-anchor" href="#hieu-suat-thu-gom-rac"><span>Hiệu suất thu gom rác</span></a></h3><p>Có hai chỉ số chính để đánh giá hiệu suất của bộ thu gom rác:</p><ul><li><strong>Thời gian tạm dừng</strong> - Thời gian mà chương trình không thể hoạt động do quá trình thu gom rác.</li><li><strong>Thông lượng</strong> - Tổng số công việc mà ứng dụng có thể thực hiện trong một khoảng thời gian cố định. Đối với các ứng dụng quan tâm đến thông lượng, thời gian tạm dừng dài có thể chấp nhận được. Vì các ứng dụng có thống suất cao thường tập trung vào chu kỳ thời gian dài hơn, nên thời gian phản hồi nhanh không được xem xét.</li></ul><h3 id="đanh-dau-don-dep-mark-sweep" tabindex="-1"><a class="header-anchor" href="#đanh-dau-don-dep-mark-sweep"><span>Đánh dấu - Dọn dẹp (Mark-Sweep)</span></a></h3><figure><img src="https://raw.githubusercontent.com/vanhung4499/images/master/snap/20230718172452.png" alt="image.png" tabindex="0" loading="lazy"><figcaption>image.png</figcaption></figure><p>Đánh dấu các đối tượng cần thu gom, sau đó dọn dẹp các đối tượng đã được đánh dấu.</p><p>Nhược điểm:</p><ul><li>Hiệu suất đánh dấu và dọn dẹp đều không cao.</li><li>Tạo ra nhiều mảnh bộ nhớ không liên tục, dẫn đến không thể cấp phát bộ nhớ cho các đối tượng lớn.</li></ul><h3 id="đanh-dau-sap-xep-mark-compact" tabindex="-1"><a class="header-anchor" href="#đanh-dau-sap-xep-mark-compact"><span>Đánh dấu - Sắp xếp (Mark-Compact)</span></a></h3><figure><img src="https://raw.githubusercontent.com/vanhung4499/images/master/snap/20230718172523.png" alt="image.png" tabindex="0" loading="lazy"><figcaption>image.png</figcaption></figure><p>Di chuyển tất cả các đối tượng còn sống về một đầu, sau đó xóa bỏ bộ nhớ ở phía bên ngoài ranh giới.</p><p>Phương pháp này giải quyết được vấn đề về mảnh bộ nhớ không liên tục, nhưng đồng thời tăng chi phí thực hiện của thuật toán nén.</p><h3 id="sao-chep-copying" tabindex="-1"><a class="header-anchor" href="#sao-chep-copying"><span>Sao chép (Copying)</span></a></h3><figure><img src="https://raw.githubusercontent.com/vanhung4499/images/master/snap/20230718172532.png" alt="image.png" tabindex="0" loading="lazy"><figcaption>image.png</figcaption></figure><p>Chia bộ nhớ thành hai phần bằng nhau, chỉ sử dụng một phần trong mỗi lần. Khi phần này đầy, các đối tượng còn sống sẽ được sao chép sang phần còn lại, sau đó xóa bỏ phần đã sử dụng.</p><p>Nhược điểm chính là chỉ sử dụng được một nửa bộ nhớ.</p><p>Hiện nay, các máy ảo thương mại sử dụng thuật toán này để thu gom thế hệ trẻ, nhưng không phải chia bộ nhớ thành hai phần bằng nhau, mà chia thành một phần Eden lớn hơn và hai phần Survivor nhỏ hơn. Mỗi lần thu gom, các đối tượng còn sống trong Eden và Survivor sẽ được sao chép sang Survivor còn lại, sau đó dọn dẹp Eden và Survivor đã sử dụng. Kích thước mặc định của Eden và Survivor trong HotSpot VM là 8:1 (có thể điều chỉnh bằng tham số<code> -XX:SurvivorRatio</code>), đảm bảo sử dụng bộ nhớ hiệu quả đạt 90%. Nếu có hơn 10% đối tượng sống sau mỗi lần thu gom, một Survivor không đủ, và cần sự hỗ trợ từ thế hệ cũ để cấp phát bộ nhớ cho các đối tượng không thể lưu trữ trong Survivor.</p><h2 id="thuat-toan-thu-gom-rac-theo-the-he" tabindex="-1"><a class="header-anchor" href="#thuat-toan-thu-gom-rac-theo-the-he"><span>Thuật toán thu gom rác theo thế hệ</span></a></h2><p>Các máy ảo hiện đại sử dụng thuật toán thu gom rác theo thế hệ, chia bộ nhớ thành các thế hệ dựa trên tuổi thọ của đối tượng và sử dụng thuật toán thu gom phù hợp cho từng thế hệ.</p><p>Thường thì Java Heap được chia thành thế hệ trẻ và thế hệ già.</p><ul><li>Thế hệ trẻ sử dụng thuật toán <strong>sao chép</strong>.</li><li>Thế hệ già sử dụng thuật toán <strong>đánh dấu - dọn dẹp</strong> hoặc <strong>đánh dấu - sắp xếp</strong>.</li></ul><div align="center"><img src="https://raw.githubusercontent.com/dunwu/images/dev/cs/java/javacore/jvm/jvm-hotspot-heap-structure.png"></div><h4 id="the-he-tre" tabindex="-1"><a class="header-anchor" href="#the-he-tre"><span>Thế hệ trẻ</span></a></h4><p>Thế hệ trẻ là nơi tạo ra và hủy bỏ đa số các đối tượng, trong ứng dụng Java thông thường, hầu hết các đối tượng có tuổi thọ ngắn. Nó được chia thành khu vực <code>Eden</code>, là nơi đối tượng được cấp phát ban đầu, và hai khu vực <code>Survivor</code>, đôi khi được gọi là <code>from</code> và <code>to</code>, được sử dụng để lưu trữ các đối tượng được giữ lại từ quá trình thu gom nhỏ trước đó.</p><p>JVM sẽ chọn ngẫu nhiên một khu vực <code>Survivor</code> làm <code>to</code>, và trong quá trình thu gom rác, các đối tượng sống sót trong <code>Eden</code> và khu vực <code>from</code> sẽ được sao chép vào khu vực <code>to</code>. Thiết kế này nhằm mục đích ngăn chặn sự phân mảnh bộ nhớ và tiếp tục làm sạch các đối tượng không sử dụng.</p><p>Java Virtual Machine sẽ ghi lại số lần sao chép của các đối tượng trong khu vực <code>Survivor</code>. Nếu một đối tượng đã được sao chép 15 lần (tương ứng với tham số <code>-XX:+MaxTenuringThreshold</code> của máy ảo), đối tượng đó sẽ được thăng chuyển (promote) lên thế hệ già. Ngoài ra, nếu một khu vực <code>Survivor</code> đã sử dụng 50% (tương ứng với tham số <code>-XX:TargetSurvivorRatio</code> của máy ảo), các đối tượng có số lần sao chép cao hơn cũng sẽ được thăng chuyển lên thế hệ già.</p><h4 id="the-he-gia" tabindex="-1"><a class="header-anchor" href="#the-he-gia"><span>Thế hệ già</span></a></h4><p>Thế hệ già chứa các đối tượng có tuổi thọ dài, thường là các đối tượng đã tồn tại trong thế hệ trẻ và đã được sao chép nhiều lần. Khi không còn đủ không gian trong thế hệ trẻ để sao chép các đối tượng, JVM sẽ chuyển chúng trực tiếp vào thế hệ già.</p><h4 id="vung-vinh-vien" tabindex="-1"><a class="header-anchor" href="#vung-vinh-vien"><span>Vùng vĩnh viễn</span></a></h4><p>Đây là phần của phương pháp thực hiện của JVM trước đây, lưu trữ các siêu dữ liệu lớp Java, bảng hằng số và bộ đệm chuỗi Intern. Từ JDK 8 trở đi, không còn Vùng vĩnh viễn này nữa.</p><h4 id="tham-so-jvm" tabindex="-1"><a class="header-anchor" href="#tham-so-jvm"><span>Tham số JVM</span></a></h4><p>Dưới đây là một số tham số JVM cho phép điều chỉnh kích thước của Heap, các thế hệ và các vùng nhớ liên quan:</p><table><thead><tr><th>Cấu hình</th><th>Mô tả</th></tr></thead><tbody><tr><td><code>-Xss</code></td><td>Kích thước ngăn xếp của máy ảo.</td></tr><tr><td><code>-Xms</code></td><td>Giá trị khởi tạo của Heap.</td></tr><tr><td><code>-Xmx</code></td><td>Giá trị tối đa của Heap.</td></tr><tr><td><code>-Xmn</code></td><td>Kích thước của thế hệ trẻ.</td></tr><tr><td><code>-XX:NewSize</code></td><td>Giá trị khởi tạo của thế hệ trẻ.</td></tr><tr><td><code>-XX:MaxNewSize</code></td><td>Giá trị tối đa của thế hệ trẻ.</td></tr><tr><td><code>-XX:NewRatio</code></td><td>Tỷ lệ giữa thế hệ trẻ và thế hệ già. Mặc định là 2, tức là thế hệ già gấp đôi thế hệ trẻ.</td></tr><tr><td><code>-XX:SurvivorRatio</code></td><td>Tỷ lệ giữa khu vực Eden và khu vực Survivor. Mặc định là 8, tức là khu vực <code>eden</code> chiếm 80% kích thước, hai khu vực <code>survivor</code> mỗi khu vực chiếm 10% kích thước.</td></tr><tr><td><code>-XX:PermSize</code></td><td>Giá trị khởi tạo của Vùng vĩnh viễn.</td></tr><tr><td><code>-XX:MaxPermSize</code></td><td>Giá trị tối đa của Vùng vĩnh viễn.</td></tr></tbody></table><h2 id="bo-thu-gom-rac" tabindex="-1"><a class="header-anchor" href="#bo-thu-gom-rac"><span>Bộ thu gom rác</span></a></h2><div align="center"><img src="https://raw.githubusercontent.com/dunwu/images/dev/cs/java/javacore/jvm/jvm-gc-overview.jpg"></div><p>Trên đây là 7 bộ thu gom rác trong máy ảo HotSpot, các đường kết nối biểu thị các bộ thu gom rác có thể được sử dụng cùng nhau.</p><p>Chú thích: Bộ thu gom rác G1 có thể thu gom bộ nhớ của cả thế hệ trẻ và thế hệ già. Trong khi đó, các bộ thu gom rác khác chỉ có thể thu gom bộ nhớ của một thế hệ cụ thể.</p><h3 id="bo-thu-gom-rac-tuan-tu" tabindex="-1"><a class="header-anchor" href="#bo-thu-gom-rac-tuan-tu"><span>Bộ thu gom rác tuần tự</span></a></h3><p>Bộ thu gom rác tuần tự (Serial) là bộ thu gom rác cơ bản nhất và có lịch sử phát triển lâu nhất.</p><p>Bộ thu gom rác tuần tự là cấu hình mặc định của chế độ <code>client</code>. Vì trong chế độ client, bộ nhớ được cấp phát cho máy ảo thường không lớn. Thời gian tạm dừng của bộ thu gom rác Serial khi thu gom thế hệ trẻ vài chục megabyte hoặc cả trăm megabyte có thể kiểm soát trong khoảng hơn một trăm mili giây, miễn là không quá thường xuyên, thời gian tạm dừng này là chấp nhận được.</p><p><strong>Bộ thu gom rác tuần tự sử dụng phương pháp stop-the-world với một luồng để thu gom rác</strong>. Khi không gian bộ nhớ không đủ, bộ thu gom rác tuần tự đặt cờ dừng, chờ tất cả các luồng đều đạt đến điểm an toàn (Safepoint), sau đó luồng ứng dụng tạm dừng, bộ thu gom rác tuần tự bắt đầu làm việc, <strong>sử dụng một luồng để thu gom không gian và sắp xếp lại bộ nhớ</strong>.</p><figure><img src="https://raw.githubusercontent.com/vanhung4499/images/master/snap/20230718201633.png" alt="image.png" tabindex="0" loading="lazy"><figcaption>image.png</figcaption></figure><p>Luồng đơn nghĩa có nghĩa là độ phức tạp thấp hơn, chiếm ít bộ nhớ hơn và hiệu suất thu gom rác cao; nhưng đồng thời cũng có nghĩa là không thể tận dụng hiệu suất đa nhân. Trên thực tế, bộ thu gom rác tuần tự rất phù hợp với các trường hợp có ít bộ nhớ, CPU đơn lõi hoặc CPU hai lõi.</p><h4 id="bo-thu-gom-rac-serial" tabindex="-1"><a class="header-anchor" href="#bo-thu-gom-rac-serial"><span>Bộ thu gom rác Serial</span></a></h4><blockquote><p>Bật tùy chọn: <code>-XX:+UseSerialGC</code></p><p>Sau khi bật tùy chọn này, sử dụng bộ thu gom rác <strong>Serial</strong> + <strong>Serial Old</strong> để thu gom bộ nhớ.</p></blockquote><h4 id="bo-thu-gom-rac-serial-old" tabindex="-1"><a class="header-anchor" href="#bo-thu-gom-rac-serial-old"><span>Bộ thu gom rác Serial Old</span></a></h4><p>Serial Old là phiên bản của bộ thu gom rác Serial dành cho thế hệ già, cũng được sử dụng cho máy ảo chế độ <code>client</code>. Nếu sử dụng trong chế độ <code>server</code>, nó có hai mục đích:</p><ul><li>Trong JDK 1.5 và các phiên bản trước đó (trước khi Parallel Old ra đời), nó được sử dụng cùng với bộ thu gom rác Parallel Scavenge.</li><li>Là phương án dự phòng cho bộ thu gom rác CMS, được sử dụng khi xảy ra lỗi thu gom đồng thời Concurrent Mode Failure.</li></ul><h3 id="bo-thu-gom-rac-song-song" tabindex="-1"><a class="header-anchor" href="#bo-thu-gom-rac-song-song"><span>Bộ thu gom rác song song</span></a></h3><blockquote><p>Bật tùy chọn: <code>-XX:+UseParallelGC</code></p><p>Sau khi bật tùy chọn này, sử dụng bộ thu gom rác <strong>Parallel Scavenge</strong> + <strong>Serial Old</strong> để thu gom bộ nhớ.</p><p>Bật tùy chọn: <code>-XX:+UseParallelOldGC</code></p><p>Sau khi bật tùy chọn này, sử dụng bộ thu gom rác <strong>Parallel Scavenge</strong> + <strong>Parallel Old</strong> để thu gom bộ nhớ.</p></blockquote><p>Các bộ thu gom rác khác đều tập trung vào thời gian tạm dừng, trong khi <strong>bộ thu gom rác song song (Parallel) tập trung vào thông lượng (Throughput)</strong>.</p><ul><li>Thời gian tạm dừng càng ngắn thì càng phù hợp với các chương trình cần tương tác với người dùng, thời gian phản hồi tốt có thể cải thiện trải nghiệm người dùng;</li><li>Trong khi đó, thông lượng cao có thể tận dụng hiệu suất CPU một cách hiệu quả, hoàn thành nhanh nhiệm vụ tính toán của chương trình, chủ yếu phù hợp với các nhiệm vụ tính toán nền mà không cần nhiều tương tác.</li></ul><div class="language-" data-ext="" data-title=""><pre class="shiki shiki-themes one-dark-pro one-dark-pro vp-code" style="background-color:#282c34;--shiki-dark-bg:#282c34;color:#abb2bf;--shiki-dark:#abb2bf;" tabindex="0"><code><span class="line"><span>Thông lượng = Thời gian chạy mã người dùng / (Thời gian chạy mã người dùng + Thời gian thu gom rác)</span></span></code></pre></div><p><strong>Bộ thu gom rác song song là bộ thu gom rác mặc định trong chế độ server.</strong></p><p>Bộ thu gom rác song song hoạt động tương tự như bộ thu gom rác tuần tự, đều sử dụng phương pháp stop-the-world, chỉ khác là tạm dừng thực hiện thu gom rác song song. <strong>Bộ thu gom rác song song sử dụng thuật toán sao chép cho thế hệ trẻ và thuật toán đánh dấu-sắp xếp cho thế hệ già</strong>, đồng thời nén bộ nhớ trong quá trình thu gom rác. Bộ thu gom rác song song phù hợp với các tình huống yêu cầu thông lượng cao hơn yêu cầu độ trễ và cung cấp thông lượng tốt nhất trong trường hợp đảm bảo độ trễ tệ nhất.</p><p><strong>Trong các trường hợp quan tâm đến thông lượng và tài nguyên CPU, nên ưu tiên sử dụng bộ thu gom rác Parallel Scavenge + Parallel Old.</strong></p><figure><img src="https://raw.githubusercontent.com/vanhung4499/images/master/snap/20230718202918.png" alt="image.png" tabindex="0" loading="lazy"><figcaption>image.png</figcaption></figure><h4 id="bo-thu-gom-rac-parallel-scavenge" tabindex="-1"><a class="header-anchor" href="#bo-thu-gom-rac-parallel-scavenge"><span>Bộ thu gom rác Parallel Scavenge</span></a></h4><p>Bộ thu gom rác Parallel Scavenge cung cấp hai tham số để kiểm soát thông lượng chính xác, đó là:</p><ul><li><code>-XX:MaxGCPauseMillis</code> - Kiểm soát thời gian tạm dừng thu gom rác tối đa, bộ thu gom rác sẽ cố gắng đảm bảo thời gian thu gom rác không vượt quá giá trị được đặt.</li><li><code>-XX:GCTimeRatio</code> - Thiết lập trực tiếp kích thước thông lượng (giá trị là số nguyên lớn hơn 0 và nhỏ hơn 100).</li></ul><p>Rút ngắn thời gian tạm dừng được thực hiện bằng cách hy sinh thông lượng và không gian thế hệ trẻ: không gian thế hệ trẻ nhỏ hơn, thu gom rác trở nên thường xuyên hơn, dẫn đến giảm thông lượng.</p><p>Bộ thu gom rác Parallel Scavenge còn cung cấp một tham số <code>-XX:+UseAdaptiveSizePolicy</code>, đây là một cờ bật, khi bật cờ này, không cần chỉ định kích thước thế hệ trẻ (<code>-Xmn</code>), tỷ lệ Eden và Survivor (<code>-XX:SurvivorRatio</code>), tuổi đối tượng chuyển lên thế hệ già (<code>-XX:PretenureSizeThreshold</code>) và các tham số chi tiết khác, máy ảo sẽ dựa trên thông tin giám sát hiệu suất hiện tại của hệ thống, tự động điều chỉnh các tham số này để cung cấp thời gian tạm dừng tốt nhất hoặc thông lượng tối đa, phương pháp này được gọi là cơ chế điều chỉnh tự động GC (GC Ergonomics).</p><h4 id="bo-thu-gom-rac-parallel-old" tabindex="-1"><a class="header-anchor" href="#bo-thu-gom-rac-parallel-old"><span>Bộ thu gom rác Parallel Old</span></a></h4><p>Đây là phiên bản của bộ thu gom rác Parallel Scavenge dành cho thế hệ già, sử dụng <strong>nhiều luồng và thuật toán &quot;đánh dấu-sắp xếp&quot;</strong>.</p><h3 id="bo-thu-gom-rac-đong-thoi-đanh-dau-xoa" tabindex="-1"><a class="header-anchor" href="#bo-thu-gom-rac-đong-thoi-đanh-dau-xoa"><span>Bộ thu gom rác đồng thời đánh dấu-xóa</span></a></h3><blockquote><p>Bật tùy chọn: <code>-XX:+UseConcMarkSweepGC</code></p><p>Sau khi bật tùy chọn này, sử dụng bộ thu gom rác <strong>CMS</strong> + <strong>ParNew</strong> + <strong>Serial Old</strong> để thu gom bộ nhớ.</p></blockquote><p>Bộ thu gom rác đồng thời đánh dấu-xóa nhằm mục tiêu giảm thiểu thời gian tạm dừng.</p><p>Sau khi bật tùy chọn này, ParNew được sử dụng để thu gom thế hệ trẻ; CMS được sử dụng để thu gom thế hệ già. Nếu CMS tạo ra quá nhiều mảnh vụn mà không thể chứa được rác lưu động, JVM sẽ gặp phải <code>Concurrent Mode Failure</code> , lúc này Serial Old sẽ được sử dụng để thay thế CMS để làm sạch mảnh vụn.</p><h4 id="bo-thu-gom-rac-cms" tabindex="-1"><a class="header-anchor" href="#bo-thu-gom-rac-cms"><span>Bộ thu gom rác CMS</span></a></h4><p><strong>Bộ thu gom rác CMS là một bộ thu gom rác đồng thời với mục tiêu giảm thiểu thời gian tạm dừng.</strong></p><p>CMS (Concurrent Mark Sweep), Mark Sweep chỉ đánh dấu-xóa.</p><h5 id="co-che-thu-gom-cua-cms" tabindex="-1"><a class="header-anchor" href="#co-che-thu-gom-cua-cms"><span>Cơ chế thu gom của CMS</span></a></h5><p>Bước thu gom của bộ thu gom rác CMS như sau:</p><ol><li><strong>Đánh dấu ban đầu</strong>: Chỉ đơn giản là đánh dấu các đối tượng mà GC Roots có thể trực tiếp liên kết đến, nhanh chóng và cần tạm dừng.</li><li><strong>Đánh dấu đồng thời</strong>: Quá trình theo dõi GC Roots để tìm các đối tượng sống trong quá trình thực thi ứng dụng, là quá trình tốn thời gian nhất, không cần tạm dừng.</li><li><strong>Đánh dấu lại</strong>: Để sửa chữa các đối tượng đã bị thay đổi trong quá trình đánh dấu đồng thời, cần tạm dừng.</li><li><strong>Xóa đồng thời</strong>: Thu hồi các đối tượng được xác định là không thể truy cập trong giai đoạn đánh dấu. Không cần tạm dừng.</li></ol><p>Trong suốt quá trình thu gom, các luồng thu gom rác có thể chạy song song với các luồng ứng dụng, không cần tạm dừng.</p><figure><img src="https://raw.githubusercontent.com/vanhung4499/images/master/snap/20230718203540.png" alt="image.png" tabindex="0" loading="lazy"><figcaption>image.png</figcaption></figure><h5 id="buoc-thu-gom-the-he-tre-cua-cms" tabindex="-1"><a class="header-anchor" href="#buoc-thu-gom-the-he-tre-cua-cms"><span>Bước thu gom thế hệ trẻ của CMS</span></a></h5><p><strong>(1) Phân chia không gian heap thành ba phần</strong></p><figure><img src="https://raw.githubusercontent.com/vanhung4499/images/master/snap/slide1.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>Thế hệ trẻ được chia thành một khu vực Eden và hai khu vực Survivor. Thế hệ già là một không gian liên tục. Thu gom đối tượng tại chỗ. Không nén trừ khi có FullGC.</p><p><strong>(2) Làm thế nào CMS thu gom thế hệ trẻ</strong></p><p>Thế hệ trẻ được đánh dấu màu xanh lá cây, thế hệ già được đánh dấu màu xanh lam. Nếu ứng dụng của bạn đã chạy một thời gian, heap của CMS sẽ trông như thế này. Các đối tượng phân tán trong không gian thế hệ già.</p><figure><img src="https://raw.githubusercontent.com/vanhung4499/images/master/snap/slide2.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>Với CMS, các đối tượng trong thế hệ già được giải phóng tại chỗ. Chúng không bị di chuyển. Không gian này không bị nén trừ khi có FullGC.</p><p><strong>(3) Thu gom thế hệ trẻ</strong></p><p>Sao chép các đối tượng sống từ Eden và Survivor sang Survivor khác. Tất cả các đối tượng đạt đến ngưỡng tuổi của chúng sẽ được thăng chuyển sang thế hệ già.</p><figure><img src="https://raw.githubusercontent.com/vanhung4499/images/master/snap/slide3.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p><strong>(4) Sau khi thu gom thế hệ trẻ</strong></p><p>Sau một lần thu gom rác thế hệ trẻ, Eden và một trong hai Survivor sẽ được làm trống.</p><figure><img src="https://raw.githubusercontent.com/vanhung4499/images/master/snap/slide4.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>Các đối tượng mới được thăng chuyển sẽ được hiển thị màu xanh lam trong hình trên, các đối tượng màu xanh lá cây là những đối tượng trẻ chưa thăng chuyển sang thế hệ già.</p><h5 id="buoc-thu-gom-the-he-gia-cua-cms" tabindex="-1"><a class="header-anchor" href="#buoc-thu-gom-the-he-gia-cua-cms"><span>Bước thu gom thế hệ già của CMS</span></a></h5><p><strong>(1) Thu gom thế hệ già của CMS</strong></p><p>Có hai sự kiện stop the world: đánh dấu ban đầu và đánh dấu lại. Khi thế hệ già đạt đến tỷ lệ sử dụng bộ nhớ cụ thể, CMS bắt đầu thực hiện.</p><figure><img src="https://raw.githubusercontent.com/vanhung4499/images/master/snap/slide5.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><ul><li>Đánh dấu ban đầu là giai đoạn tạm dừng ngắn, chỉ đánh dấu các đối tượng có thể tiếp cận được.</li><li>Đánh dấu đồng thời tìm kiếm đối tượng sống trong quá trình thực thi ứng dụng.</li><li>Cuối cùng, trong giai đoạn đánh dấu lại, tìm kiếm các đối tượng bị mất trong giai đoạn đánh dấu đồng thời trước đó.</li></ul><p><strong>(2) Thu gom thế hệ già - xóa đồng thời</strong></p><p>Các đối tượng chưa được đánh dấu sẽ được giải phóng tại chỗ. Không nén trừ khi có FullGC.</p><figure><img src="https://raw.githubusercontent.com/vanhung4499/images/master/snap/slide6.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p><strong>Lưu ý:</strong> Đối tượng chưa được đánh dấu tương đương với đối tượng đã chết.</p><p><strong>(3) Thu gom thế hệ già - sau khi xóa</strong></p><p>Sau giai đoạn xóa, bạn có thể thấy rất nhiều bộ nhớ được giải phóng. Bạn cũng có thể nhận thấy không có hoạt động nén.</p><figure><img src="https://raw.githubusercontent.com/vanhung4499/images/master/snap/slide7.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>Cuối cùng, bộ thu gom rác CMS sẽ tiếp tục vào giai đoạn thiết lập lại, chờ đợi thời điểm thu gom rác tiếp theo.</p><h5 id="đac-điem-cua-cms" tabindex="-1"><a class="header-anchor" href="#đac-điem-cua-cms"><span>Đặc điểm của CMS</span></a></h5><p>Bộ thu gom rác CMS có các nhược điểm sau:</p><ul><li>Thu gom đồng thời - Đồng thời có nghĩa là các luồng ứng dụng và luồng GC có thể chạy song song, không cần tạm dừng.</li><li>Thông lượng thấp - Thời gian tạm dừng thấp được đánh đổi bằng cách hy sinh thông lượng, dẫn đến tỷ lệ sử dụng CPU không cao.</li><li>Không thể xử lý rác lưu động - Có thể xảy ra <code>Concurrent Mode Failure</code>. Rác lưu động là rác được tạo ra trong giai đoạn xóa đồng thời do luồng ứng dụng tiếp tục chạy, phần rác này chỉ có thể được thu gom lại trong lần GC tiếp theo. Vì có rác lưu động, cần dành một phần bộ nhớ trống, điều này có nghĩa là bộ thu gom CMS không thể chờ thế hệ già gần đầy mới thu gom như những bộ thu gom khác. <ul><li>Có thể sử dụng <code>-XX:CMSInitiatingOccupancyFraction</code> để thay đổi ngưỡng sử dụng bộ nhớ để kích hoạt CMS, nếu giá trị này được đặt quá lớn, dẫn đến không đủ bộ nhớ dự phòng để chứa rác lưu động, sẽ xảy ra <code>Concurrent Mode Failure</code> và JVM sẽ tạm thời sử dụng Serial Old để thay thế CMS để làm sạch rác lưu động.</li></ul></li><li>Đánh dấu - Xóa gây ra sự phân mảnh, thường xuyên xảy ra tình trạng không gian thế hệ già còn trống nhưng không tìm thấy không gian liên tục đủ lớn để cấp phát cho đối tượng hiện tại, phải sớm kích hoạt một lần Full GC. <ul><li>Có thể sử dụng <code>-XX:+UseCMSCompactAtFullCollection</code> để kích hoạt việc nén mảnh vụn khi CMS cần thực hiện Full GC, quá trình nén không thể đồng thời, vấn đề mảnh vụn được giải quyết, nhưng thời gian tạm dừng sẽ tăng lên.</li><li>Có thể sử dụng <code>-XX:CMSFullGCsBeforeCompaction</code> để thiết lập số lần Full GC không nén trước khi thực hiện một lần nén (mặc định là 0, có nghĩa là mỗi khi thực hiện Full GC đều phải thực hiện nén mảnh vụn).</li></ul></li></ul><h4 id="bo-thu-gom-parnew" tabindex="-1"><a class="header-anchor" href="#bo-thu-gom-parnew"><span>Bộ thu gom ParNew</span></a></h4><blockquote><p>Tùy chọn kích hoạt: <code>-XX:+UseParNewGC</code></p></blockquote><p>Bộ thu gom ParNew thực chất là phiên bản đa luồng của bộ thu gom Serial.</p><p>ParNew là bộ thu gom thế hệ trẻ được ưu tiên sử dụng trong chế độ Server của máy ảo Java. Ngoài lý do hiệu suất, chính là do nó là bộ thu gom duy nhất có thể hoạt động cùng với bộ thu gom CMS.</p><p>Bộ thu gom ParNew cũng là bộ thu gom mặc định cho thế hệ trẻ khi sử dụng <code>-XX:+UseConcMarkSweepGC</code>.</p><p>Số luồng mặc định của bộ thu gom ParNew là bằng số lượng CPU, có thể sử dụng tham số <code>-XX:ParallelGCThreads</code> để thiết lập số luồng.</p><h3 id="bo-thu-gom-g1" tabindex="-1"><a class="header-anchor" href="#bo-thu-gom-g1"><span>Bộ thu gom G1</span></a></h3><blockquote><p>Tùy chọn kích hoạt: <code>-XX:+UseG1GC</code></p></blockquote><p>Các bộ thu gom rác đã được đề cập trước đây thường tập trung vào hiệu suất hoặc thời gian tạm dừng. Tuy nhiên, G1 là một bộ thu gom rác kết hợp cả hiệu suất và thời gian tạm dừng. G1 là bộ thu gom rác mặc định từ Oracle JDK 9 trở đi. G1 có thể thiết lập mục tiêu thời gian tạm dừng một cách trực quan. So với bộ thu gom CMS, G1 có thể không đạt được thời gian tạm dừng tối ưu nhưng cũng tốt hơn trong trường hợp xấu nhất.</p><p>Điểm đặc biệt lớn nhất của G1 là sự giới thiệu của khái niệm phân vùng, làm mờ khái niệm theo thế hệ và tận dụng tài nguyên của các chu kỳ thu gom rác khác nhau, giải quyết nhiều khuyết điểm của các bộ thu gom khác, kể cả CMS.</p><h4 id="the-he-va-phan-vung" tabindex="-1"><a class="header-anchor" href="#the-he-va-phan-vung"><span>Thế hệ và phân vùng</span></a></h4><p>Các bộ thu gom rác cũ thông thường thực hiện thu gom theo thế hệ, trong đó Java Heap được chia thành thế hệ trẻ, thế hệ già và thế hệ vĩnh cửu. Phạm vi thu gom là toàn bộ thế hệ trẻ hoặc toàn bộ thế hệ già.</p><p>G1 loại bỏ thế hệ vĩnh cửu và chia thế hệ trẻ và thế hệ già thành nhiều vùng độc lập có kích thước bằng nhau, thế hệ trẻ và thế hệ già không còn được cách ly vật lý. G1 có thể thu gom trực tiếp thế hệ trẻ và thế hệ già cùng một lúc.</p><div align="center"><img src="https://raw.githubusercontent.com/dunwu/images/dev/cs/java/javacore/jvm/jvm-gc-g1-heap-allocation.png"></div><p>Bằng cách giới thiệu khái niệm vùng, một khối bộ nhớ được chia thành nhiều khối nhỏ, mỗi khối nhỏ có thể được thu gom rác độc lập. Phương pháp chia này mang lại tính linh hoạt lớn, cho phép mô hình thời gian tạm dừng có thể dự đoán được. Bằng cách ghi lại thời gian thu gom rác của mỗi vùng và không gian thu được từ việc thu gom rác trước đó, và duy trì một danh sách ưu tiên, mỗi lần dựa trên thời gian thu gom cho phép, ưu tiên thu gom vùng có giá trị cao nhất.</p><p>Mỗi vùng đều có một Remembered Set để ghi lại các vùng mà các đối tượng tham chiếu đến. Bằng cách sử dụng Remembered Set, không cần quét toàn bộ heap để phân tích khả năng tiếp cận.</p><h4 id="co-che-thu-gom-cua-g1" tabindex="-1"><a class="header-anchor" href="#co-che-thu-gom-cua-g1"><span>Cơ chế thu gom của G1</span></a></h4><p>Nếu không tính toán việc duy trì Remembered Set, quá trình hoạt động của bộ thu gom G1 có thể chia thành các bước sau:</p><ol><li><strong>Đánh dấu ban đầu</strong></li><li><strong>Đánh dấu đồng thời</strong></li><li><strong>Đánh dấu cuối cùng</strong> - Để sửa chữa phần đánh dấu bị thay đổi trong quá trình đánh dấu đồng thời do hoạt động của chương trình người dùng, máy ảo ghi lại các thay đổi này trong Remembered Set Logs của các luồng và sau đó hợp nhất dữ liệu Remembered Set Logs vào Remembered Set. Bước này yêu cầu tạm dừng luồng, nhưng có thể thực hiện song song.</li><li><strong>Thu gom lựa chọn</strong> - Đầu tiên, sắp xếp giá trị thu gom và chi phí của mỗi vùng, dựa trên thời gian tạm dừng GC mà người dùng mong muốn. Thực tế, bước này cũng có thể được thực hiện song song với chương trình người dùng, nhưng vì chỉ thu gom một phần vùng, thời gian tạm dừng là do người dùng kiểm soát và tăng hiệu suất thu gom.</li></ol><p>Có những đặc điểm sau:</p><ul><li>Tích hợp không gian: Tổng thể là một bộ thu gom dựa trên thuật toán &quot;đánh dấu - sắp xếp&quot;, từ một góc nhìn cục bộ (giữa hai vùng) dựa trên thuật toán &quot;sao chép&quot;. Điều này có nghĩa là không có mảnh không gian bị phân mảnh được tạo ra trong quá trình chạy.</li><li>Thời gian tạm dừng có thể dự đoán được: Cho phép người dùng chỉ định rõ ràng rằng trong một khoảng thời gian M mili giây, thời gian tiêu tốn cho GC không được vượt quá N mili giây.</li></ul><h4 id="quy-trinh-thu-gom-the-he-tre-chi-tiet-cua-g1" tabindex="-1"><a class="header-anchor" href="#quy-trinh-thu-gom-the-he-tre-chi-tiet-cua-g1"><span>Quy trình thu gom thế hệ trẻ chi tiết của G1</span></a></h4><p><strong>（1）G1 khởi tạo không gian heap</strong></p><p>Heap là một khối bộ nhớ được chia thành nhiều vùng có kích thước cố định.</p><figure><img src="https://raw.githubusercontent.com/vanhung4499/images/master/snap/slide8.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>Khi máy ảo Java khởi động, kích thước vùng được chọn. Thông thường, máy ảo Java sẽ chọn khoảng 2000 vùng có kích thước tương đương, mỗi vùng có kích thước từ 1 đến 32M.</p><p><strong>（2）Phân vùng không gian heap của G1</strong></p><p>Thực tế, các vùng này được ánh xạ thành các vùng Eden, Survivor và Old logic.</p><figure><img src="https://raw.githubusercontent.com/vanhung4499/images/master/snap/slide9.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>Màu sắc trong hình chỉ ra vùng nào được liên kết với vai trò gì. Đối tượng hoạt động được phân tán (sao chép, di chuyển) từ một vùng sang một vùng khác. Các vùng được thiết kế để thu gom theo cách song song, có thể tạm dừng hoặc không tạm dừng tất cả các luồng người dùng khác.</p><p>Có thể phân vùng rõ ràng thành Eden, Survivor và Old. Ngoài ra, có một loại vùng thứ tư được gọi là <em>vùng cực lớn (Humongous regions)</em>. Các vùng này được thiết kế để giữ 50% hoặc nhiều hơn kích thước vùng tiêu chuẩn. Chúng được lưu trữ trong một tập hợp các vùng liên tục. Cuối cùng, loại vùng cuối cùng là các vùng không được sử dụng trong không gian heap.</p><p><strong>Lưu ý:</strong> Khi viết bài này, việc thu gom đối tượng cực lớn vẫn chưa được tối ưu hóa. Do đó, bạn nên tránh tạo đối tượng có kích thước lớn như vậy.</p><p><strong>（3）Thế hệ trẻ của G1</strong></p><p>Không gian heap được chia thành khoảng 2000 vùng. Tối thiểu là 1M, tối đa là 32M. Vùng màu xanh lá cây giữ các đối tượng thế hệ già, vùng màu xanh lam giữ các đối tượng thế hệ trẻ.</p><p><img src="https://raw.githubusercontent.com/vanhung4499/images/master/snap/slide10.png" alt="img" loading="lazy"><br><strong>Lưu ý:</strong> Không cần phải là các vùng liên tục như các bộ thu gom cũ.</p><p><strong>（4）Thu gom thế hệ trẻ của G1</strong></p><p>Các đối tượng hoạt động được sao chép (di chuyển) sang một hoặc nhiều vùng Survivor. Nếu đạt đến ngưỡng thăng cấp tổng, đối tượng sẽ được thăng cấp vào vùng Old.</p><figure><img src="https://raw.githubusercontent.com/vanhung4499/images/master/snap/slide11.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>Đây là một sự tạm dừng stop the world. Tính toán lại kích thước Eden và Survivor cho lần thu gom rác thế hệ trẻ tiếp theo. Việc giữ lại thông tin kiểm tra giúp tính toán kích thước. Các vấn đề tương tự thời gian tạm dừng mục tiêu sẽ được xem xét.</p><p>Phương pháp này làm cho việc điều chỉnh kích thước vùng trở nên dễ dàng, tăng hoặc giảm theo nhu cầu.</p><p><strong>（5）Kết thúc thu gom thế hệ trẻ của G1</strong></p><p>Các đối tượng hoạt động được sao chép vào vùng Survivor hoặc vùng Old.</p><figure><img src="https://raw.githubusercontent.com/vanhung4499/images/master/snap/slide12.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>Các đối tượng mới được thăng cấp gần đây được hiển thị dưới dạng màu xanh đậm. Các vùng Survivor được hiển thị dưới dạng màu xanh lá cây.</p><p>Tóm lại quá trình thu gom thế hệ trẻ của G1:</p><ul><li>Không gian heap là một khối bộ nhớ độc lập được chia thành nhiều vùng.</li><li>Thế hệ trẻ của bộ nhớ được tạo thành từ một nhóm các vùng không liên tục. Điều này làm cho việc điều chỉnh kích thước trở nên dễ dàng.</li><li>Thu gom rác thế hệ trẻ là một sự kiện stop the world, tất cả các luồng ứng dụng đều tạm dừng trong quá trình này.</li><li>Thu gom rác thế hệ trẻ sử dụng nhiều luồng để thu gom song song.</li><li>Các đối tượng hoạt động được sao chép vào vùng Survivor hoặc vùng Old.</li></ul><h4 id="qua-trinh-thu-gom-the-he-gia-cua-g1" tabindex="-1"><a class="header-anchor" href="#qua-trinh-thu-gom-the-he-gia-cua-g1"><span>Quá trình thu gom thế hệ già của G1</span></a></h4><p><strong>Bước 1: Gắn nhãn ban đầu (Initial Mark)</strong></p><p>Thu gom rác trong thế hệ già của G1 đảm nhiệm việc gắn nhãn cho các đối tượng hoạt động. Được ghi lại trong tệp nhật ký với tên <em>GC pause (young)(inital-mark)</em>.</p><figure><img src="https://raw.githubusercontent.com/vanhung4499/images/master/snap/slide13.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p><strong>Bước 2: Gắn nhãn song song (Concurrent Mark)</strong></p><p>Nếu có các vùng trống (được đánh dấu bằng &quot;X&quot;), chúng sẽ được xóa ngay trong giai đoạn gắn nhãn lại. Đồng thời, thông tin kiểm tra sự sống cũng được tính toán tại giai đoạn này.</p><figure><img src="https://raw.githubusercontent.com/vanhung4499/images/master/snap/slide14.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p><strong>Bước 3: Gắn nhãn lại (Remark)</strong></p><p>Các vùng trống được xóa và thu gom. Tính toán sự sống của tất cả các vùng trong quá trình này.</p><figure><img src="https://raw.githubusercontent.com/vanhung4499/images/master/snap/slide15.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p><strong>Bước 4: Sao chép/Thu dọn (Copy/Cleanup)</strong></p><p>G1 chọn các vùng có độ sống thấp nhất để thu gom, những vùng này có thể được thu gom nhanh nhất. Sau đó, các vùng này sẽ được thu gom trong quá trình thu gom rác trong thế hệ già. Được ghi lại trong nhật ký với tên <em>[GC pause (mixed)]</em>. Vì vậy, cả thế hệ già và đa thế hệ cùng được thu gom cùng một lúc.</p><figure><img src="https://raw.githubusercontent.com/vanhung4499/images/master/snap/slide16.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p><strong>Bước 5: Sau quá trình sao chép/Thu dọn</strong></p><p>Các vùng được chọn đã được thu gom và nén vào các vùng màu xanh đậm và màu xanh lá cây được hiển thị trong hình.</p><figure><img src="https://raw.githubusercontent.com/vanhung4499/images/master/snap/slide17.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><h3 id="tong-ket" tabindex="-1"><a class="header-anchor" href="#tong-ket"><span>Tổng kết</span></a></h3><table><thead><tr><th style="text-align:center;">Bộ thu gom</th><th style="text-align:center;">Tuần tự/Đồng thời/Phân tán</th><th style="text-align:center;">Thế hệ trẻ/Thế hệ già</th><th style="text-align:center;">Thu gom thuật toán</th><th style="text-align:center;">Mục tiêu</th><th style="text-align:center;">Ứng dụng phù hợp</th></tr></thead><tbody><tr><td style="text-align:center;"><strong>Serial</strong></td><td style="text-align:center;">Tuần tự</td><td style="text-align:center;">Thế hệ trẻ</td><td style="text-align:center;">Sao chép</td><td style="text-align:center;">Ưu tiên tốc độ đáp ứng</td><td style="text-align:center;">Môi trường Client với một CPU trong chế độ Client</td></tr><tr><td style="text-align:center;"><strong>Serial Old</strong></td><td style="text-align:center;">Tuần tự</td><td style="text-align:center;">Thế hệ già</td><td style="text-align:center;">Đánh dấu-đóng gói</td><td style="text-align:center;">Ưu tiên tốc độ đáp ứng</td><td style="text-align:center;">Môi trường Client với một CPU, dự phòng cho CMS</td></tr><tr><td style="text-align:center;"><strong>ParNew</strong></td><td style="text-align:center;">Tuần tự + Đồng thời</td><td style="text-align:center;">Thế hệ trẻ</td><td style="text-align:center;">Sao chép</td><td style="text-align:center;">Ưu tiên tốc độ đáp ứng</td><td style="text-align:center;">Môi trường Server với nhiều CPU, kết hợp với CMS</td></tr><tr><td style="text-align:center;"><strong>Parallel Scavenge</strong></td><td style="text-align:center;">Tuần tự + Đồng thời</td><td style="text-align:center;">Thế hệ trẻ</td><td style="text-align:center;">Sao chép</td><td style="text-align:center;">Ưu tiên hiệu suất</td><td style="text-align:center;">Các tác vụ chạy nền không cần nhiều tương tác</td></tr><tr><td style="text-align:center;"><strong>Parallel Old</strong></td><td style="text-align:center;">Tuần tự + Đồng thời</td><td style="text-align:center;">Thế hệ già</td><td style="text-align:center;">Đánh dấu-đóng gói</td><td style="text-align:center;">Ưu tiên hiệu suất</td><td style="text-align:center;">Các tác vụ chạy nền không cần nhiều tương tác</td></tr><tr><td style="text-align:center;"><strong>CMS</strong></td><td style="text-align:center;">Đồng thời + Đồng thời</td><td style="text-align:center;">Thế hệ già</td><td style="text-align:center;">Đánh dấu-xóa</td><td style="text-align:center;">Ưu tiên tốc độ đáp ứng</td><td style="text-align:center;">Ứng dụng Java tập trung trên các trang web hoặc dịch vụ máy chủ B/S</td></tr><tr><td style="text-align:center;"><strong>G1</strong></td><td style="text-align:center;">Đồng thời + Đồng thời</td><td style="text-align:center;">Thế hệ trẻ + Thế hệ già</td><td style="text-align:center;">Đánh dấu-đóng gói + Sao chép</td><td style="text-align:center;">Ưu tiên tốc độ đáp ứng</td><td style="text-align:center;">Ứng dụng dành cho máy chủ, thay thế CMS trong tương lai</td></tr></tbody></table><h2 id="chien-luoc-cap-phat-va-thu-gom-bo-nho" tabindex="-1"><a class="header-anchor" href="#chien-luoc-cap-phat-va-thu-gom-bo-nho"><span>Chiến lược cấp phát và thu gom bộ nhớ</span></a></h2><p>cấp phát bộ nhớ cho đối tượng được thực hiện trên heap. Đa phần các đối tượng được cấp phát trên khu vực Eden của thế hệ trẻ, trong một số trường hợp cũng có thể được cấp phát trực tiếp trên khu vực của thế hệ già.</p><h3 id="minor-gc" tabindex="-1"><a class="header-anchor" href="#minor-gc"><span>Minor GC</span></a></h3><p><strong>Khi không gian trong khu vực Eden không đủ, Minor GC sẽ được kích hoạt</strong>.</p><p><strong>Minor GC xảy ra trên thế hệ trẻ</strong>, vì thời gian sống của các đối tượng trên thế hệ trẻ ngắn, nên Minor GC thường xuyên xảy ra và thực hiện nhanh chóng.</p><p>Quy trình của Minor GC:</p><ol><li>Ứng dụng Java liên tục tạo ra các đối tượng, thường được cấp phát trên khu vực Eden. Khi không gian trong Eden không đủ (đạt đến ngưỡng đã định), Minor GC sẽ được kích hoạt. Các đối tượng vẫn còn được tham chiếu (hình vuông màu xanh lá cây) sẽ được sao chép vào khu vực Survivor mà JVM chọn, trong khi các đối tượng không còn được tham chiếu (hình vuông màu vàng) sẽ được thu gom.</li><li>Sau một lần Minor GC, khu vực Eden sẽ trở thành trống rỗng cho đến khi đạt đến điều kiện kích hoạt Minor GC lần tiếp theo. Lúc này, khu vực Survivor khác sẽ trở thành khu vực <code>To</code>, các đối tượng còn sống trong khu vực Eden và khu vực <code>From</code> sẽ được sao chép vào khu vực <code>To</code>, và độ tuổi của đối tượng sống sẽ được tăng thêm 1.</li><li>Quá trình tương tự như bước 2 sẽ xảy ra nhiều lần, cho đến khi một số đối tượng đạt đến ngưỡng tuổi, khi đó quá trình &quot;thăng cấp&quot; (Promotion) sẽ xảy ra, các đối tượng vượt quá ngưỡng sẽ được thăng cấp vào thế hệ già. Ngưỡng này có thể được chỉ định bằng tham số <code>-XX:MaxTenuringThreshold</code>.</li></ol><h3 id="full-gc" tabindex="-1"><a class="header-anchor" href="#full-gc"><span>Full GC</span></a></h3><p><strong>Full GC xảy ra trên thế hệ già</strong>, đối tượng trên thế hệ già có tuổi sống lâu hơn thế hệ trẻ, do đó Full GC xảy ra ít và tốc độ thực hiện cũng chậm hơn Minor GC nhiều.</p><h4 id="chien-luoc-cap-phat-bo-nho" tabindex="-1"><a class="header-anchor" href="#chien-luoc-cap-phat-bo-nho"><span>Chiến lược cấp phát bộ nhớ</span></a></h4><p><strong>(1) Ưu tiên cấp phát đối tượng trên Eden</strong></p><p>Trong hầu hết các trường hợp, đối tượng được cấp phát trên khu vực Eden của thế hệ trẻ. Khi không gian trong Eden không đủ, Minor GC sẽ được kích hoạt. Điều này đảm bảo rằng đối tượng có tuổi sống ngắn được thu gom nhanh chóng.</p><p><strong>(2) Đối tượng lớn trực tiếp vào thế hệ già</strong></p><p>Đối tượng lớn là những đối tượng cần có không gian liên tục, ví dụ như chuỗi dài và mảng lớn.</p><p>Việc cấp phát đối tượng lớn sẽ kích hoạt thu gom rác trước để có đủ không gian liên tục để cấp phát cho đối tượng lớn.</p><p><code>-XX:PretenureSizeThreshold</code> được sử dụng để định nghĩa kích thước ngưỡng, nếu đối tượng lớn hơn ngưỡng này, nó sẽ được cấp phát trực tiếp trên thế hệ già, tránh việc sao chép nhiều bộ nhớ giữa khu vực Eden và khu vực Survivor.</p><p><strong>(3) Đối tượng tồn tại lâu vào thế hệ già</strong></p><p>Đối tượng được định nghĩa với bộ đếm tuổi, đối tượng sinh ra trong Eden và sống sót qua Minor GC sẽ được chuyển sang khu vực Survivor, và tuổi đối tượng sẽ tăng lên 1.</p><p><code>-XX:MaxTenuringThreshold</code> được sử dụng để định nghĩa ngưỡng tuổi.</p><p><strong>(4) Xác định tuổi của đối tượng động</strong></p><p>Máy ảo không yêu cầu tuổi của đối tượng phải đạt đến <code>MaxTenuringThreshold</code> mới có thể thăng cấp vào thế hệ già. Nếu tổng kích thước của tất cả các đối tượng cùng tuổi trong khu vực Survivor lớn hơn một nửa không gian của Survivor, các đối tượng có tuổi lớn hơn hoặc bằng tuổi này có thể trực tiếp thăng cấp vào thế hệ già mà không cần đợi đến tuổi yêu cầu.</p><p><strong>(5) Bảo đảm cấp phát không gian</strong></p><p>Trước khi thực hiện Minor GC, máy ảo sẽ kiểm tra xem không gian liên tục lớn nhất có sẵn trong thế hệ già có lớn hơn tổng không gian của tất cả các đối tượng trong thế hệ trẻ hay không. Nếu điều kiện này đúng, Minor GC có thể được thực hiện một cách an toàn. Nếu không đúng, máy ảo sẽ kiểm tra xem cài đặt <code>HandlePromotionFailure</code> có cho phép thất bại bảo đảm không. Nếu cho phép, máy ảo sẽ kiểm tra xem không gian liên tục lớn nhất có sẵn trong thế hệ già có lớn hơn kích thước trung bình của các đối tượng đã thăng cấp vào thế hệ già trước đó hay không. Nếu lớn hơn, máy ảo sẽ thử thực hiện một lần Minor GC, mặc dù điều này có rủi ro. Nếu nhỏ hơn hoặc <code>HandlePromotionFailure</code> không cho phép rủi ro, máy ảo sẽ thực hiện Full GC.</p><h4 id="đieu-kien-kich-hoat-full-gc" tabindex="-1"><a class="header-anchor" href="#đieu-kien-kich-hoat-full-gc"><span>Điều kiện kích hoạt Full GC</span></a></h4><p>Đối với Minor GC, điều kiện kích hoạt rất đơn giản, khi không gian trong khu vực Eden đầy, một Minor GC sẽ được kích hoạt. Trong khi đó, Full GC phức tạp hơn và có các điều kiện sau:</p><p><strong>(1) Gọi <code>System.gc()</code></strong></p><p>Việc gọi phương thức này đề nghị máy ảo thực hiện Full GC, mặc dù chỉ là đề nghị và không chắc chắn, nhưng trong nhiều trường hợp nó sẽ kích hoạt Full GC, tăng tần suất Full GC và tạo ra nhiều lần tạm dừng không đều. Do đó, rất khuyến khích không sử dụng phương thức này nếu không cần thiết, để máy ảo tự quản lý bộ nhớ của nó. Có thể vô hiệu hóa việc gọi <code>System.gc()</code> bằng cách sử dụng <code>-XX:DisableExplicitGC</code>.</p><p><strong>(2) Không gian trong thế hệ già không đủ</strong></p><p>Trường hợp phổ biến là khi đối tượng lớn trực tiếp vào thế hệ già, đối tượng trường hợp lâu dài vào thế hệ già, khi thực hiện Full GC sau khi không gian vẫn không đủ, sẽ ném ra <code>java.lang.OutOfMemoryError: Java heap space</code>. Để tránh Full GC do các nguyên nhân trên, khi tối ưu hóa, hãy cố gắng để đối tượng được thu gom trong giai đoạn Minor GC, để đối tượng sống lâu hơn trong thế hệ trẻ và không tạo ra đối tượng hoặc mảng quá lớn.</p><p><strong>(3) Không gian trong vùng phương thức không đủ</strong></p><p>Vùng phương thức trong khu vực dữ liệu chạy thời gian (Runtime Data Area) của JVM, trong HotSpot JVM thường được gọi là <strong>vùng không thay đổi</strong> (PermGen), vùng không thay đổi chứa thông tin mô tả lớp, hằng số, biến tĩnh, v.v. Khi có nhiều lớp được tải, lớp phản chiếu và phương thức được gọi, vùng không thay đổi có thể bị đầy, nếu không được cấu hình để sử dụng CMS GC, Full GC cũng sẽ được thực hiện. Nếu Full GC vẫn không thể thu gom được, JVM sẽ ném ra lỗi <code>java.lang.OutOfMemoryError: PermGen space</code>. Để tránh tình trạng vùng không thay đổi bị đầy gây ra Full GC, có thể tăng kích thước của Perm Gen hoặc chuyển sang sử dụng CMS GC.</p><p><strong>(4) Kích thước trung bình của Minor GC vượt quá không gian còn lại trong thế hệ già</strong></p><p>Nếu số liệu thống kê cho thấy kích thước trung bình của Minor GC trước đó lớn hơn không gian còn lại trong thế hệ già, thì không sẽ kích hoạt Minor GC mà sẽ chuyển sang kích hoạt Full GC.</p><p><strong>(5) Kích thước đối tượng lớn hơn không gian trống của khu vực To và thế hệ già</strong></p><p>Khi sao chép từ khu vực <code>Eden</code> và khu vực <code>From</code> sang khu vực <code>To</code>, nếu kích thước đối tượng lớn hơn bộ nhớ khả dụng của khu vực <code>To</code>, thì đối tượng sẽ được chuyển vào thế hệ già, và bộ nhớ khả dụng của thế hệ già nhỏ hơn kích thước của đối tượng.</p></div><!----><footer class="vp-page-meta"><div class="vp-meta-item edit-link"><a class="auto-link external-link vp-meta-label" href="https://github.com/vanhung4499/my-wiki/edit/main/src/programming/java/JVM/JVM Garbage Collection.md" aria-label="Edit this page on GitHub" rel="noopener noreferrer" target="_blank"><!--[--><svg xmlns="http://www.w3.org/2000/svg" class="icon edit-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="edit icon" name="edit"><path d="M430.818 653.65a60.46 60.46 0 0 1-50.96-93.281l71.69-114.012 7.773-10.365L816.038 80.138A60.46 60.46 0 0 1 859.225 62a60.46 60.46 0 0 1 43.186 18.138l43.186 43.186a60.46 60.46 0 0 1 0 86.373L588.879 565.55l-8.637 8.637-117.466 68.234a60.46 60.46 0 0 1-31.958 11.229z"></path><path d="M728.802 962H252.891A190.883 190.883 0 0 1 62.008 771.98V296.934a190.883 190.883 0 0 1 190.883-192.61h267.754a60.46 60.46 0 0 1 0 120.92H252.891a69.962 69.962 0 0 0-69.098 69.099V771.98a69.962 69.962 0 0 0 69.098 69.098h475.911A69.962 69.962 0 0 0 797.9 771.98V503.363a60.46 60.46 0 1 1 120.922 0V771.98A190.883 190.883 0 0 1 728.802 962z"></path></svg><!--]-->Edit this page on GitHub<!----></a></div><div class="vp-meta-item git-info"><div class="update-time"><span class="vp-meta-label">Last update: </span><!----></div><div class="contributors"><span class="vp-meta-label">Contributors: </span><!--[--><!--[--><span class="vp-meta-info" title="email: vanhung4499@gmail.com">Hung Nguyen Van</span><!--]--><!--]--></div></div></footer><nav class="vp-page-nav"><a class="route-link auto-link prev" href="/programming/java/JVM/JVM%20Command%20Line%20Tools.html" aria-label="JVM Command Line Tools"><div class="hint"><span class="arrow start"></span>Prev</div><div class="link"><!---->JVM Command Line Tools</div></a><a class="route-link auto-link next" href="/programming/java/JVM/JVM%20GUI%20Tools.html" aria-label="JVM GUI Tools"><div class="hint">Next<span class="arrow end"></span></div><div class="link">JVM GUI Tools<!----></div></a></nav><!----><!----><!--]--></main><!--]--><footer class="footer-wrapper" style="display:none;--1ea755b8:;"><div class="footer-content"><div class="footer">Made with ❤️ by Hung Nguyen</div><div class="copyright">Copyright © 2016-2024 Hung Nguyen</div></div><span id="runtime_span"></span></footer></div><!--]--><!--[--><!----><!----><!----><!----><!--]--><!--]--></div>
    <script type="module" src="/assets/app-BG8AAbz2.js" defer></script>
  </body>
</html>
