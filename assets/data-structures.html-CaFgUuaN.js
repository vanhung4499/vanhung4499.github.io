import{_ as n,o as i,c as s,d as t}from"./app-BdwADm4z.js";const a={},c=t(`<h1 id="redis-data-structures" tabindex="-1"><a class="header-anchor" href="#redis-data-structures"><span>Redis Data Structures</span></a></h1><h2 id="sds" tabindex="-1"><a class="header-anchor" href="#sds"><span>SDS</span></a></h2><h3 id="gioi-thieu-ve-sds" tabindex="-1"><a class="header-anchor" href="#gioi-thieu-ve-sds"><span>Giới thiệu về SDS</span></a></h3><p>SDS là viết tắt của Simple Dynamic String, tức là <strong>Chuỗi Động Đơn Giản</strong>. Redis đã tối ưu SDS để thay thế chuỗi C trong việc biểu diễn nội dung chuỗi. Ngoài ra, SDS còn được Redis sử dụng như là vùng đệm (buffer), chẳng hạn như vùng đệm AOF trong mô đun AOF và vùng đệm đầu vào trong trạng thái của khách hàng.</p><p>So với chuỗi C, SDS có những ưu điểm sau:</p><table><thead><tr><th style="text-align:left;">Chuỗi C</th><th style="text-align:left;">SDS</th></tr></thead><tbody><tr><td style="text-align:left;">Độ phức tạp để lấy độ dài chuỗi là O(N).</td><td style="text-align:left;">Độ phức tạp để lấy độ dài chuỗi là O(1).</td></tr><tr><td style="text-align:left;">API không an toàn, có thể gây tràn bộ đệm.</td><td style="text-align:left;">API an toàn, không gây tràn bộ đệm.</td></tr><tr><td style="text-align:left;">Đổi độ dài chuỗi <code>N</code> lần sẽ cần phải cấp phát lại <code>N</code> lần bộ nhớ.</td><td style="text-align:left;">Đổi độ dài chuỗi <code>N</code> lần tối đa chỉ cần cấp phát lại <code>N</code> lần bộ nhớ.</td></tr><tr><td style="text-align:left;">Chỉ có thể lưu trữ dữ liệu văn bản.</td><td style="text-align:left;">Có thể lưu trữ cả dữ liệu văn bản và dữ liệu nhị phân.</td></tr><tr><td style="text-align:left;">Có thể sử dụng tất cả các hàm trong thư viện <code>&lt;string.h&gt;</code>.</td><td style="text-align:left;">Chỉ có thể sử dụng một phần hàm trong thư viện <code>&lt;string.h&gt;</code>.</td></tr></tbody></table><h3 id="trien-khai-sds" tabindex="-1"><a class="header-anchor" href="#trien-khai-sds"><span>Triển khai SDS</span></a></h3><p>Mỗi cấu trúc <code>sds.h/sdshdr</code> đại diện cho một giá trị SDS:</p><div class="language-c" data-ext="c" data-title="c"><pre class="shiki shiki-themes one-dark-pro one-dark-pro vp-code" style="background-color:#282c34;--shiki-dark-bg:#282c34;color:#abb2bf;--shiki-dark:#abb2bf;" tabindex="0"><code><span class="line"><span style="color:#C678DD;--shiki-dark:#C678DD;">struct</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;"> sdshdr {</span></span>
<span class="line"></span>
<span class="line"><span style="color:#7F848E;--shiki-dark:#7F848E;font-style:italic;--shiki-dark-font-style:italic;">    // Ghi lại số lượng byte đã sử dụng trong mảng buf</span></span>
<span class="line"><span style="color:#7F848E;--shiki-dark:#7F848E;font-style:italic;--shiki-dark-font-style:italic;">    // Bằng với độ dài của chuỗi được lưu bởi SDS</span></span>
<span class="line"><span style="color:#C678DD;--shiki-dark:#C678DD;">    int</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;"> len;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#7F848E;--shiki-dark:#7F848E;font-style:italic;--shiki-dark-font-style:italic;">    // Ghi lại số lượng byte chưa sử dụng trong mảng buf</span></span>
<span class="line"><span style="color:#C678DD;--shiki-dark:#C678DD;">    int</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;"> free;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#7F848E;--shiki-dark:#7F848E;font-style:italic;--shiki-dark-font-style:italic;">    // Mảng byte được sử dụng để lưu trữ chuỗi</span></span>
<span class="line"><span style="color:#C678DD;--shiki-dark:#C678DD;">    char</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;"> buf</span><span style="color:#C678DD;--shiki-dark:#C678DD;">[]</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">};</span></span></code></pre></div><p>SDS tuân thủ quy ước chuỗi C với ký tự null kết thúc, trong đó không tính <code>1</code> byte được cấp phát cho ký tự null trong thuộc tính <code>len</code> của SDS. Ngoài ra, các thao tác như cấp phát thêm <code>1</code> byte cho ký tự null ở cuối chuỗi được xử lý tự động bởi các hàm SDS, làm cho ký tự null này hoàn toàn trong suốt đối với người dùng SDS.</p><figure><img src="https://raw.githubusercontent.com/vanhung4499/images/master/snap/20240624213746.png" alt="image.png" tabindex="0" loading="lazy"><figcaption>image.png</figcaption></figure><h2 id="tinh-nang-cua-sds" tabindex="-1"><a class="header-anchor" href="#tinh-nang-cua-sds"><span>Tính năng của SDS</span></a></h2><p>SDS so với chuỗi C, có những tối ưu hóa sau đây:</p><h3 id="lay-đo-dai-chuoi-voi-đo-phuc-tap-hang-so" tabindex="-1"><a class="header-anchor" href="#lay-đo-dai-chuoi-voi-đo-phuc-tap-hang-so"><span>Lấy độ dài chuỗi với độ phức tạp hằng số</span></a></h3><ul><li>Chuỗi C: Vì chuỗi C không ghi nhận thông tin độ dài của chính nó, để lấy độ dài của một chuỗi C, chương trình phải duyệt qua toàn bộ chuỗi, đếm từng ký tự cho đến khi gặp ký tự null đánh dấu kết thúc chuỗi. Độ phức tạp của thao tác này là <code>O(N)</code>.</li><li>SDS: SDS ghi nhận độ dài của chính nó trong thuộc tính <code>len</code>, do đó để lấy độ dài của SDS chỉ mất độ phức tạp <code>O(1)</code>. Công việc thiết lập và cập nhật độ dài SDS được thực hiện tự động bởi API của SDS khi thực thi, không cần phải chỉnh sửa độ dài bằng tay.</li></ul><h3 id="ngan-chan-tran-bo-đem" tabindex="-1"><a class="header-anchor" href="#ngan-chan-tran-bo-đem"><span>Ngăn chặn tràn bộ đệm</span></a></h3><ul><li>Chuỗi C: Vì chuỗi C không ghi nhận độ dài của chính nó, điều này dễ dẫn đến vấn đề tràn bộ đệm (buffer overflow).</li><li>SDS: Khi API của SDS cần thay đổi SDS, nó trước tiên kiểm tra xem không gian SDS có đáp ứng yêu cầu thay đổi hay không. Nếu không đủ, API sẽ tự động mở rộng không gian SDS đến kích thước cần thiết trước khi thực hiện thay đổi thực tế. Do đó, việc sử dụng SDS không cần phải điều chỉnh kích thước không gian SDS thủ công và không gặp vấn đề tràn bộ đệm như chuỗi C.</li></ul><h3 id="giam-so-lan-phan-bo-lai-bo-nho-khi-thay-đoi-đo-dai-chuoi" tabindex="-1"><a class="header-anchor" href="#giam-so-lan-phan-bo-lai-bo-nho-khi-thay-đoi-đo-dai-chuoi"><span>Giảm số lần phân bổ lại bộ nhớ khi thay đổi độ dài chuỗi</span></a></h3><ul><li>Chuỗi C: Với một chuỗi C có <code>N</code> ký tự, triển khai dưới cơ sở dữ liệu của chuỗi C luôn có mảng dài <code>N+1</code> ký tự (bao gồm một ký tự thêm để lưu ký tự null). Bởi vì có sự tương quan giữa độ dài chuỗi và độ dài của mảng cơ sở, mỗi lần tăng hoặc giảm độ dài của một chuỗi C đều yêu cầu một phép phân bổ lại bộ nhớ cho mảng lưu trữ chuỗi này. <ul><li>Khi tăng độ dài chuỗi mà không phân bổ lại bộ nhớ, có nguy cơ tràn bộ đệm.</li><li>Khi giảm độ dài chuỗi mà không phân bổ lại bộ nhớ, có nguy cơ rò rỉ bộ nhớ.</li></ul></li><li>SDS: Bằng cách sử dụng không gian chưa sử dụng, SDS loại bỏ sự phụ thuộc giữa độ dài chuỗi và độ dài của mảng cơ sở: độ dài mảng <code>buf</code> trong SDS không nhất thiết phải bằng số lượng ký tự cộng một. Thay vào đó, mảng này có thể chứa các byte chưa sử dụng, và số lượng byte này được ghi nhận bởi thuộc tính <code>free</code> của SDS. SDS thực hiện hai chiến lược tối ưu hóa sau: <ul><li><strong>Dự trữ không gian</strong> - Dự trữ không gian được sử dụng để tối ưu hóa việc mở rộng chuỗi SDS. Khi API của SDS sửa đổi một SDS và cần mở rộng không gian, chương trình không chỉ cấp phát không gian cần thiết cho sửa đổi, mà còn cấp phát không gian chưa sử dụng thêm. Bằng cách này, SDS giảm số lần phân bổ lại bộ nhớ cần thiết khi chuỗi tăng dần liên tục <code>N</code> lần từ bắt buộc xuống tối đa <code>N</code> lần.</li><li><strong>Giải phóng không gian một cách lười biếng</strong> - Chiến lược giải phóng không gian một cách lười biếng được sử dụng để tối ưu hóa việc rút ngắn chuỗi SDS. Khi API của SDS cần rút ngắn chuỗi SDS, chương trình không sử dụng ngay lập tức phân bổ lại bộ nhớ để thu hồi các byte dư thừa sau khi rút ngắn. Thay vào đó, nó sử dụng thuộc tính <code>free</code> để ghi nhận số lượng byte này và chờ đợi sử dụng trong tương lai. Bằng cách này, SDS tránh phải thực hiện phân bổ lại bộ nhớ khi rút ngắn chuỗi và tối ưu hóa cho các thao tác tăng dần có thể xảy ra trong tương lai.</li></ul></li></ul><h3 id="an-toan-cho-du-lieu-nhi-phan" tabindex="-1"><a class="header-anchor" href="#an-toan-cho-du-lieu-nhi-phan"><span>An toàn cho dữ liệu nhị phân</span></a></h3><ul><li>Chuỗi C: Ký tự trong chuỗi C phải tuân thủ một mã hóa nhất định (ví dụ: ASCII), và ngoài ký tự null ở cuối chuỗi, chuỗi không thể chứa ký tự null. Nếu có, ký tự null đầu tiên được chương trình đọc sẽ bị hiểu lầm là kết thúc chuỗi — những hạn chế này khiến <strong>chuỗi C chỉ có thể lưu trữ dữ liệu văn bản</strong> và không thể lưu trữ các dạng dữ liệu nhị phân như hình ảnh, âm thanh, video, tệp nén.</li><li>SDS: Các API của SDS đều an toàn cho dữ liệu nhị phân (binary-safe): Tất cả các API của SDS xử lý dữ liệu trong mảng <code>buf</code> theo cách xử lý dữ liệu nhị phân, chương trình không giới hạn, lọc, hoặc giả định về dữ liệu trong đó — dữ liệu được viết vào là gì, thì khi đọc ra sẽ vẫn là như vậy. <strong>Bằng cách sử dụng SDS an toàn cho dữ liệu nhị phân</strong>, Redis không chỉ có thể lưu trữ dữ liệu văn bản, mà còn có thể lưu trữ bất kỳ định dạng dữ liệu nhị phân nào.</li></ul><h3 id="tuong-thich-voi-mot-so-ham-chuoi-c" tabindex="-1"><a class="header-anchor" href="#tuong-thich-voi-mot-so-ham-chuoi-c"><span>Tương thích với một số hàm chuỗi C</span></a></h3><p>Mặc dù các API của SDS an toàn cho dữ liệu nhị phân, SDS vẫn tuân thủ quy ước chuỗi C bằng cách thiết lập ký tự null ở cuối dữ liệu được lưu trữ và luôn cấp phát thêm một byte cho mảng <code>buf</code> để chứa ký tự null này — điều này giúp các SDS lưu trữ dữ liệu văn bản có thể sử dụng lại một phần các hàm được định nghĩa trong thư viện <code>&lt;string.h&gt;</code> của C. Do đó, SDS có thể tương thích với một số hàm chuỗi C.</p><h2 id="danh-sach-lien-ket" tabindex="-1"><a class="header-anchor" href="#danh-sach-lien-ket"><span>Danh sách liên kết</span></a></h2><h3 id="gioi-thieu-ve-danh-sach-lien-ket" tabindex="-1"><a class="header-anchor" href="#gioi-thieu-ve-danh-sach-lien-ket"><span>Giới thiệu về Danh sách liên kết</span></a></h3><p>Danh sách liên kết được sử dụng rộng rãi trong Redis để thực hiện nhiều chức năng như các khóa Danh sách (List), đăng ký và phát hành (publish-subscribe), truy vấn chậm, trình giám sát và nhiều chức năng khác. Ngoài ra, Redis còn sử dụng danh sách liên kết để lưu trữ thông tin trạng thái của nhiều khách hàng và xây dựng bộ đệm đầu ra (output buffer) cho khách hàng.</p><p>Bởi vì ngôn ngữ lập trình C không tích hợp sẵn danh sách liên kết, Redis đã tự triển khai một danh sách liên kết của riêng mình: <strong>Danh sách liên kết trong Redis thực tế là một danh sách liên kết hai chiều</strong>.</p><ul><li>Mỗi danh sách liên kết được biểu diễn bằng một cấu trúc <code>list</code>, cấu trúc này bao gồm con trỏ đến nút đầu danh sách, con trỏ đến nút cuối danh sách và thông tin về độ dài của danh sách.</li><li>Vì nút trước nút đầu danh sách và nút sau nút cuối danh sách đều trỏ đến <code>NULL</code>, do đó, cài đặt danh sách liên kết trong Redis là danh sách liên kết không có vòng lặp.</li><li>Bằng cách thiết lập các hàm đặc thù cho từng loại, danh sách liên kết trong Redis có thể được sử dụng để lưu trữ các giá trị khác nhau.</li></ul><p>Danh sách liên kết trong Redis cung cấp các tính năng chèn, xóa và tìm kiếm hiệu quả, làm cho nó rất hữu ích và linh hoạt trong việc triển khai nhiều cấu trúc dữ liệu và chức năng khác nhau trong Redis.</p><h3 id="trien-khai-cua-danh-sach-lien-ket" tabindex="-1"><a class="header-anchor" href="#trien-khai-cua-danh-sach-lien-ket"><span>Triển khai của Danh sách liên kết</span></a></h3><p>Mỗi nút trong danh sách liên kết được biểu diễn bằng cấu trúc <code>adlist.h/listNode</code>. Mỗi nút này có một con trỏ trỏ đến nút phía trước và nút phía sau, do đó, danh sách liên kết trong Redis được triển khai như là một danh sách liên kết hai chiều.</p><div class="language-c" data-ext="c" data-title="c"><pre class="shiki shiki-themes one-dark-pro one-dark-pro vp-code" style="background-color:#282c34;--shiki-dark-bg:#282c34;color:#abb2bf;--shiki-dark:#abb2bf;" tabindex="0"><code><span class="line"><span style="color:#C678DD;--shiki-dark:#C678DD;">typedef</span><span style="color:#C678DD;--shiki-dark:#C678DD;"> struct</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;"> listNode {</span></span>
<span class="line"></span>
<span class="line"><span style="color:#7F848E;--shiki-dark:#7F848E;font-style:italic;--shiki-dark-font-style:italic;">    // Con trỏ đến nút phía trước</span></span>
<span class="line"><span style="color:#C678DD;--shiki-dark:#C678DD;">    struct</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;"> listNode </span><span style="color:#C678DD;--shiki-dark:#C678DD;">*</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">prev;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#7F848E;--shiki-dark:#7F848E;font-style:italic;--shiki-dark-font-style:italic;">    // Con trỏ đến nút phía sau</span></span>
<span class="line"><span style="color:#C678DD;--shiki-dark:#C678DD;">    struct</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;"> listNode </span><span style="color:#C678DD;--shiki-dark:#C678DD;">*</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">next;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#7F848E;--shiki-dark:#7F848E;font-style:italic;--shiki-dark-font-style:italic;">    // Giá trị của nút</span></span>
<span class="line"><span style="color:#C678DD;--shiki-dark:#C678DD;">    void</span><span style="color:#C678DD;--shiki-dark:#C678DD;"> *</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">value;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">} listNode;</span></span></code></pre></div><p>Nhiều <code>listNode</code> có thể được sắp xếp lại với nhau bằng cách sử dụng các con trỏ <code>prev</code> và <code>next</code>, hình thành một danh sách liên kết hai chiều.</p><figure><img src="https://raw.githubusercontent.com/vanhung4499/images/master/snap/20240624201754.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>Mặc dù chỉ cần sử dụng nhiều cấu trúc <code>listNode</code> là có thể tạo thành danh sách liên kết, nhưng việc sử dụng <code>adlist.h/list</code> để lưu giữ danh sách liên kết sẽ làm cho việc thao tác dễ dàng hơn:</p><div class="language-c line-numbers-mode" data-ext="c" data-title="c"><pre class="shiki shiki-themes one-dark-pro one-dark-pro vp-code" style="background-color:#282c34;--shiki-dark-bg:#282c34;color:#abb2bf;--shiki-dark:#abb2bf;" tabindex="0"><code><span class="line"><span style="color:#C678DD;--shiki-dark:#C678DD;">typedef</span><span style="color:#C678DD;--shiki-dark:#C678DD;"> struct</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;"> list {</span></span>
<span class="line"></span>
<span class="line"><span style="color:#7F848E;--shiki-dark:#7F848E;font-style:italic;--shiki-dark-font-style:italic;">    // Con trỏ đến nút đầu danh sách</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">    listNode </span><span style="color:#C678DD;--shiki-dark:#C678DD;">*</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">head;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#7F848E;--shiki-dark:#7F848E;font-style:italic;--shiki-dark-font-style:italic;">    // Con trỏ đến nút cuối danh sách</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">    listNode </span><span style="color:#C678DD;--shiki-dark:#C678DD;">*</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">tail;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#7F848E;--shiki-dark:#7F848E;font-style:italic;--shiki-dark-font-style:italic;">    // Số lượng nút trong danh sách</span></span>
<span class="line"><span style="color:#C678DD;--shiki-dark:#C678DD;">    unsigned</span><span style="color:#C678DD;--shiki-dark:#C678DD;"> long</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;"> len;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#7F848E;--shiki-dark:#7F848E;font-style:italic;--shiki-dark-font-style:italic;">    // Hàm sao chép giá trị của nút</span></span>
<span class="line"><span style="color:#C678DD;--shiki-dark:#C678DD;">    void</span><span style="color:#C678DD;--shiki-dark:#C678DD;"> *</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">(</span><span style="color:#C678DD;--shiki-dark:#C678DD;">*</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">dup)(</span><span style="color:#C678DD;--shiki-dark:#C678DD;">void</span><span style="color:#C678DD;--shiki-dark:#C678DD;"> *</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">ptr);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#7F848E;--shiki-dark:#7F848E;font-style:italic;--shiki-dark-font-style:italic;">    // Hàm giải phóng giá trị của nút</span></span>
<span class="line"><span style="color:#C678DD;--shiki-dark:#C678DD;">    void</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;"> (</span><span style="color:#C678DD;--shiki-dark:#C678DD;">*</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">free)(</span><span style="color:#C678DD;--shiki-dark:#C678DD;">void</span><span style="color:#C678DD;--shiki-dark:#C678DD;"> *</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">ptr);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#7F848E;--shiki-dark:#7F848E;font-style:italic;--shiki-dark-font-style:italic;">    // Hàm so sánh giá trị của nút</span></span>
<span class="line"><span style="color:#C678DD;--shiki-dark:#C678DD;">    int</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;"> (</span><span style="color:#C678DD;--shiki-dark:#C678DD;">*</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">match)(</span><span style="color:#C678DD;--shiki-dark:#C678DD;">void</span><span style="color:#C678DD;--shiki-dark:#C678DD;"> *</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">ptr, </span><span style="color:#C678DD;--shiki-dark:#C678DD;">void</span><span style="color:#C678DD;--shiki-dark:#C678DD;"> *</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">key);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">} list;</span></span></code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Cấu trúc <code>list</code> cung cấp con trỏ <code>head</code> (đầu danh sách), <code>tail</code> (cuối danh sách) và <code>len</code> (độ dài danh sách). Các thành viên <code>dup</code>, <code>free</code> và <code>match</code> được sử dụng để triển khai các hàm đặc thù cho từng loại dữ liệu của danh sách:</p><ul><li>Hàm <code>dup</code> - dùng để sao chép giá trị của nút trong danh sách.</li><li>Hàm <code>free</code> - dùng để giải phóng giá trị của nút trong danh sách.</li><li>Hàm <code>match</code> - dùng để so sánh giá trị của nút với một giá trị khác.</li></ul><figure><img src="https://raw.githubusercontent.com/vanhung4499/images/master/snap/20240624201852.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h2 id="tu-đien" tabindex="-1"><a class="header-anchor" href="#tu-đien"><span>Từ điển</span></a></h2><h3 id="gioi-thieu-ve-tu-đien" tabindex="-1"><a class="header-anchor" href="#gioi-thieu-ve-tu-đien"><span>Giới thiệu về Từ điển</span></a></h3><p>Từ điển (Dictionary) là một cấu trúc dữ liệu trừu tượng được sử dụng để lưu trữ các cặp khóa-giá trị (key-value pairs). Mỗi khóa trong từ điển là duy nhất, cho phép chương trình tìm kiếm, cập nhật hoặc xóa giá trị liên quan dựa trên khóa, cùng với các thao tác khác.</p><p>Redis đã tự triển khai một cấu trúc từ điển do ngôn ngữ lập trình C không hỗ trợ cấu trúc từ điển sẵn có.</p><p>Từ điển được sử dụng rộng rãi trong Redis để triển khai các chức năng khác nhau, bao gồm cả cơ sở dữ liệu và các khóa băm (Hash Keys).</p><h3 id="trien-khai-cua-tu-đien" tabindex="-1"><a class="header-anchor" href="#trien-khai-cua-tu-đien"><span>Triển khai của Từ điển</span></a></h3><p>Redis sử dụng bảng băm (hash table) làm cấu trúc dữ liệu cơ sở cho từ điển, trong đó mỗi bảng băm có thể chứa nhiều nút bảng băm, và mỗi nút này lưu trữ một cặp khóa-giá trị trong từ điển.</p><p>Cấu trúc <code>dictht</code> trong Redis được định nghĩa như sau:</p><div class="language-c line-numbers-mode" data-ext="c" data-title="c"><pre class="shiki shiki-themes one-dark-pro one-dark-pro vp-code" style="background-color:#282c34;--shiki-dark-bg:#282c34;color:#abb2bf;--shiki-dark:#abb2bf;" tabindex="0"><code><span class="line"><span style="color:#C678DD;--shiki-dark:#C678DD;">typedef</span><span style="color:#C678DD;--shiki-dark:#C678DD;"> struct</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;"> dictht {</span></span>
<span class="line"></span>
<span class="line"><span style="color:#7F848E;--shiki-dark:#7F848E;font-style:italic;--shiki-dark-font-style:italic;">    // Mảng của bảng băm</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">    dictEntry </span><span style="color:#C678DD;--shiki-dark:#C678DD;">**</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">table;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#7F848E;--shiki-dark:#7F848E;font-style:italic;--shiki-dark-font-style:italic;">    // Kích thước của bảng băm</span></span>
<span class="line"><span style="color:#C678DD;--shiki-dark:#C678DD;">    unsigned</span><span style="color:#C678DD;--shiki-dark:#C678DD;"> long</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;"> size;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#7F848E;--shiki-dark:#7F848E;font-style:italic;--shiki-dark-font-style:italic;">    // Mặt nạ kích thước của bảng băm, dùng để tính chỉ số</span></span>
<span class="line"><span style="color:#7F848E;--shiki-dark:#7F848E;font-style:italic;--shiki-dark-font-style:italic;">    // Luôn luôn bằng size - 1</span></span>
<span class="line"><span style="color:#C678DD;--shiki-dark:#C678DD;">    unsigned</span><span style="color:#C678DD;--shiki-dark:#C678DD;"> long</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;"> sizemask;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#7F848E;--shiki-dark:#7F848E;font-style:italic;--shiki-dark-font-style:italic;">    // Số lượng nút hiện có trong bảng băm</span></span>
<span class="line"><span style="color:#C678DD;--shiki-dark:#C678DD;">    unsigned</span><span style="color:#C678DD;--shiki-dark:#C678DD;"> long</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;"> used;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">} dictht;</span></span></code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>Thuộc tính <code>table</code> là một mảng các con trỏ tới cấu trúc <code>dictEntry</code>, mỗi <code>dictEntry</code> lưu trữ một cặp khóa-giá trị.</li><li>Thuộc tính <code>size</code> là kích thước của bảng băm, tức là kích thước của mảng <code>table</code>.</li><li>Thuộc tính <code>sizemask</code> là mặt nạ kích thước của bảng băm, được sử dụng để tính chỉ số của khóa.</li><li>Thuộc tính <code>used</code> là số lượng nút (cặp khóa-giá trị) đã được thêm vào bảng băm.</li></ul><figure><img src="https://raw.githubusercontent.com/vanhung4499/images/master/snap/20240624215302.png" alt="image.png" tabindex="0" loading="lazy"><figcaption>image.png</figcaption></figure><p>Cấu trúc <code>dictEntry</code> đại diện cho một nút trong bảng băm, lưu trữ một cặp khóa-giá trị như sau:</p><div class="language-c line-numbers-mode" data-ext="c" data-title="c"><pre class="shiki shiki-themes one-dark-pro one-dark-pro vp-code" style="background-color:#282c34;--shiki-dark-bg:#282c34;color:#abb2bf;--shiki-dark:#abb2bf;" tabindex="0"><code><span class="line"><span style="color:#C678DD;--shiki-dark:#C678DD;">typedef</span><span style="color:#C678DD;--shiki-dark:#C678DD;"> struct</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;"> dictEntry {</span></span>
<span class="line"></span>
<span class="line"><span style="color:#7F848E;--shiki-dark:#7F848E;font-style:italic;--shiki-dark-font-style:italic;">    // Khóa</span></span>
<span class="line"><span style="color:#C678DD;--shiki-dark:#C678DD;">    void</span><span style="color:#C678DD;--shiki-dark:#C678DD;"> *</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">key;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#7F848E;--shiki-dark:#7F848E;font-style:italic;--shiki-dark-font-style:italic;">    // Giá trị</span></span>
<span class="line"><span style="color:#C678DD;--shiki-dark:#C678DD;">    union</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="color:#C678DD;--shiki-dark:#C678DD;">        void</span><span style="color:#C678DD;--shiki-dark:#C678DD;"> *</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">val;</span></span>
<span class="line"><span style="color:#C678DD;--shiki-dark:#C678DD;">        uint64_t</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;"> u64;</span></span>
<span class="line"><span style="color:#C678DD;--shiki-dark:#C678DD;">        int64_t</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;"> s64;</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">    } v;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#7F848E;--shiki-dark:#7F848E;font-style:italic;--shiki-dark-font-style:italic;">    // Con trỏ đến nút bảng băm tiếp theo, tạo thành danh sách liên kết</span></span>
<span class="line"><span style="color:#C678DD;--shiki-dark:#C678DD;">    struct</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;"> dictEntry </span><span style="color:#C678DD;--shiki-dark:#C678DD;">*</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">next;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">} dictEntry;</span></span></code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>Thuộc tính <code>key</code> lưu trữ khóa của cặp khóa-giá trị.</li><li>Thuộc tính <code>v</code> lưu trữ giá trị tương ứng với khóa. Giá trị có thể là một con trỏ, hoặc một số nguyên <code>uint64_t</code> hoặc <code>int64_t</code>.</li><li>Thuộc tính <code>next</code> là con trỏ đến nút bảng băm kế tiếp trong trường hợp xảy ra va chạm (collision), để tạo thành một danh sách liên kết.</li></ul><figure><img src="https://raw.githubusercontent.com/vanhung4499/images/master/snap/20240624215319.png" alt="image.png" tabindex="0" loading="lazy"><figcaption>image.png</figcaption></figure><p>Cấu trúc <code>dict</code> trong Redis đại diện cho từ điển:</p><div class="language-c line-numbers-mode" data-ext="c" data-title="c"><pre class="shiki shiki-themes one-dark-pro one-dark-pro vp-code" style="background-color:#282c34;--shiki-dark-bg:#282c34;color:#abb2bf;--shiki-dark:#abb2bf;" tabindex="0"><code><span class="line"><span style="color:#C678DD;--shiki-dark:#C678DD;">typedef</span><span style="color:#C678DD;--shiki-dark:#C678DD;"> struct</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;"> dict {</span></span>
<span class="line"></span>
<span class="line"><span style="color:#7F848E;--shiki-dark:#7F848E;font-style:italic;--shiki-dark-font-style:italic;">    // Hàm đặc thù cho từng loại</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">    dictType </span><span style="color:#C678DD;--shiki-dark:#C678DD;">*</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">type;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#7F848E;--shiki-dark:#7F848E;font-style:italic;--shiki-dark-font-style:italic;">    // Dữ liệu riêng tư</span></span>
<span class="line"><span style="color:#C678DD;--shiki-dark:#C678DD;">    void</span><span style="color:#C678DD;--shiki-dark:#C678DD;"> *</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">privdata;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#7F848E;--shiki-dark:#7F848E;font-style:italic;--shiki-dark-font-style:italic;">    // Bảng băm</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">    dictht </span><span style="color:#E06C75;--shiki-dark:#E06C75;">ht</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">[</span><span style="color:#D19A66;--shiki-dark:#D19A66;">2</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">];</span></span>
<span class="line"></span>
<span class="line"><span style="color:#7F848E;--shiki-dark:#7F848E;font-style:italic;--shiki-dark-font-style:italic;">    // Chỉ số tái băm</span></span>
<span class="line"><span style="color:#7F848E;--shiki-dark:#7F848E;font-style:italic;--shiki-dark-font-style:italic;">    // Nếu không tái băm thì giá trị là -1</span></span>
<span class="line"><span style="color:#C678DD;--shiki-dark:#C678DD;">    int</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;"> rehashidx;</span><span style="color:#7F848E;--shiki-dark:#7F848E;font-style:italic;--shiki-dark-font-style:italic;"> /* rehashing not in progress if rehashidx == -1 */</span></span>
<span class="line"></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">} dict;</span></span></code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>Thuộc tính <code>type</code> và <code>privdata</code> được sử dụng cho các hàm đặc thù của từng loại, cho phép Redis triển khai từ điển đa hình.</li><li>Thuộc tính <code>ht</code> là một mảng có 2 phần tử, mỗi phần tử là một cấu trúc <code>dictht</code> bảng băm. Thông thường, từ điển chỉ sử dụng <code>ht[0]</code>, <code>ht[1]</code> được sử dụng chỉ khi tái băm (rehashing).</li><li>Thuộc tính <code>rehashidx</code> là chỉ số tái băm, ghi nhận tiến độ tái băm hiện tại. Nếu không có tái băm nào đang diễn ra, giá trị sẽ là <code>-1</code>.</li></ul><figure><img src="https://raw.githubusercontent.com/vanhung4499/images/master/snap/20240624215336.png" alt="image.png" tabindex="0" loading="lazy"><figcaption>image.png</figcaption></figure><h3 id="thuat-toan-bam" tabindex="-1"><a class="header-anchor" href="#thuat-toan-bam"><span>Thuật toán băm</span></a></h3><p>Khi từ điển được sử dụng làm cài đặt cơ sở dữ liệu hoặc cài đặt cơ sở dữ liệu của các khóa băm, Redis sử dụng thuật toán <a href="http://code.google.com/p/smhasher/" target="_blank" rel="noopener noreferrer">MurmurHash2</a> để tính toán giá trị băm của khóa.</p><p>Redis tính toán giá trị băm và chỉ mục như sau:</p><div class="language-c" data-ext="c" data-title="c"><pre class="shiki shiki-themes one-dark-pro one-dark-pro vp-code" style="background-color:#282c34;--shiki-dark-bg:#282c34;color:#abb2bf;--shiki-dark:#abb2bf;" tabindex="0"><code><span class="line"><span style="color:#7F848E;--shiki-dark:#7F848E;font-style:italic;--shiki-dark-font-style:italic;">// Sử dụng hàm băm được thiết lập cho từ điển, tính toán giá trị băm của khóa key</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">hash </span><span style="color:#C678DD;--shiki-dark:#C678DD;">=</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;"> dict</span><span style="color:#C678DD;--shiki-dark:#C678DD;">-&gt;</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">type</span><span style="color:#C678DD;--shiki-dark:#C678DD;">-&gt;</span><span style="color:#61AFEF;--shiki-dark:#61AFEF;">hashFunction</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">(</span><span style="color:#E06C75;--shiki-dark:#E06C75;">key</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#7F848E;--shiki-dark:#7F848E;font-style:italic;--shiki-dark-font-style:italic;">// Sử dụng thuộc tính sizemask của bảng băm và giá trị băm để tính chỉ mục</span></span>
<span class="line"><span style="color:#7F848E;--shiki-dark:#7F848E;font-style:italic;--shiki-dark-font-style:italic;">// Tùy vào hoàn cảnh, ht[x] có thể là ht[0] hoặc ht[1]</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">index </span><span style="color:#C678DD;--shiki-dark:#C678DD;">=</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;"> hash </span><span style="color:#C678DD;--shiki-dark:#C678DD;">&amp;</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;"> dict</span><span style="color:#C678DD;--shiki-dark:#C678DD;">-&gt;</span><span style="color:#E06C75;--shiki-dark:#E06C75;">ht</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">[x].sizemask;</span></span></code></pre></div><h3 id="xu-ly-va-cham" tabindex="-1"><a class="header-anchor" href="#xu-ly-va-cham"><span>Xử lý va chạm</span></a></h3><p>Khi hai hoặc nhiều hơn hai khóa được gán vào cùng một chỉ mục của mảng bảng băm, chúng ta gọi là xảy ra va chạm (collision).</p><p>Redis sử dụng phương pháp xử lý va chạm dùng chuỗi riêng (separate chaining) để giải quyết các va chạm: Mỗi nút bảng băm có một con trỏ <code>next</code>, nhiều nút bảng băm có thể được kết nối với nhau để tạo thành một danh sách liên kết đơn hướng, các nút này được gán vào cùng một chỉ mục sẽ được kết nối với nhau qua danh sách liên kết này, từ đó giải quyết được vấn đề của va chạm.</p><figure><img src="https://raw.githubusercontent.com/vanhung4499/images/master/snap/20240624215524.png" alt="image.png" tabindex="0" loading="lazy"><figcaption>image.png</figcaption></figure><h3 id="rehash" tabindex="-1"><a class="header-anchor" href="#rehash"><span>rehash</span></a></h3><h4 id="cac-buoc-cua-rehash" tabindex="-1"><a class="header-anchor" href="#cac-buoc-cua-rehash"><span>Các bước của rehash</span></a></h4><ol><li><p><strong>Phân bổ không gian cho <code>ht[1]</code>:</strong></p><ul><li>Tạo không gian cho bảng băm <code>ht[1]</code> của từ điển, kích thước của bảng này phụ thuộc vào hoạt động cụ thể và số lượng cặp khóa-giá trị hiện có trong <code>ht[0]</code> (được biểu diễn bởi thuộc tính <code>ht[0].used</code>).</li></ul></li><li><p><strong>Di chuyển tất cả các cặp khóa-giá trị từ <code>ht[0]</code> sang <code>ht[1]</code>:</strong></p><ul><li>Rehashing đề cập đến việc tính toán lại giá trị băm của khóa và chỉ mục của nó, sau đó đặt cặp khóa-giá trị vào vị trí xác định trong bảng băm <code>ht[1]</code>.</li></ul></li><li><p><strong>Khi tất cả các cặp khóa-giá trị từ <code>ht[0]</code> đã được di chuyển sang <code>ht[1]</code>:</strong></p><ul><li><code>ht[0]</code> sẽ trở thành bảng rỗng, được giải phóng, và <code>ht[1]</code> sẽ được thiết lập là <code>ht[0]</code>.</li><li>Một bảng băm mới trống sẽ được tạo cho <code>ht[1]</code>, chuẩn bị cho lần rehash tiếp theo.</li></ul></li></ol><figure><img src="https://raw.githubusercontent.com/vanhung4499/images/master/snap/20240624215901.png" alt="image.png" tabindex="0" loading="lazy"><figcaption>image.png</figcaption></figure><figure><img src="https://raw.githubusercontent.com/vanhung4499/images/master/snap/20240624215909.png" alt="image.png" tabindex="0" loading="lazy"><figcaption>image.png</figcaption></figure><figure><img src="https://raw.githubusercontent.com/vanhung4499/images/master/snap/20240624215917.png" alt="image.png" tabindex="0" loading="lazy"><figcaption>image.png</figcaption></figure><figure><img src="https://raw.githubusercontent.com/vanhung4499/images/master/snap/20240624215924.png" alt="image.png" tabindex="0" loading="lazy"><figcaption>image.png</figcaption></figure><figure><img src="https://raw.githubusercontent.com/vanhung4499/images/master/snap/20240624215931.png" alt="image.png" tabindex="0" loading="lazy"><figcaption>image.png</figcaption></figure><figure><img src="https://raw.githubusercontent.com/vanhung4499/images/master/snap/20240624215938.png" alt="image.png" tabindex="0" loading="lazy"><figcaption>image.png</figcaption></figure><h4 id="cac-đieu-kien-đe-thuc-hien-rehash" tabindex="-1"><a class="header-anchor" href="#cac-đieu-kien-đe-thuc-hien-rehash"><span>Các điều kiện để thực hiện rehash</span></a></h4><ul><li><p>Khi một trong những điều kiện sau được đáp ứng, Redis sẽ tự động bắt đầu mở rộng bảng băm:</p><ol><li>Server hiện không thực thi lệnh BGSAVE hoặc BGREWRITEAOF và hệ số tải của bảng băm (<code>load factor</code>) lớn hơn hoặc bằng <code>1</code>.</li><li>Server đang thực thi lệnh BGSAVE hoặc BGREWRITEAOF và hệ số tải của bảng băm lớn hơn hoặc bằng <code>5</code>.</li></ol><p>Hệ số tải của bảng băm có thể tính theo công thức sau:</p><div class="language-" data-ext="" data-title=""><pre class="shiki shiki-themes one-dark-pro one-dark-pro vp-code" style="background-color:#282c34;--shiki-dark-bg:#282c34;color:#abb2bf;--shiki-dark:#abb2bf;" tabindex="0"><code><span class="line"><span>load_factor = ht[0].used / ht[0].size</span></span></code></pre></div></li></ul><h4 id="rehash-tung-buoc-progressive-rehash" tabindex="-1"><a class="header-anchor" href="#rehash-tung-buoc-progressive-rehash"><span>Rehash từng bước (Progressive rehash)</span></a></h4><ul><li>Bước chi tiết của rehash tiến bộ như sau: <ol><li>Phân bổ không gian cho <code>ht[1]</code>, cho phép từ điển giữ cả hai bảng băm <code>ht[0]</code> và <code>ht[1]</code>.</li><li>Duy trì một biến đếm chỉ mục rehash <code>rehashidx</code> trong từ điển và thiết lập nó bằng <code>0</code> để bắt đầu công việc rehash.</li><li>Trong suốt quá trình rehash, mỗi lần thực hiện thêm, xóa, tìm kiếm hoặc cập nhật trong từ điển, chương trình sẽ thực hiện rehash tất cả các cặp khóa-giá trị của <code>ht[0]</code> tại chỉ mục <code>rehashidx</code> sang <code>ht[1]</code>.</li><li>Sau khi công việc rehash hoàn tất, giá trị của <code>rehashidx</code> sẽ tăng lên một.</li><li>Khi mọi cặp khóa-giá trị từ <code>ht[0]</code> đã được rehash sang <code>ht[1]</code>, Redis sẽ đặt giá trị của <code>rehashidx</code> thành <code>-1</code>, chỉ ra rằng công việc rehash đã hoàn thành.</li></ol></li></ul><p>Qua việc sử dụng MurmurHash2 và phương pháp xử lý va chạm bằng chuỗi riêng, Redis đảm bảo hiệu quả và hiệu suất của từ điển trong việc lưu trữ và truy xuất các cặp khóa-giá trị một cách hiệu quả.</p><h2 id="skip-list" tabindex="-1"><a class="header-anchor" href="#skip-list"><span>Skip List</span></a></h2><h3 id="gioi-thieu-ve-skip-list" tabindex="-1"><a class="header-anchor" href="#gioi-thieu-ve-skip-list"><span>Giới thiệu về Skip List</span></a></h3><p>Skip List (hay còn gọi là skiplist) là một cấu trúc dữ liệu sắp xếp, được xây dựng dựa trên các con trỏ nối đến các nút khác nhau trong mỗi nút để thực hiện việc truy cập nhanh chóng vào các nút. Skip List hỗ trợ việc tìm kiếm các nút với độ phức tạp trung bình là O(log N), trong trường hợp xấu nhất là O(N), và cũng hỗ trợ các thao tác tuần tự để xử lý các nút một cách nhanh chóng.</p><p>Trong hầu hết các trường hợp, hiệu suất của Skip List có thể sánh ngang với cây cân bằng và vì cách thức triển khai đơn giản hơn, nên có nhiều chương trình sử dụng Skip List để thay thế cho cây cân bằng.</p><p>Redis sử dụng Skip List làm một trong các triển khai cơ sở của các khóa tập hợp có thứ tự: nếu một tập hợp có thứ tự chứa một số lượng phần tử lớn, hoặc các thành viên trong tập hợp có thứ tự là các chuỗi dài, Redis sẽ sử dụng Skip List làm cơ sở dữ liệu của khóa tập hợp có thứ tự.</p><p>Bên cạnh đó, Redis cũng sử dụng Skip List trong các nút cụm của mạng lưới.</p><h3 id="trien-khai-skip-list" tabindex="-1"><a class="header-anchor" href="#trien-khai-skip-list"><span>Triển khai Skip List</span></a></h3><p>Triển khai Skip List trong Redis bao gồm hai cấu trúc: <code>zskiplist</code> và <code>zskiplistNode</code>, trong đó <code>zskiplist</code> được sử dụng để lưu trữ thông tin của Skip List (ví dụ như nút đầu tiên và nút cuối cùng của Skip List, độ dài), và <code>zskiplistNode</code> được sử dụng để đại diện cho từng nút trong Skip List.</p><figure><img src="https://raw.githubusercontent.com/vanhung4499/images/master/snap/20240624220250.png" alt="image.png" tabindex="0" loading="lazy"><figcaption>image.png</figcaption></figure><p>Cấu trúc của <code>zskiplist</code> được định nghĩa như sau:</p><div class="language-c" data-ext="c" data-title="c"><pre class="shiki shiki-themes one-dark-pro one-dark-pro vp-code" style="background-color:#282c34;--shiki-dark-bg:#282c34;color:#abb2bf;--shiki-dark:#abb2bf;" tabindex="0"><code><span class="line"><span style="color:#C678DD;--shiki-dark:#C678DD;">typedef</span><span style="color:#C678DD;--shiki-dark:#C678DD;"> struct</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;"> zskiplist {</span></span>
<span class="line"></span>
<span class="line"><span style="color:#7F848E;--shiki-dark:#7F848E;font-style:italic;--shiki-dark-font-style:italic;">    // Con trỏ đến nút đầu tiên và nút cuối cùng của Skip List</span></span>
<span class="line"><span style="color:#C678DD;--shiki-dark:#C678DD;">    struct</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;"> zskiplistNode </span><span style="color:#C678DD;--shiki-dark:#C678DD;">*</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">header, </span><span style="color:#C678DD;--shiki-dark:#C678DD;">*</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">tail;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#7F848E;--shiki-dark:#7F848E;font-style:italic;--shiki-dark-font-style:italic;">    // Số lượng nút trong Skip List</span></span>
<span class="line"><span style="color:#C678DD;--shiki-dark:#C678DD;">    unsigned</span><span style="color:#C678DD;--shiki-dark:#C678DD;"> long</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;"> length;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#7F848E;--shiki-dark:#7F848E;font-style:italic;--shiki-dark-font-style:italic;">    // Số lớp của nút có số lượng lớn nhất trong Skip List</span></span>
<span class="line"><span style="color:#C678DD;--shiki-dark:#C678DD;">    int</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;"> level;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">} zskiplist;</span></span></code></pre></div><ul><li>Con trỏ <code>header</code> và <code>tail</code> lần lượt trỏ tới nút đầu tiên và nút cuối cùng của Skip List, cho phép việc xác định nút đầu và nút cuối của Skip List với độ phức tạp O(1).</li><li>Thuộc tính <code>length</code> lưu trữ số lượng nút trong Skip List, cho phép trả về độ dài của Skip List với độ phức tạp O(1).</li><li>Thuộc tính <code>level</code> được sử dụng để xác định số lớp của nút có số lượng lớn nhất trong Skip List, với mỗi nút trong Skip List có số lớp từ 1 đến 32 được chọn ngẫu nhiên.</li></ul><p>Cấu trúc của nút Skip List <code>zskiplistNode</code> được định nghĩa như sau:</p><div class="language-c line-numbers-mode" data-ext="c" data-title="c"><pre class="shiki shiki-themes one-dark-pro one-dark-pro vp-code" style="background-color:#282c34;--shiki-dark-bg:#282c34;color:#abb2bf;--shiki-dark:#abb2bf;" tabindex="0"><code><span class="line"><span style="color:#C678DD;--shiki-dark:#C678DD;">typedef</span><span style="color:#C678DD;--shiki-dark:#C678DD;"> struct</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;"> zskiplistNode {</span></span>
<span class="line"></span>
<span class="line"><span style="color:#7F848E;--shiki-dark:#7F848E;font-style:italic;--shiki-dark-font-style:italic;">    // Con trỏ lùi</span></span>
<span class="line"><span style="color:#C678DD;--shiki-dark:#C678DD;">    struct</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;"> zskiplistNode </span><span style="color:#C678DD;--shiki-dark:#C678DD;">*</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">backward;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#7F848E;--shiki-dark:#7F848E;font-style:italic;--shiki-dark-font-style:italic;">    // Điểm số</span></span>
<span class="line"><span style="color:#C678DD;--shiki-dark:#C678DD;">    double</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;"> score;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#7F848E;--shiki-dark:#7F848E;font-style:italic;--shiki-dark-font-style:italic;">    // Đối tượng thành viên</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">    robj </span><span style="color:#C678DD;--shiki-dark:#C678DD;">*</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">obj;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#7F848E;--shiki-dark:#7F848E;font-style:italic;--shiki-dark-font-style:italic;">    // Các lớp</span></span>
<span class="line"><span style="color:#C678DD;--shiki-dark:#C678DD;">    struct</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;"> zskiplistLevel {</span></span>
<span class="line"></span>
<span class="line"><span style="color:#7F848E;--shiki-dark:#7F848E;font-style:italic;--shiki-dark-font-style:italic;">        // Con trỏ tiến</span></span>
<span class="line"><span style="color:#C678DD;--shiki-dark:#C678DD;">        struct</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;"> zskiplistNode </span><span style="color:#C678DD;--shiki-dark:#C678DD;">*</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">forward;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#7F848E;--shiki-dark:#7F848E;font-style:italic;--shiki-dark-font-style:italic;">        // Khoảng cách</span></span>
<span class="line"><span style="color:#C678DD;--shiki-dark:#C678DD;">        unsigned</span><span style="color:#C678DD;--shiki-dark:#C678DD;"> int</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;"> span;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">    } level</span><span style="color:#C678DD;--shiki-dark:#C678DD;">[]</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">} zskiplistNode;</span></span></code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><strong>Các cấp (level)</strong>: Mỗi cấp bao gồm một con trỏ tiến và một khoảng cách. Con trỏ tiến được sử dụng để truy cập các nút khác ở phía cuối của Skip List và khoảng cách ghi lại sự khác biệt giữa nút tiến và nút hiện tại trong Skip List. Trong hình ảnh trên, các mũi tên có số thể hiện con trỏ tiến và số lượng thể hiện khoảng cách. Khi bạn đi qua từ nút đầu đến nút cuối, hành vi duyệt theo cấp sẽ được sử dụng.</li><li><strong>Con trỏ lùi (backward)</strong>: Con trỏ lùi chỉ đến nút trước nút hiện tại. Khi duyệt từ cuối đến đầu của Skip List, bạn sử dụng con trỏ lùi.</li><li><strong>Điểm số (score)</strong>: Trong Skip List, các nút được sắp xếp theo điểm số từ thấp đến cao. Trong cùng một Skip List, nhiều nút có thể chứa cùng một điểm số, nhưng đối tượng thành viên của mỗi nút phải là duy nhất. Các nút trong Skip List được sắp xếp theo điểm số và khi điểm số giống nhau, các nút được sắp xếp theo kích thước của thành viên.</li><li><strong>Đối tượng thành viên (obj)</strong>: Trong mỗi nút, <code>o1</code>, <code>o2</code> và <code>o3</code> là các thành viên của nút.</li></ul><h2 id="tap-hop-so-nguyen" tabindex="-1"><a class="header-anchor" href="#tap-hop-so-nguyen"><span>Tập hợp số nguyên</span></a></h2><h3 id="gioi-thieu-ve-tap-hop-so-nguyen" tabindex="-1"><a class="header-anchor" href="#gioi-thieu-ve-tap-hop-so-nguyen"><span>Giới thiệu về tập hợp số nguyên</span></a></h3><p><strong>Tập hợp số nguyên (intset)</strong> là một trong những cách thức lưu trữ dữ liệu của Redis cho các tập hợp có các phần tử là số nguyên. Khi một tập hợp chỉ bao gồm các phần tử số nguyên và số lượng phần tử không nhiều, Redis sẽ sử dụng cấu trúc dữ liệu tập hợp số nguyên để làm cơ sở dữ liệu.</p><p><strong>Cấu trúc dưới của tập hợp số nguyên là một mảng, mảng này lưu trữ các phần tử của tập hợp theo cách sắp xếp không trùng lặp</strong>.</p><p><strong>Hoạt động nâng cấp mang lại tính linh hoạt cho tập hợp số nguyên và cũng tiết kiệm bộ nhớ càng nhiều càng tốt</strong>.</p><p><strong>Tập hợp số nguyên chỉ hỗ trợ hoạt động nâng cấp, không hỗ trợ hoạt động hạ cấp</strong>.</p><h3 id="trien-khai-tap-hop-so-nguyen" tabindex="-1"><a class="header-anchor" href="#trien-khai-tap-hop-so-nguyen"><span>Triển khai tập hợp số nguyên</span></a></h3><p>Tập hợp số nguyên là cấu trúc dữ liệu trừu tượng của Redis để lưu trữ các giá trị số nguyên dưới dạng <code>int16_t</code>, <code>int32_t</code>, hoặc <code>int64_t</code>, đảm bảo rằng không có các phần tử trùng lặp trong tập hợp.</p><p>Mỗi cấu trúc <code>intset</code> trong <code>intset.h/intset</code> biểu thị một tập hợp số nguyên:</p><div class="language-c" data-ext="c" data-title="c"><pre class="shiki shiki-themes one-dark-pro one-dark-pro vp-code" style="background-color:#282c34;--shiki-dark-bg:#282c34;color:#abb2bf;--shiki-dark:#abb2bf;" tabindex="0"><code><span class="line"><span style="color:#C678DD;--shiki-dark:#C678DD;">typedef</span><span style="color:#C678DD;--shiki-dark:#C678DD;"> struct</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;"> intset {</span></span>
<span class="line"><span style="color:#7F848E;--shiki-dark:#7F848E;font-style:italic;--shiki-dark-font-style:italic;">    // Phương thức mã hóa</span></span>
<span class="line"><span style="color:#C678DD;--shiki-dark:#C678DD;">    uint32_t</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;"> encoding;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#7F848E;--shiki-dark:#7F848E;font-style:italic;--shiki-dark-font-style:italic;">    // Số lượng phần tử trong tập hợp</span></span>
<span class="line"><span style="color:#C678DD;--shiki-dark:#C678DD;">    uint32_t</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;"> length;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#7F848E;--shiki-dark:#7F848E;font-style:italic;--shiki-dark-font-style:italic;">    // Mảng lưu trữ các phần tử</span></span>
<span class="line"><span style="color:#C678DD;--shiki-dark:#C678DD;">    int8_t</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;"> contents</span><span style="color:#C678DD;--shiki-dark:#C678DD;">[]</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">} intset;</span></span></code></pre></div><ul><li>Mảng <code>contents</code> là triển khai cơ sở của tập hợp số nguyên: Mỗi phần tử của tập hợp số nguyên là một phần tử mảng (<code>item</code>) của <code>contents</code>, các phần tử được sắp xếp theo thứ tự từ bé đến lớn và không chứa bất kỳ phần tử nào làm lặp lại.</li><li>Thuộc tính <code>length</code> ghi lại số lượng phần tử hiện tại trong tập hợp số nguyên, tức là độ dài của mảng <code>contents</code>.</li><li>Mặc dù cấu trúc <code>intset</code> khai báo thuộc tính <code>contents</code> là một mảng kiểu <code>int8_t</code>, thực tế mảng <code>contents</code> không lưu trữ bất kỳ giá trị kiểu <code>int8_t</code> nào — kiểu thực sự của mảng <code>contents</code> phụ thuộc vào giá trị của thuộc tính <code>encoding</code>: <ul><li>Nếu thuộc tính <code>encoding</code> có giá trị là <code>INTSET_ENC_INT16</code>, thì <code>contents</code> là một mảng kiểu <code>int16_t</code> với mỗi phần tử là một số nguyên kiểu <code>int16_t</code> (giá trị nhỏ nhất là <code>-32,768</code>, lớn nhất là <code>32,767</code>).</li><li>Nếu thuộc tính <code>encoding</code> có giá trị là <code>INTSET_ENC_INT32</code>, thì <code>contents</code> là một mảng kiểu <code>int32_t</code> với mỗi phần tử là một số nguyên kiểu <code>int32_t</code> (giá trị nhỏ nhất là <code>-2,147,483,648</code>, lớn nhất là <code>2,147,483,647</code>).</li><li>Nếu thuộc tính <code>encoding</code> có giá trị là <code>INTSET_ENC_INT64</code>, thì <code>contents</code> là một mảng kiểu <code>int64_t</code> với mỗi phần tử là một số nguyên kiểu <code>int64_t</code> (giá trị nhỏ nhất là <code>-9,223,372,036,854,775,808</code>, lớn nhất là <code>9,223,372,036,854,775,807</code>).</li></ul></li></ul><figure><img src="https://raw.githubusercontent.com/vanhung4499/images/master/snap/20240624221034.png" alt="image.png" tabindex="0" loading="lazy"><figcaption>image.png</figcaption></figure><figure><img src="https://raw.githubusercontent.com/vanhung4499/images/master/snap/20240624221123.png" alt="image.png" tabindex="0" loading="lazy"><figcaption>image.png</figcaption></figure><h3 id="nang-cap-tap-hop-so-nguyen" tabindex="-1"><a class="header-anchor" href="#nang-cap-tap-hop-so-nguyen"><span>Nâng cấp tập hợp số nguyên</span></a></h3><p>Mỗi khi bạn thêm một phần tử mới vào tập hợp số nguyên và kiểu dữ liệu của phần tử mới dài hơn so với tất cả các phần tử hiện có trong tập hợp số nguyên, tập hợp số nguyên sẽ cần phải thực hiện một hoạt động nâng cấp trước khi thêm phần tử mới vào.</p><p>Hoạt động nâng cấp và thêm phần tử mới vào tập hợp số nguyên được thực hiện theo ba bước:</p><ol><li>Mở rộng kích thước của mảng cơ sở của tập hợp số nguyên dựa trên kiểu dữ liệu của phần tử mới.</li><li>Chuyển đổi tất cả các phần tử hiện có trong mảng cơ sở sang kiểu dữ liệu giống nhau với phần tử mới và sắp xếp các phần tử đã được chuyển đổi này theo thứ tự.</li><li>Thêm phần tử mới vào mảng cơ sở.</li></ol><p>Bởi vì mỗi lần thêm phần tử mới vào tập hợp số nguyên có thể dẫn đến việc nâng cấp, và mỗi lần nâng cấp đều phải chuyển đổi lại tất cả các phần tử hiện có trong mảng cơ sở, do đó thời gian phục vụ thêm phần tử mới vào tập hợp số nguyên là O(N).</p><h2 id="danh-sach-nen" tabindex="-1"><a class="header-anchor" href="#danh-sach-nen"><span>Danh sách nén</span></a></h2><h3 id="đinh-nghia-ve-danh-sach-nen" tabindex="-1"><a class="header-anchor" href="#đinh-nghia-ve-danh-sach-nen"><span>Định nghĩa về Danh sách nén</span></a></h3><p><strong>Danh sách nén (ziplist)</strong> là một cấu trúc dữ liệu tuần tự được thiết kế để tiết kiệm bộ nhớ.</p><p><strong>Danh sách nén được sử dụng như một trong các triển khai dưới cùng của khóa danh sách và khóa băm trong Redis</strong>.</p><ul><li>Khi một khóa danh sách chỉ chứa một số lượng ít các mục danh sách và mỗi mục danh sách là giá trị số nguyên nhỏ hoặc chuỗi có độ dài ngắn, Redis sẽ sử dụng danh sách nén làm triển khai dưới cùng của khóa danh sách.</li><li>Khi một khóa băm chỉ chứa một số lượng ít các cặp khóa-giá trị và mỗi cặp khóa-giá trị có khóa và giá trị là số nguyên nhỏ hoặc chuỗi có độ dài ngắn, Redis sẽ sử dụng danh sách nén làm triển khai dưới cùng của khóa băm.</li></ul><p><strong>Danh sách nén có thể chứa nhiều nút, mỗi nút có thể lưu trữ một mảng byte hoặc giá trị số nguyên</strong>.</p><p>Thêm một nút mới vào danh sách nén, hoặc xóa nút từ danh sách nén, có thể gây ra các hoạt động cập nhật chuỗi, nhưng khả năng xảy ra điều này không cao.</p><h3 id="trien-khai-cua-danh-sach-nen" tabindex="-1"><a class="header-anchor" href="#trien-khai-cua-danh-sach-nen"><span>Triển khai của Danh sách nén</span></a></h3><p><strong>Các thành phần chi tiết của danh sách nén</strong></p><table><thead><tr><th style="text-align:left;">Thuộc tính</th><th style="text-align:left;">Kiểu dữ liệu</th><th style="text-align:left;">Độ dài</th><th style="text-align:left;">Mục đích</th></tr></thead><tbody><tr><td style="text-align:left;"><code>zlbytes</code></td><td style="text-align:left;"><code>uint32_t</code></td><td style="text-align:left;"><code>4</code> byte</td><td style="text-align:left;">Ghi lại số byte bộ nhớ chiếm dụng của toàn bộ danh sách nén: được sử dụng trong việc phân bổ lại bộ nhớ của danh sách nén hoặc khi tính vị trí <code>zlend</code>.</td></tr><tr><td style="text-align:left;"><code>zltail</code></td><td style="text-align:left;"><code>uint32_t</code></td><td style="text-align:left;"><code>4</code> byte</td><td style="text-align:left;">Ghi lại khoảng cách từ nút đuôi của danh sách nén đến địa chỉ bắt đầu của danh sách nén: thông qua lệnh lệnh này, chương trình không cần duyệt qua toàn bộ danh sách nén mà vẫn có thể xác định vị trí của nút đuôi.</td></tr><tr><td style="text-align:left;"><code>zllen</code></td><td style="text-align:left;"><code>uint16_t</code></td><td style="text-align:left;"><code>2</code> byte</td><td style="text-align:left;">Ghi lại số lượng nút có trong danh sách nén: khi giá trị thuộc tính này nhỏ hơn <code>UINT16_MAX</code> (<code>65535</code>), nó biểu thị số lượng nút trong danh sách nén; khi giá trị này bằng <code>UINT16_MAX</code>, số lượng thực sự phải được tính toán bằng cách duyệt qua toàn bộ danh sách nén.</td></tr><tr><td style="text-align:left;"><code>entryX</code></td><td style="text-align:left;">Nút danh sách</td><td style="text-align:left;">Không xác định</td><td style="text-align:left;">Các nút đang chứa trong danh sách nén, chiều dài của nút phụ thuộc vào nội dung mà nó lưu trữ.</td></tr><tr><td style="text-align:left;"><code>zlend</code></td><td style="text-align:left;"><code>uint8_t</code></td><td style="text-align:left;"><code>1</code> byte</td><td style="text-align:left;">Giá trị đặc biệt <code>0xFF</code> (255 trong hệ thập phân), được sử dụng để đánh dấu kết thúc của danh sách nén.</td></tr></tbody></table><h2 id="đoi-tuong-object" tabindex="-1"><a class="header-anchor" href="#đoi-tuong-object"><span>Đối tượng (Object)</span></a></h2><p>Redis không sử dụng các cấu trúc dữ liệu trực tiếp để triển khai cơ sở dữ liệu khóa-giá trị, mà dựa trên các cấu trúc dữ liệu này để tạo ra một hệ thống đối tượng. Hệ thống này bao gồm năm loại đối tượng: chuỗi, danh sách, bảng băm (hash), tập hợp và tập hợp có thứ tự, mỗi loại đều sử dụng ít nhất một trong các cấu trúc dữ liệu mà chúng ta đã giới thiệu trước đó.</p><h3 id="gioi-thieu-ve-đoi-tuong" tabindex="-1"><a class="header-anchor" href="#gioi-thieu-ve-đoi-tuong"><span>Giới thiệu về Đối tượng</span></a></h3><p>Mỗi cặp khóa-giá trị trong cơ sở dữ liệu Redis đều là một đối tượng.</p><p>Redis bao gồm năm loại đối tượng: chuỗi (string), danh sách (list), bảng băm (hash), tập hợp (set), và tập hợp có thứ tự (sorted set). Mỗi loại đối tượng này đều có ít nhất hai cách mã hóa khác nhau hoặc nhiều hơn, từ đó tối ưu hóa hiệu suất sử dụng đối tượng trong các tình huống khác nhau.</p><p>Trước khi thực hiện một số lệnh nhất định, máy chủ sẽ kiểm tra xem kiểu của khóa cụ thể có thể thực hiện lệnh đó hay không, và việc kiểm tra kiểu của một khóa là kiểm tra kiểu đối tượng của giá trị khóa.</p><p><strong>Cơ chế thu hồi bộ nhớ dựa trên đếm tham chiếu</strong> - Hệ thống đối tượng của Redis đi kèm với cơ chế tự động thu hồi bộ nhớ dựa trên đếm tham chiếu. Khi một đối tượng không còn được sử dụng nữa, bộ nhớ của đối tượng đó sẽ tự động được giải phóng.</p><p><strong>Cơ chế chia sẻ đối tượng dựa trên đếm tham chiếu</strong> - Redis chia sẻ các đối tượng chuỗi có giá trị từ <code>0</code> đến <code>9999</code>.</p><p><strong>Thời gian chờ rỗng của khóa cơ sở dữ liệu</strong> - Đối tượng ghi lại thời gian cuối cùng mà nó được truy cập, thời gian này có thể được sử dụng để tính toán thời gian chờ rỗng của đối tượng.</p><h3 id="kieu-đoi-tuong-trong-redis" tabindex="-1"><a class="header-anchor" href="#kieu-đoi-tuong-trong-redis"><span>Kiểu đối tượng trong Redis</span></a></h3><p>Trong Redis, đối tượng được sử dụng để đại diện cho các cặp khóa và giá trị trong cơ sở dữ liệu. Mỗi khi tạo một cặp khóa giá trị mới trong Redis, ít nhất hai đối tượng sẽ được tạo ra: một đối tượng để làm khóa (được gọi là đối tượng khóa), và một đối tượng để làm giá trị (được gọi là đối tượng giá trị).</p><p>Mỗi đối tượng trong Redis được biểu diễn bằng một cấu trúc <code>redisObject</code>, trong đó có ba thuộc tính liên quan đến dữ liệu:</p><div class="language-c" data-ext="c" data-title="c"><pre class="shiki shiki-themes one-dark-pro one-dark-pro vp-code" style="background-color:#282c34;--shiki-dark-bg:#282c34;color:#abb2bf;--shiki-dark:#abb2bf;" tabindex="0"><code><span class="line"><span style="color:#C678DD;--shiki-dark:#C678DD;">typedef</span><span style="color:#C678DD;--shiki-dark:#C678DD;"> struct</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;"> redisObject {</span></span>
<span class="line"></span>
<span class="line"><span style="color:#7F848E;--shiki-dark:#7F848E;font-style:italic;--shiki-dark-font-style:italic;">    // Kiểu đối tượng</span></span>
<span class="line"><span style="color:#C678DD;--shiki-dark:#C678DD;">    unsigned</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;"> type:</span><span style="color:#D19A66;--shiki-dark:#D19A66;">4</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#7F848E;--shiki-dark:#7F848E;font-style:italic;--shiki-dark-font-style:italic;">    // Mã hóa</span></span>
<span class="line"><span style="color:#C678DD;--shiki-dark:#C678DD;">    unsigned</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;"> encoding:</span><span style="color:#D19A66;--shiki-dark:#D19A66;">4</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#7F848E;--shiki-dark:#7F848E;font-style:italic;--shiki-dark-font-style:italic;">    // Con trỏ đến cấu trúc dữ liệu thực</span></span>
<span class="line"><span style="color:#C678DD;--shiki-dark:#C678DD;">    void</span><span style="color:#C678DD;--shiki-dark:#C678DD;"> *</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">ptr;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#7F848E;--shiki-dark:#7F848E;font-style:italic;--shiki-dark-font-style:italic;">    // ...</span></span>
<span class="line"></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">} robj;</span></span></code></pre></div><p>Thuộc tính <code>type</code> của đối tượng lưu trữ loại của đối tượng, và Redis có những loại đối tượng sau:</p><table><thead><tr><th style="text-align:left;">Đối tượng</th><th style="text-align:left;">Giá trị của <code>type</code></th><th style="text-align:left;">Kết quả của lệnh TYPE</th></tr></thead><tbody><tr><td style="text-align:left;">Đối tượng chuỗi</td><td style="text-align:left;"><code>REDIS_STRING</code></td><td style="text-align:left;"><code>&quot;string&quot;</code></td></tr><tr><td style="text-align:left;">Đối tượng danh sách</td><td style="text-align:left;"><code>REDIS_LIST</code></td><td style="text-align:left;"><code>&quot;list&quot;</code></td></tr><tr><td style="text-align:left;">Đối tượng băm</td><td style="text-align:left;"><code>REDIS_HASH</code></td><td style="text-align:left;"><code>&quot;hash&quot;</code></td></tr><tr><td style="text-align:left;">Đối tượng tập hợp</td><td style="text-align:left;"><code>REDIS_SET</code></td><td style="text-align:left;"><code>&quot;set&quot;</code></td></tr><tr><td style="text-align:left;">Đối tượng tập có thứ tự</td><td style="text-align:left;"><code>REDIS_ZSET</code></td><td style="text-align:left;"><code>&quot;zset&quot;</code></td></tr></tbody></table><p>Trong Redis, khóa của cặp khóa giá trị luôn là một đối tượng chuỗi, trong khi giá trị có thể là một trong những loại đối tượng như trên: chuỗi, danh sách, băm, tập hợp, hoặc tập có thứ tự.</p><p><strong>Ví dụ</strong>: Sử dụng lệnh <code>TYPE</code> để xác định loại đối tượng của giá trị cho mỗi khóa trong cơ sở dữ liệu Redis:</p><div class="language-shell line-numbers-mode" data-ext="shell" data-title="shell"><pre class="shiki shiki-themes one-dark-pro one-dark-pro vp-code" style="background-color:#282c34;--shiki-dark-bg:#282c34;color:#abb2bf;--shiki-dark:#abb2bf;" tabindex="0"><code><span class="line"><span style="color:#7F848E;--shiki-dark:#7F848E;font-style:italic;--shiki-dark-font-style:italic;"># Khóa là đối tượng chuỗi, giá trị là đối tượng chuỗi</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">&gt; SET msg </span><span style="color:#98C379;--shiki-dark:#98C379;">&quot;Xin chào&quot;</span></span>
<span class="line"><span style="color:#61AFEF;--shiki-dark:#61AFEF;">OK</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">&gt; TYPE msg</span></span>
<span class="line"><span style="color:#61AFEF;--shiki-dark:#61AFEF;">string</span></span>
<span class="line"></span>
<span class="line"><span style="color:#7F848E;--shiki-dark:#7F848E;font-style:italic;--shiki-dark-font-style:italic;"># Khóa là đối tượng chuỗi, giá trị là đối tượng danh sách</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">&gt; RPUSH numbers 1 3 5</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">(</span><span style="color:#61AFEF;--shiki-dark:#61AFEF;">integer</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">) </span><span style="color:#61AFEF;--shiki-dark:#61AFEF;">3</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">&gt; TYPE numbers</span></span>
<span class="line"><span style="color:#61AFEF;--shiki-dark:#61AFEF;">list</span></span>
<span class="line"></span>
<span class="line"><span style="color:#7F848E;--shiki-dark:#7F848E;font-style:italic;--shiki-dark-font-style:italic;"># Khóa là đối tượng chuỗi, giá trị là đối tượng băm</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">&gt; HMSET user id 100 name </span><span style="color:#98C379;--shiki-dark:#98C379;">&quot;Nguyen&quot;</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;"> age 30</span></span>
<span class="line"><span style="color:#61AFEF;--shiki-dark:#61AFEF;">OK</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">&gt; TYPE user</span></span>
<span class="line"><span style="color:#56B6C2;--shiki-dark:#56B6C2;">hash</span></span>
<span class="line"></span>
<span class="line"><span style="color:#7F848E;--shiki-dark:#7F848E;font-style:italic;--shiki-dark-font-style:italic;"># Khóa là đối tượng chuỗi, giá trị là đối tượng tập hợp</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">&gt; SADD cities </span><span style="color:#98C379;--shiki-dark:#98C379;">&quot;Hanoi&quot;</span><span style="color:#98C379;--shiki-dark:#98C379;"> &quot;Ho Chi Minh&quot;</span><span style="color:#98C379;--shiki-dark:#98C379;"> &quot;Danang&quot;</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">(</span><span style="color:#61AFEF;--shiki-dark:#61AFEF;">integer</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">) </span><span style="color:#61AFEF;--shiki-dark:#61AFEF;">3</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">&gt; TYPE cities</span></span>
<span class="line"><span style="color:#56B6C2;--shiki-dark:#56B6C2;">set</span></span>
<span class="line"></span>
<span class="line"><span style="color:#7F848E;--shiki-dark:#7F848E;font-style:italic;--shiki-dark-font-style:italic;"># Khóa là đối tượng chuỗi, giá trị là đối tượng tập có thứ tự</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">&gt; ZADD salary 3000 </span><span style="color:#98C379;--shiki-dark:#98C379;">&quot;Alice&quot;</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;"> 4000 </span><span style="color:#98C379;--shiki-dark:#98C379;">&quot;Bob&quot;</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;"> 2500 </span><span style="color:#98C379;--shiki-dark:#98C379;">&quot;Carol&quot;</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">(</span><span style="color:#61AFEF;--shiki-dark:#61AFEF;">integer</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">) </span><span style="color:#61AFEF;--shiki-dark:#61AFEF;">3</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">&gt; TYPE salary</span></span>
<span class="line"><span style="color:#61AFEF;--shiki-dark:#61AFEF;">zset</span></span></code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="ma-hoa-cua-đoi-tuong" tabindex="-1"><a class="header-anchor" href="#ma-hoa-cua-đoi-tuong"><span>Mã hóa của Đối tượng</span></a></h3><p>Con trỏ <code>ptr</code> của đối tượng trong Redis trỏ đến cấu trúc dữ liệu cụ thể được sử dụng để triển khai đối tượng, và cấu trúc này được quyết định bởi thuộc tính <code>encoding</code> của đối tượng.</p><p>Thuộc tính <code>encoding</code> ghi nhận phương thức mã hóa được sử dụng để triển khai đối tượng, tức là đối tượng sử dụng cấu trúc dữ liệu nào làm nền tảng.</p><p>Redis hỗ trợ các phương thức mã hóa sau:</p><table><thead><tr><th style="text-align:left;">Loại đối tượng</th><th style="text-align:left;">Mã hóa</th><th style="text-align:left;">Đối tượng</th><th>Kết quả của lệnh <strong>OBJECT ENCODING</strong></th></tr></thead><tbody><tr><td style="text-align:left;"><code>REDIS_STRING</code></td><td style="text-align:left;"><code>REDIS_ENCODING_INT</code></td><td style="text-align:left;">Đối tượng chuỗi được triển khai bằng giá trị số nguyên.</td><td>&quot;int&quot;</td></tr><tr><td style="text-align:left;"><code>REDIS_STRING</code></td><td style="text-align:left;"><code>REDIS_ENCODING_EMBSTR</code></td><td style="text-align:left;">Đối tượng chuỗi động đơn giản được triển khai bằng <code>embstr</code>.</td><td>&quot;embstr&quot;</td></tr><tr><td style="text-align:left;"><code>REDIS_STRING</code></td><td style="text-align:left;"><code>REDIS_ENCODING_RAW</code></td><td style="text-align:left;">Đối tượng chuỗi động đơn giản được triển khai bằng chuỗi động.</td><td>&quot;raw&quot;</td></tr><tr><td style="text-align:left;"><code>REDIS_LIST</code></td><td style="text-align:left;"><code>REDIS_ENCODING_ZIPLIST</code></td><td style="text-align:left;">Đối tượng danh sách được triển khai bằng danh sách nén (ziplist).</td><td>&quot;ziplist&quot;</td></tr><tr><td style="text-align:left;"><code>REDIS_LIST</code></td><td style="text-align:left;"><code>REDIS_ENCODING_LINKEDLIST</code></td><td style="text-align:left;">Đối tượng danh sách được triển khai bằng danh sách liên kết (linkedlist).</td><td>&quot;linkedlist&quot;</td></tr><tr><td style="text-align:left;"><code>REDIS_HASH</code></td><td style="text-align:left;"><code>REDIS_ENCODING_ZIPLIST</code></td><td style="text-align:left;">Đối tượng bảng băm được triển khai bằng bảng băm nén (ziplist).</td><td>&quot;ziplist&quot;</td></tr><tr><td style="text-align:left;"><code>REDIS_HASH</code></td><td style="text-align:left;"><code>REDIS_ENCODING_HT</code></td><td style="text-align:left;">Đối tượng bảng băm được triển khai bằng từ điển (hashtable).</td><td>&quot;hashtable&quot;</td></tr><tr><td style="text-align:left;"><code>REDIS_SET</code></td><td style="text-align:left;"><code>REDIS_ENCODING_INTSET</code></td><td style="text-align:left;">Đối tượng tập hợp được triển khai bằng tập hợp số nguyên (intset).</td><td>&quot;intset&quot;</td></tr><tr><td style="text-align:left;"><code>REDIS_SET</code></td><td style="text-align:left;"><code>REDIS_ENCODING_HT</code></td><td style="text-align:left;">Đối tượng tập hợp được triển khai bằng từ điển (hashtable).</td><td>&quot;hashtable&quot;</td></tr><tr><td style="text-align:left;"><code>REDIS_ZSET</code></td><td style="text-align:left;"><code>REDIS_ENCODING_ZIPLIST</code></td><td style="text-align:left;">Đối tượng tập hợp có thứ tự được triển khai bằng danh sách nén (ziplist).</td><td>&quot;ziplist&quot;</td></tr><tr><td style="text-align:left;"><code>REDIS_ZSET</code></td><td style="text-align:left;"><code>REDIS_ENCODING_SKIPLIST</code></td><td style="text-align:left;">Đối tượng tập hợp có thứ tự được triển khai bằng skip list và từ điển (skiplist).</td><td>&quot;skiplist&quot;</td></tr></tbody></table><p><strong>Ví dụ</strong></p><p>Sử dụng lệnh <code>OBJECT ENCODING</code> để xem mã hóa của đối tượng giá trị của các khóa trong cơ sở dữ liệu Redis:</p><div class="language-shell line-numbers-mode" data-ext="shell" data-title="shell"><pre class="shiki shiki-themes one-dark-pro one-dark-pro vp-code" style="background-color:#282c34;--shiki-dark-bg:#282c34;color:#abb2bf;--shiki-dark:#abb2bf;" tabindex="0"><code><span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">&gt; SET msg </span><span style="color:#98C379;--shiki-dark:#98C379;">&quot;Xin chào&quot;</span></span>
<span class="line"><span style="color:#61AFEF;--shiki-dark:#61AFEF;">OK</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">&gt; OBJECT ENCODING msg</span></span>
<span class="line"><span style="color:#61AFEF;--shiki-dark:#61AFEF;">&quot;embstr&quot;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">&gt; SET story </span><span style="color:#98C379;--shiki-dark:#98C379;">&quot;Rất lâu rồi...&quot;</span></span>
<span class="line"><span style="color:#61AFEF;--shiki-dark:#61AFEF;">OK</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">&gt; OBJECT ENCODING story</span></span>
<span class="line"><span style="color:#61AFEF;--shiki-dark:#61AFEF;">&quot;raw&quot;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">&gt; SADD numbers 1 3 5</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">(</span><span style="color:#61AFEF;--shiki-dark:#61AFEF;">integer</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">) </span><span style="color:#61AFEF;--shiki-dark:#61AFEF;">3</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">&gt; OBJECT ENCODING numbers</span></span>
<span class="line"><span style="color:#61AFEF;--shiki-dark:#61AFEF;">&quot;intset&quot;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">&gt; SADD numbers </span><span style="color:#98C379;--shiki-dark:#98C379;">&quot;bảy&quot;</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">(</span><span style="color:#61AFEF;--shiki-dark:#61AFEF;">integer</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">) </span><span style="color:#61AFEF;--shiki-dark:#61AFEF;">1</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">&gt; OBJECT ENCODING numbers</span></span>
<span class="line"><span style="color:#61AFEF;--shiki-dark:#61AFEF;">&quot;hashtable&quot;</span></span></code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="kiem-tra-loai-va-đa-hinh-lenh" tabindex="-1"><a class="header-anchor" href="#kiem-tra-loai-va-đa-hinh-lenh"><span>Kiểm tra loại và đa hình lệnh</span></a></h3><p>Trong Redis, các lệnh có thể được chia thành hai loại chính:</p><ul><li><p><strong>Lệnh đa hình</strong>: Các lệnh này có thể thực hiện trên bất kỳ loại khóa nào, chẳng hạn như <code>DEL</code>, <code>EXPIRE</code>, <code>RENAME</code>, <code>TYPE</code>, <code>OBJECT</code>, vv.</p></li><li><p><strong>Lệnh đặc biệt cho từng loại</strong>: Đây là những lệnh chỉ có thể thực hiện trên một loại cụ thể của khóa, như sau:</p><ul><li>Lệnh liên quan đến khóa chuỗi: <code>SET</code>, <code>GET</code>, <code>APPEND</code>, <code>STRLEN</code>, vv.</li><li>Lệnh liên quan đến khóa băm: <code>HDEL</code>, <code>HSET</code>, <code>HGET</code>, <code>HLEN</code>, vv.</li><li>Lệnh liên quan đến khóa danh sách: <code>RPUSH</code>, <code>LPOP</code>, <code>LINSERT</code>, <code>LLEN</code>, vv.</li><li>Lệnh liên quan đến khóa tập hợp: <code>SADD</code>, <code>SPOP</code>, <code>SINTER</code>, <code>SCARD</code>, vv.</li><li>Lệnh liên quan đến khóa tập hợp có thứ tự: <code>ZADD</code>, <code>ZCARD</code>, <code>ZRANK</code>, <code>ZSCORE</code>, vv.</li></ul></li></ul><p>Trước khi thực hiện một lệnh đặc biệt cho từng loại, Redis sẽ kiểm tra xem loại đối tượng của khóa đầu vào có phù hợp không, và sau đó quyết định liệu nên thực hiện lệnh cụ thể cho khóa đã cho hay không. Việc kiểm tra loại đối tượng trước khi thực hiện lệnh đặc biệt cho từng loại được thực hiện dựa trên thuộc tính <code>type</code> của cấu trúc <code>redisObject</code>:</p><ul><li>Trước khi thực hiện lệnh đặc biệt cho từng loại, máy chủ sẽ kiểm tra xem đối tượng giá trị của khóa đầu vào có phải là loại cần thiết cho lệnh đó hay không.</li><li>Nếu đúng như vậy, máy chủ sẽ thực hiện lệnh cụ thể cho khóa.</li><li>Nếu không, máy chủ sẽ từ chối thực hiện lệnh và trả về lỗi loại không phù hợp cho khách hàng.</li></ul><p>Redis không chỉ dựa vào loại đối tượng để xác định liệu khóa có thể thực hiện lệnh cụ thể cho từng loại hay không, mà còn dựa vào cách mã hóa của đối tượng giá trị để chọn mã lệnh thích hợp để thực hiện lệnh.</p><h3 id="xu-ly-thu-gom-rac" tabindex="-1"><a class="header-anchor" href="#xu-ly-thu-gom-rac"><span>Xử lý thu gom rác</span></a></h3><p>Do ngôn ngữ C không hỗ trợ tự động thu gom rác, Redis đã triển khai một cơ chế thu gom rác dựa trên đếm số tham chiếu.</p><p>Thông tin đếm tham chiếu của mỗi đối tượng được ghi nhận trong cấu trúc <code>redisObject</code> bằng thuộc tính <code>refcount</code>:</p><div class="language-c" data-ext="c" data-title="c"><pre class="shiki shiki-themes one-dark-pro one-dark-pro vp-code" style="background-color:#282c34;--shiki-dark-bg:#282c34;color:#abb2bf;--shiki-dark:#abb2bf;" tabindex="0"><code><span class="line"><span style="color:#C678DD;--shiki-dark:#C678DD;">typedef</span><span style="color:#C678DD;--shiki-dark:#C678DD;"> struct</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;"> redisObject {</span></span>
<span class="line"></span>
<span class="line"><span style="color:#7F848E;--shiki-dark:#7F848E;font-style:italic;--shiki-dark-font-style:italic;">    // ...</span></span>
<span class="line"></span>
<span class="line"><span style="color:#7F848E;--shiki-dark:#7F848E;font-style:italic;--shiki-dark-font-style:italic;">    // Số tham chiếu</span></span>
<span class="line"><span style="color:#C678DD;--shiki-dark:#C678DD;">    int</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;"> refcount;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#7F848E;--shiki-dark:#7F848E;font-style:italic;--shiki-dark-font-style:italic;">    // ...</span></span>
<span class="line"></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">} robj;</span></span></code></pre></div><p>Thông tin đếm tham chiếu của đối tượng sẽ thay đổi theo trạng thái sử dụng của đối tượng:</p><ul><li>Khi tạo một đối tượng mới, giá trị đếm tham chiếu sẽ được khởi tạo là <code>1</code>.</li><li>Khi một đối tượng được sử dụng bởi một chương trình mới, giá trị đếm tham chiếu sẽ được tăng lên.</li><li>Khi một đối tượng không còn được sử dụng bởi bất kỳ chương trình nào nữa, giá trị đếm tham chiếu sẽ giảm đi.</li><li>Khi giá trị đếm tham chiếu của một đối tượng xuống <code>0</code>, bộ nhớ mà đối tượng đó chiếm dụng sẽ được giải phóng.</li></ul><h3 id="chia-se-đoi-tuong" tabindex="-1"><a class="header-anchor" href="#chia-se-đoi-tuong"><span>Chia sẻ đối tượng</span></a></h3><p>Trong Redis, nhiều khóa có thể chia sẻ cùng một đối tượng giá trị bằng cách thực hiện hai bước sau:</p><ol><li><strong>Chỉ định đến đối tượng hiện tại</strong>: Chỉ định con trỏ giá trị của nhiều khóa trong cơ sở dữ liệu đến cùng một đối tượng giá trị hiện tại.</li><li><strong>Tăng số lượng tham chiếu</strong>: Tăng số lượng tham chiếu của đối tượng giá trị được chia sẻ lên một.</li></ol><p>Cơ chế chia sẻ đối tượng giúp tiết kiệm rất nhiều bộ nhớ. Khi nhiều khóa trong cơ sở dữ liệu lưu trữ cùng một giá trị đối tượng, việc sử dụng cơ chế chia sẻ đối tượng có thể giảm đáng kể lượng bộ nhớ sử dụng.</p><p>Redis sẽ tự động chia sẻ các đối tượng chuỗi có giá trị từ <code>0</code> đến <code>9999</code> khi khởi tạo máy chủ.</p><h3 id="thoi-gian-ranh-cua-đoi-tuong" tabindex="-1"><a class="header-anchor" href="#thoi-gian-ranh-cua-đoi-tuong"><span>Thời gian rảnh của đối tượng</span></a></h3><p>Thuộc tính <code>lru</code> của <code>redisObject</code> ghi lại thời điểm lần cuối cùng mà đối tượng được truy cập bởi các lệnh trong chương trình:</p><div class="language-c" data-ext="c" data-title="c"><pre class="shiki shiki-themes one-dark-pro one-dark-pro vp-code" style="background-color:#282c34;--shiki-dark-bg:#282c34;color:#abb2bf;--shiki-dark:#abb2bf;" tabindex="0"><code><span class="line"><span style="color:#C678DD;--shiki-dark:#C678DD;">typedef</span><span style="color:#C678DD;--shiki-dark:#C678DD;"> struct</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;"> redisObject {</span></span>
<span class="line"></span>
<span class="line"><span style="color:#7F848E;--shiki-dark:#7F848E;font-style:italic;--shiki-dark-font-style:italic;">    // ...</span></span>
<span class="line"></span>
<span class="line"><span style="color:#C678DD;--shiki-dark:#C678DD;">    unsigned</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;"> lru:</span><span style="color:#D19A66;--shiki-dark:#D19A66;">22</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#7F848E;--shiki-dark:#7F848E;font-style:italic;--shiki-dark-font-style:italic;">    // ...</span></span>
<span class="line"></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">} robj;</span></span></code></pre></div><p>Lệnh <code>OBJECT IDLETIME</code> có thể in ra thời gian rảnh của một khóa đã cho, thời gian rảnh này được tính bằng cách lấy thời gian hiện tại trừ đi thời điểm <code>lru</code> của đối tượng giá trị của khóa:</p><div class="language- line-numbers-mode" data-ext="" data-title=""><pre class="shiki shiki-themes one-dark-pro one-dark-pro vp-code" style="background-color:#282c34;--shiki-dark-bg:#282c34;color:#abb2bf;--shiki-dark:#abb2bf;" tabindex="0"><code><span class="line"><span>&gt; SET msg &quot;hello world&quot;</span></span>
<span class="line"><span>OK</span></span>
<span class="line"><span></span></span>
<span class="line"><span># Chờ một khoảng thời gian ngắn</span></span>
<span class="line"><span>&gt; OBJECT IDLETIME msg</span></span>
<span class="line"><span>(integer) 20</span></span>
<span class="line"><span></span></span>
<span class="line"><span># Chờ lâu hơn</span></span>
<span class="line"><span>&gt; OBJECT IDLETIME msg</span></span>
<span class="line"><span>(integer) 180</span></span>
<span class="line"><span></span></span>
<span class="line"><span># Truy cập giá trị của khóa msg</span></span>
<span class="line"><span>&gt; GET msg</span></span>
<span class="line"><span>&quot;hello world&quot;</span></span>
<span class="line"><span></span></span>
<span class="line"><span># Khóa hiện đang hoạt động, thời gian rảnh là 0</span></span>
<span class="line"><span>&gt; OBJECT IDLETIME msg</span></span>
<span class="line"><span>(integer) 0</span></span></code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>Lưu ý</p><p>Lệnh OBJECT IDLETIME có cách triển khai đặc biệt, lệnh này không thay đổi thuộc tính <code>lru</code> của đối tượng giá trị khi truy cập.</p></blockquote><p>Ngoài việc có thể in ra bởi lệnh OBJECT IDLETIME, thời gian rảnh của một khóa cũng có tác dụng khác: nếu máy chủ Redis bật tùy chọn <code>maxmemory</code> và sử dụng thuật toán <code>volatile-lru</code> hoặc <code>allkeys-lru</code> để thu hồi bộ nhớ, khi lượng bộ nhớ máy chủ vượt quá giá trị tối đa được thiết lập bởi <code>maxmemory</code>, các khóa có thời gian rảnh cao sẽ được ưu tiên giải phóng bởi máy chủ để giảm bộ nhớ.</p>`,173),e=[c];function l(h,o){return i(),s("div",null,e)}const r=n(a,[["render",l],["__file","data-structures.html.vue"]]),p=JSON.parse('{"path":"/database/redis/data-structures.html","title":"Redis Data Structures","lang":"en-US","frontmatter":{"title":"Redis Data Structures","tags":["redis","nosql"],"categories":["redis"],"icon":"devicon:redis","order":5,"description":"Redis Data Structures SDS Giới thiệu về SDS SDS là viết tắt của Simple Dynamic String, tức là Chuỗi Động Đơn Giản. Redis đã tối ưu SDS để thay thế chuỗi C trong việc biểu diễn n...","head":[["meta",{"property":"og:url","content":"https://vanhung4499.github.io/database/redis/data-structures.html"}],["meta",{"property":"og:site_name","content":"VanHung4499"}],["meta",{"property":"og:title","content":"Redis Data Structures"}],["meta",{"property":"og:description","content":"Redis Data Structures SDS Giới thiệu về SDS SDS là viết tắt của Simple Dynamic String, tức là Chuỗi Động Đơn Giản. Redis đã tối ưu SDS để thay thế chuỗi C trong việc biểu diễn n..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://raw.githubusercontent.com/vanhung4499/images/master/snap/20240624213746.png"}],["meta",{"property":"og:locale","content":"en-US"}],["meta",{"property":"og:updated_time","content":"2024-06-28T15:54:38.000Z"}],["meta",{"property":"article:author","content":"Hung Nguyen"}],["meta",{"property":"article:tag","content":"redis"}],["meta",{"property":"article:tag","content":"nosql"}],["meta",{"property":"article:modified_time","content":"2024-06-28T15:54:38.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Redis Data Structures\\",\\"image\\":[\\"https://raw.githubusercontent.com/vanhung4499/images/master/snap/20240624213746.png\\",\\"https://raw.githubusercontent.com/vanhung4499/images/master/snap/20240624201754.png\\",\\"https://raw.githubusercontent.com/vanhung4499/images/master/snap/20240624201852.png\\",\\"https://raw.githubusercontent.com/vanhung4499/images/master/snap/20240624215302.png\\",\\"https://raw.githubusercontent.com/vanhung4499/images/master/snap/20240624215319.png\\",\\"https://raw.githubusercontent.com/vanhung4499/images/master/snap/20240624215336.png\\",\\"https://raw.githubusercontent.com/vanhung4499/images/master/snap/20240624215524.png\\",\\"https://raw.githubusercontent.com/vanhung4499/images/master/snap/20240624215901.png\\",\\"https://raw.githubusercontent.com/vanhung4499/images/master/snap/20240624215909.png\\",\\"https://raw.githubusercontent.com/vanhung4499/images/master/snap/20240624215917.png\\",\\"https://raw.githubusercontent.com/vanhung4499/images/master/snap/20240624215924.png\\",\\"https://raw.githubusercontent.com/vanhung4499/images/master/snap/20240624215931.png\\",\\"https://raw.githubusercontent.com/vanhung4499/images/master/snap/20240624215938.png\\",\\"https://raw.githubusercontent.com/vanhung4499/images/master/snap/20240624220250.png\\",\\"https://raw.githubusercontent.com/vanhung4499/images/master/snap/20240624221034.png\\",\\"https://raw.githubusercontent.com/vanhung4499/images/master/snap/20240624221123.png\\"],\\"dateModified\\":\\"2024-06-28T15:54:38.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Hung Nguyen\\",\\"url\\":\\"https://vanhung4499.github.io\\"}]}"]]},"headers":[{"level":2,"title":"SDS","slug":"sds","link":"#sds","children":[{"level":3,"title":"Giới thiệu về SDS","slug":"gioi-thieu-ve-sds","link":"#gioi-thieu-ve-sds","children":[]},{"level":3,"title":"Triển khai SDS","slug":"trien-khai-sds","link":"#trien-khai-sds","children":[]}]},{"level":2,"title":"Tính năng của SDS","slug":"tinh-nang-cua-sds","link":"#tinh-nang-cua-sds","children":[{"level":3,"title":"Lấy độ dài chuỗi với độ phức tạp hằng số","slug":"lay-đo-dai-chuoi-voi-đo-phuc-tap-hang-so","link":"#lay-đo-dai-chuoi-voi-đo-phuc-tap-hang-so","children":[]},{"level":3,"title":"Ngăn chặn tràn bộ đệm","slug":"ngan-chan-tran-bo-đem","link":"#ngan-chan-tran-bo-đem","children":[]},{"level":3,"title":"Giảm số lần phân bổ lại bộ nhớ khi thay đổi độ dài chuỗi","slug":"giam-so-lan-phan-bo-lai-bo-nho-khi-thay-đoi-đo-dai-chuoi","link":"#giam-so-lan-phan-bo-lai-bo-nho-khi-thay-đoi-đo-dai-chuoi","children":[]},{"level":3,"title":"An toàn cho dữ liệu nhị phân","slug":"an-toan-cho-du-lieu-nhi-phan","link":"#an-toan-cho-du-lieu-nhi-phan","children":[]},{"level":3,"title":"Tương thích với một số hàm chuỗi C","slug":"tuong-thich-voi-mot-so-ham-chuoi-c","link":"#tuong-thich-voi-mot-so-ham-chuoi-c","children":[]}]},{"level":2,"title":"Danh sách liên kết","slug":"danh-sach-lien-ket","link":"#danh-sach-lien-ket","children":[{"level":3,"title":"Giới thiệu về Danh sách liên kết","slug":"gioi-thieu-ve-danh-sach-lien-ket","link":"#gioi-thieu-ve-danh-sach-lien-ket","children":[]},{"level":3,"title":"Triển khai của Danh sách liên kết","slug":"trien-khai-cua-danh-sach-lien-ket","link":"#trien-khai-cua-danh-sach-lien-ket","children":[]}]},{"level":2,"title":"Từ điển","slug":"tu-đien","link":"#tu-đien","children":[{"level":3,"title":"Giới thiệu về Từ điển","slug":"gioi-thieu-ve-tu-đien","link":"#gioi-thieu-ve-tu-đien","children":[]},{"level":3,"title":"Triển khai của Từ điển","slug":"trien-khai-cua-tu-đien","link":"#trien-khai-cua-tu-đien","children":[]},{"level":3,"title":"Thuật toán băm","slug":"thuat-toan-bam","link":"#thuat-toan-bam","children":[]},{"level":3,"title":"Xử lý va chạm","slug":"xu-ly-va-cham","link":"#xu-ly-va-cham","children":[]},{"level":3,"title":"rehash","slug":"rehash","link":"#rehash","children":[]}]},{"level":2,"title":"Skip List","slug":"skip-list","link":"#skip-list","children":[{"level":3,"title":"Giới thiệu về Skip List","slug":"gioi-thieu-ve-skip-list","link":"#gioi-thieu-ve-skip-list","children":[]},{"level":3,"title":"Triển khai Skip List","slug":"trien-khai-skip-list","link":"#trien-khai-skip-list","children":[]}]},{"level":2,"title":"Tập hợp số nguyên","slug":"tap-hop-so-nguyen","link":"#tap-hop-so-nguyen","children":[{"level":3,"title":"Giới thiệu về tập hợp số nguyên","slug":"gioi-thieu-ve-tap-hop-so-nguyen","link":"#gioi-thieu-ve-tap-hop-so-nguyen","children":[]},{"level":3,"title":"Triển khai tập hợp số nguyên","slug":"trien-khai-tap-hop-so-nguyen","link":"#trien-khai-tap-hop-so-nguyen","children":[]},{"level":3,"title":"Nâng cấp tập hợp số nguyên","slug":"nang-cap-tap-hop-so-nguyen","link":"#nang-cap-tap-hop-so-nguyen","children":[]}]},{"level":2,"title":"Danh sách nén","slug":"danh-sach-nen","link":"#danh-sach-nen","children":[{"level":3,"title":"Định nghĩa về Danh sách nén","slug":"đinh-nghia-ve-danh-sach-nen","link":"#đinh-nghia-ve-danh-sach-nen","children":[]},{"level":3,"title":"Triển khai của Danh sách nén","slug":"trien-khai-cua-danh-sach-nen","link":"#trien-khai-cua-danh-sach-nen","children":[]}]},{"level":2,"title":"Đối tượng (Object)","slug":"đoi-tuong-object","link":"#đoi-tuong-object","children":[{"level":3,"title":"Giới thiệu về Đối tượng","slug":"gioi-thieu-ve-đoi-tuong","link":"#gioi-thieu-ve-đoi-tuong","children":[]},{"level":3,"title":"Kiểu đối tượng trong Redis","slug":"kieu-đoi-tuong-trong-redis","link":"#kieu-đoi-tuong-trong-redis","children":[]},{"level":3,"title":"Mã hóa của Đối tượng","slug":"ma-hoa-cua-đoi-tuong","link":"#ma-hoa-cua-đoi-tuong","children":[]},{"level":3,"title":"Kiểm tra loại và đa hình lệnh","slug":"kiem-tra-loai-va-đa-hinh-lenh","link":"#kiem-tra-loai-va-đa-hinh-lenh","children":[]},{"level":3,"title":"Xử lý thu gom rác","slug":"xu-ly-thu-gom-rac","link":"#xu-ly-thu-gom-rac","children":[]},{"level":3,"title":"Chia sẻ đối tượng","slug":"chia-se-đoi-tuong","link":"#chia-se-đoi-tuong","children":[]},{"level":3,"title":"Thời gian rảnh của đối tượng","slug":"thoi-gian-ranh-cua-đoi-tuong","link":"#thoi-gian-ranh-cua-đoi-tuong","children":[]}]}],"git":{"createdTime":1719590078000,"updatedTime":1719590078000,"contributors":[{"name":"Hung Nguyen Van","email":"vanhung4499@gmail.com","commits":1}]},"readingTime":{"minutes":31.67,"words":9500},"filePathRelative":"database/redis/data-structures.md","localizedDate":"June 28, 2024","excerpt":"\\n<h2>SDS</h2>\\n<h3>Giới thiệu về SDS</h3>\\n<p>SDS là viết tắt của Simple Dynamic String, tức là <strong>Chuỗi Động Đơn Giản</strong>. Redis đã tối ưu SDS để thay thế chuỗi C trong việc biểu diễn nội dung chuỗi. Ngoài ra, SDS còn được Redis sử dụng như là vùng đệm (buffer), chẳng hạn như vùng đệm AOF trong mô đun AOF và vùng đệm đầu vào trong trạng thái của khách hàng.</p>","autoDesc":true}');export{r as comp,p as data};
