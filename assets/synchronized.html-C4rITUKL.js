import{_ as g,g as l,o as k,c as o,e as i,h,f as a,w as s,a as c}from"./app-5QVbWi7Z.js";const r={};function e(p,n){const t=l("RouteLink");return k(),o("div",null,[n[25]||(n[25]=i("h1",{id:"bon-trang-thai-cua-synchronized",tabindex:"-1"},[i("a",{class:"header-anchor",href:"#bon-trang-thai-cua-synchronized"},[i("span",null,"Bốn trạng thái của synchronized")])],-1)),n[26]||(n[26]=i("p",null,[h("Trong bài trước, chúng ta đã tìm hiểu về cách sử dụng cơ bản của từ khóa synchronized. Nó có thể được sử dụng để đồng bộ hóa phương thức và khối mã. Vậy "),i("code",null,"synchronized"),h(" thực sự khóa cái gì? Khi phiên bản JDK nâng cấp, "),i("code",null,"synchronized"),h(' đã có những thay đổi gì? Liệu có đúng không rằng "hiệu suất của synchronized rất kém"?')],-1)),n[27]||(n[27]=i("p",null,"Tôi nghĩ đây là câu hỏi mà nhiều bạn quan tâm.",-1)),n[28]||(n[28]=i("p",null,[h("Điều đầu tiên cần làm rõ là: "),i("strong",null,"Khóa trong Java đa luồng đều dựa trên đối tượng"),h(", mỗi đối tượng trong Java đều có thể làm khóa.")],-1)),i("p",null,[n[1]||(n[1]=h("Một điểm nữa cần chú ý là, cái mà chúng ta thường nghe là ")),n[2]||(n[2]=i("strong",null,"khóa lớp",-1)),n[3]||(n[3]=h(" thực chất cũng là khóa đối tượng, như đã nói ở ")),a(t,{to:"/programming/java/Concurency/synchronized-1.html"},{default:s(()=>n[0]||(n[0]=[h("bài trước")])),_:1}),n[4]||(n[4]=h(", chắc hẳn nhiều bạn đã nhận ra."))]),n[29]||(n[29]=c('<p>Hãy nói thêm một chút về điều này. Đối tượng <code>Class</code> là một đối tượng đặc biệt trong Java, đại diện cho các lớp và giao diện trong chương trình. Mỗi kiểu trong Java (bao gồm lớp, giao diện, mảng và kiểu nguyên thủy) đều có một đối tượng <code>Class</code> duy nhất trong JVM tương ứng với nó. Đối tượng <code>Class</code> này được tạo ra khi JVM tải lớp, và quá trình này được thực hiện tự động bởi JVM.</p><p>Đối tượng <code>Class</code> chứa nhiều thông tin liên quan đến lớp, chẳng hạn như tên lớp, lớp cha, các giao diện mà lớp thực hiện, các phương thức, trường của lớp,... Những thông tin này thường được gọi là &quot;metadata&quot; (siêu dữ liệu).</p><p>Chúng ta có thể sử dụng đối tượng <code>Class</code> để lấy siêu dữ liệu của lớp, thậm chí có thể tạo động các phiên bản của lớp, gọi phương thức của lớp, truy cập vào các trường của lớp, v.v. Đây chính là cơ chế phản xạ của Java (Reflection).</p><p>Vì vậy, cái gọi là khóa lớp thực chất là khóa đối tượng <code>Class</code>.</p><h2 id="cach-su-dung-co-ban-cua-khoa" tabindex="-1"><a class="header-anchor" href="#cach-su-dung-co-ban-cua-khoa"><span>Cách sử dụng cơ bản của khóa</span></a></h2><p>Từ khóa <code>synchronized</code> có nghĩa là &quot;đồng bộ hóa&quot;.</p>',6)),i("p",null,[n[6]||(n[6]=h("Chúng ta thường sử dụng từ khóa ")),n[7]||(n[7]=i("code",null,"synchronized",-1)),n[8]||(n[8]=h(" để khóa một đoạn mã hoặc một phương thức. Như đã đề cập trong ")),a(t,{to:"/programming/java/Concurency/synchronized-1.html"},{default:s(()=>n[5]||(n[5]=[h("bài trước")])),_:1}),n[9]||(n[9]=h(", chúng ta hãy điểm qua nhanh lại, vì ")),n[10]||(n[10]=i("code",null,"synchronized",-1)),n[11]||(n[11]=h(" rất quan trọng và thường được hỏi trong các cuộc phỏng vấn cũng như khi lập trình. Nó thường có ba hình thức sau:"))]),n[30]||(n[30]=c(`<div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#abb2bf;--shiki-dark:#abb2bf;--shiki-light-bg:#282c34;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-dark-pro one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#7F848E;--shiki-dark:#7F848E;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;">// Từ khóa trong phương thức instance, khóa là đối tượng hiện tại</span></span>
<span class="line"><span style="--shiki-light:#C678DD;--shiki-dark:#C678DD;">public</span><span style="--shiki-light:#C678DD;--shiki-dark:#C678DD;"> synchronized</span><span style="--shiki-light:#C678DD;--shiki-dark:#C678DD;"> void</span><span style="--shiki-light:#61AFEF;--shiki-dark:#61AFEF;"> instanceLock</span><span style="--shiki-light:#E06C75;--shiki-dark:#E06C75;">() {</span></span>
<span class="line"><span style="--shiki-light:#7F848E;--shiki-dark:#7F848E;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;">    // code</span></span>
<span class="line"><span style="--shiki-light:#E06C75;--shiki-dark:#E06C75;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#7F848E;--shiki-dark:#7F848E;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;">// Từ khóa trong phương thức static, khóa là đối tượng Class hiện tại</span></span>
<span class="line"><span style="--shiki-light:#C678DD;--shiki-dark:#C678DD;">public</span><span style="--shiki-light:#C678DD;--shiki-dark:#C678DD;"> static</span><span style="--shiki-light:#C678DD;--shiki-dark:#C678DD;"> synchronized</span><span style="--shiki-light:#C678DD;--shiki-dark:#C678DD;"> void</span><span style="--shiki-light:#61AFEF;--shiki-dark:#61AFEF;"> classLock</span><span style="--shiki-light:#E06C75;--shiki-dark:#E06C75;">() {</span></span>
<span class="line"><span style="--shiki-light:#7F848E;--shiki-dark:#7F848E;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;">    // code</span></span>
<span class="line"><span style="--shiki-light:#E06C75;--shiki-dark:#E06C75;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#7F848E;--shiki-dark:#7F848E;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;">// Từ khóa trong khối mã, khóa là đối tượng bên trong dấu ngoặc</span></span>
<span class="line"><span style="--shiki-light:#C678DD;--shiki-dark:#C678DD;">public</span><span style="--shiki-light:#C678DD;--shiki-dark:#C678DD;"> void</span><span style="--shiki-light:#61AFEF;--shiki-dark:#61AFEF;"> blockLock</span><span style="--shiki-light:#E06C75;--shiki-dark:#E06C75;">() {</span></span>
<span class="line"><span style="--shiki-light:#E5C07B;--shiki-dark:#E5C07B;">    Object</span><span style="--shiki-light:#E06C75;--shiki-dark:#E06C75;"> o </span><span style="--shiki-light:#56B6C2;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#C678DD;--shiki-dark:#C678DD;"> new</span><span style="--shiki-light:#61AFEF;--shiki-dark:#61AFEF;"> Object</span><span style="--shiki-light:#E06C75;--shiki-dark:#E06C75;">()</span><span style="--shiki-light:#ABB2BF;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#C678DD;--shiki-dark:#C678DD;">    synchronized</span><span style="--shiki-light:#E06C75;--shiki-dark:#E06C75;"> (o) {</span></span>
<span class="line"><span style="--shiki-light:#7F848E;--shiki-dark:#7F848E;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;">        // code</span></span>
<span class="line"><span style="--shiki-light:#E06C75;--shiki-dark:#E06C75;">    }</span></span>
<span class="line"><span style="--shiki-light:#E06C75;--shiki-dark:#E06C75;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Ở đây, khái niệm critical section được giới thiệu. critical section là một khu vực mã mà chỉ một luồng có thể thực thi tại một thời điểm. Trong các ví dụ trên, nếu từ khóa <code>synchronized</code> được sử dụng trong phương thức, thì critical section chính là toàn bộ phương thức. Nếu nó là một khối mã <code>synchronized</code>, thì critical section chỉ là khu vực mã bên trong khối mã đó.</p><p>Nhìn vào các ví dụ trên, chúng ta có thể thấy hai cách viết sau thực chất có tác dụng tương đương:</p><div class="language-java" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#abb2bf;--shiki-dark:#abb2bf;--shiki-light-bg:#282c34;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-dark-pro one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#7F848E;--shiki-dark:#7F848E;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;">// Từ khóa trong phương thức instance, khóa là đối tượng hiện tại</span></span>
<span class="line"><span style="--shiki-light:#C678DD;--shiki-dark:#C678DD;">public</span><span style="--shiki-light:#C678DD;--shiki-dark:#C678DD;"> synchronized</span><span style="--shiki-light:#C678DD;--shiki-dark:#C678DD;"> void</span><span style="--shiki-light:#61AFEF;--shiki-dark:#61AFEF;"> instanceLock</span><span style="--shiki-light:#E06C75;--shiki-dark:#E06C75;">() {</span></span>
<span class="line"><span style="--shiki-light:#7F848E;--shiki-dark:#7F848E;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;">    // code</span></span>
<span class="line"><span style="--shiki-light:#E06C75;--shiki-dark:#E06C75;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#7F848E;--shiki-dark:#7F848E;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;">// Từ khóa trong khối mã, khóa là đối tượng hiện tại</span></span>
<span class="line"><span style="--shiki-light:#C678DD;--shiki-dark:#C678DD;">public</span><span style="--shiki-light:#C678DD;--shiki-dark:#C678DD;"> void</span><span style="--shiki-light:#61AFEF;--shiki-dark:#61AFEF;"> blockLock</span><span style="--shiki-light:#E06C75;--shiki-dark:#E06C75;">() {</span></span>
<span class="line"><span style="--shiki-light:#C678DD;--shiki-dark:#C678DD;">    synchronized</span><span style="--shiki-light:#E06C75;--shiki-dark:#E06C75;"> (</span><span style="--shiki-light:#E5C07B;--shiki-dark:#E5C07B;">this</span><span style="--shiki-light:#E06C75;--shiki-dark:#E06C75;">) {</span></span>
<span class="line"><span style="--shiki-light:#7F848E;--shiki-dark:#7F848E;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;">        // code</span></span>
<span class="line"><span style="--shiki-light:#E06C75;--shiki-dark:#E06C75;">    }</span></span>
<span class="line"><span style="--shiki-light:#E06C75;--shiki-dark:#E06C75;">}</span></span></code></pre></div><p>Tương tự, hai phương thức dưới đây cũng có tác dụng tương đương:</p><div class="language-java" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#abb2bf;--shiki-dark:#abb2bf;--shiki-light-bg:#282c34;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-dark-pro one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#7F848E;--shiki-dark:#7F848E;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;">// Từ khóa trong phương thức static, khóa là đối tượng Class hiện tại</span></span>
<span class="line"><span style="--shiki-light:#C678DD;--shiki-dark:#C678DD;">public</span><span style="--shiki-light:#C678DD;--shiki-dark:#C678DD;"> static</span><span style="--shiki-light:#C678DD;--shiki-dark:#C678DD;"> synchronized</span><span style="--shiki-light:#C678DD;--shiki-dark:#C678DD;"> void</span><span style="--shiki-light:#61AFEF;--shiki-dark:#61AFEF;"> classLock</span><span style="--shiki-light:#E06C75;--shiki-dark:#E06C75;">() {</span></span>
<span class="line"><span style="--shiki-light:#7F848E;--shiki-dark:#7F848E;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;">    // code</span></span>
<span class="line"><span style="--shiki-light:#E06C75;--shiki-dark:#E06C75;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#7F848E;--shiki-dark:#7F848E;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;">// Từ khóa trong khối mã, khóa là đối tượng Class hiện tại</span></span>
<span class="line"><span style="--shiki-light:#C678DD;--shiki-dark:#C678DD;">public</span><span style="--shiki-light:#C678DD;--shiki-dark:#C678DD;"> void</span><span style="--shiki-light:#61AFEF;--shiki-dark:#61AFEF;"> blockLock</span><span style="--shiki-light:#E06C75;--shiki-dark:#E06C75;">() {</span></span>
<span class="line"><span style="--shiki-light:#C678DD;--shiki-dark:#C678DD;">    synchronized</span><span style="--shiki-light:#E06C75;--shiki-dark:#E06C75;"> (</span><span style="--shiki-light:#E5C07B;--shiki-dark:#E5C07B;">this</span><span style="--shiki-light:#ABB2BF;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#61AFEF;--shiki-dark:#61AFEF;">getClass</span><span style="--shiki-light:#ABB2BF;--shiki-dark:#ABB2BF;">()</span><span style="--shiki-light:#E06C75;--shiki-dark:#E06C75;">) {</span></span>
<span class="line"><span style="--shiki-light:#7F848E;--shiki-dark:#7F848E;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;">        // code</span></span>
<span class="line"><span style="--shiki-light:#E06C75;--shiki-dark:#E06C75;">    }</span></span>
<span class="line"><span style="--shiki-light:#E06C75;--shiki-dark:#E06C75;">}</span></span></code></pre></div><h2 id="bon-trang-thai-cua-khoa-va-ha-cap-khoa" tabindex="-1"><a class="header-anchor" href="#bon-trang-thai-cua-khoa-va-ha-cap-khoa"><span>Bốn trạng thái của khóa và hạ cấp khóa</span></a></h2><p>Trước JDK 1.6, tất cả các khóa đều là &quot;khóa nặng&quot; vì sử dụng khóa của hệ điều hành, khi một luồng giữ khóa thì các luồng khác cố gắng truy cập vào khối <code>synchronized</code> sẽ bị chặn cho đến khi khóa được giải phóng. Điều này liên quan đến việc chuyển đổi ngữ cảnh luồng và chuyển đổi giữa người dùng và chế độ lõi của hệ điều hành, dẫn đến hiệu suất thấp.</p><p>Đây là lý do tại sao nhiều lập trình viên nghĩ rằng hiệu suất của <code>synchronized</code> rất kém.</p><p>Để giảm thiểu chi phí hiệu suất khi lấy và giải phóng khóa, JDK 1.6 đã giới thiệu khái niệm &quot;khóa thiên vị&quot; và &quot;khóa nhẹ&quot;, làm cho <code>synchronized</code> có một bước cải tiến lớn về hiệu suất. Kể từ JDK 1.6 trở đi, một đối tượng thực sự có bốn trạng thái khóa, xếp theo thứ tự từ thấp đến cao như sau:</p><ol><li>Trạng thái không khóa</li><li>Trạng thái khóa thiên vị</li><li>Trạng thái khóa nhẹ</li><li>Trạng thái khóa nặng</li></ol><p>Không khóa nghĩa là không có bất kỳ khóa nào trên tài nguyên, bất kỳ luồng nào cũng có thể cố gắng sửa đổi nó, điều này rất dễ hiểu.</p><p>Các loại khóa này có thể nâng cấp dần dần tùy theo mức độ cạnh tranh, quá trình nâng cấp khóa rất dễ xảy ra, nhưng việc hạ cấp khóa lại ít xảy ra hơn. Hạ cấp khóa thường xảy ra trong quá trình <a href="../jvm/gc">Stop The World</a> (một khái niệm quan trọng trong thu gom rác của Java, chúng ta sẽ đề cập sâu hơn trong phần JVM), khi JVM vào điểm an toàn và kiểm tra xem có khóa nào không được sử dụng để thực hiện hạ cấp.</p><p>Về hạ cấp khóa, có một điều cần làm rõ:</p><p>Khác với phần lớn các bài viết cho rằng không thể hạ cấp khóa, thực tế là HotSpot JVM hỗ trợ hạ cấp khóa. Trong <a href="https://openjdk.org/jeps/8183909" target="_blank" rel="noopener noreferrer">bài đăng này</a>, có một luận điểm quan trọng mà bài viết đưa ra, do tác giả nổi tiếng R-Giải trình bày.</p><blockquote><p>In its current implementation, monitor deflation is performed during every STW pause, while all Java threads are waiting at a safepoint. We have seen safepoint cleanup stalls up to 200ms on monitor-heavy-applications。</p></blockquote><p>Điều này có nghĩa rằng hạ cấp khóa nặng xảy ra trong giai đoạn STW, và chỉ áp dụng cho các đối tượng chỉ có thể được truy cập bởi VMThread mà không có JavaThread nào khác truy cập.</p><p>So sánh ưu nhược điểm của các loại khóa:</p><table><thead><tr><th>Loại khóa</th><th>Ưu điểm</th><th>Nhược điểm</th><th>Tình huống sử dụng</th></tr></thead><tbody><tr><td>Khóa thiên vị</td><td>Việc lấy và thả khóa không tốn nhiều tài nguyên, gần như không khác so với việc thực hiện phương thức không đồng bộ.</td><td>Nếu có sự cạnh tranh giữa các luồng, sẽ có chi phí hủy bỏ khóa.</td><td>Dùng trong tình huống chỉ có một luồng truy cập khối đồng bộ.</td></tr><tr><td>Khóa nhẹ</td><td>Các luồng cạnh tranh không bị chặn, giúp cải thiện tốc độ phản hồi của chương trình.</td><td>Nếu không lấy được khóa, các luồng quay vòng sẽ tiêu tốn CPU.</td><td>Ưu tiên tốc độ phản hồi. Khối đồng bộ thực thi nhanh.</td></tr><tr><td>Khóa nặng</td><td>Luồng cạnh tranh không quay vòng, không tiêu tốn CPU.</td><td>Các luồng bị chặn, tốc độ phản hồi chậm.</td><td>Ưu tiên thông lượng. Khối đồng bộ thực thi lâu dài.</td></tr></tbody></table><h2 id="khoa-cua-đoi-tuong-đuoc-luu-o-đau" tabindex="-1"><a class="header-anchor" href="#khoa-cua-đoi-tuong-đuoc-luu-o-đau"><span>Khóa của đối tượng được lưu ở đâu?</span></a></h2><p>Như đã nói ở phần trước, khóa trong Java đều dựa trên đối tượng.</p><p>Đầu tiên, hãy xem khóa của một đối tượng được lưu trữ ở đâu.</p><p>Mỗi đối tượng Java đều có một &quot;tiêu đề đối tượng&quot; (object header). Nếu là loại không phải mảng, đầu đối tượng chiếm 2 word; nếu là mảng, nó chiếm 3 word. Trong bộ xử lý 32-bit, một word là 32 bit; trong JVM 64-bit, một word là 64 bit. Nội dung của đầu đối tượng như sau:</p><table><thead><tr><th>Chiều dài</th><th>Nội dung</th><th>Mô tả</th></tr></thead><tbody><tr><td>32/64 bit</td><td>Mark Word</td><td>Lưu trữ hashCode của đối tượng hoặc thông tin về khóa</td></tr><tr><td>32/64 bit</td><td>Class Metadata Address</td><td>Con trỏ đến dữ liệu loại của đối tượng</td></tr><tr><td>32/64 bit</td><td>Array length</td><td>Độ dài của mảng (nếu là mảng)</td></tr></tbody></table><p>Hãy cùng xem định dạng của <code>Mark Word</code>:</p><table><thead><tr><th>Trạng thái khóa</th><th>29 bit hoặc 61 bit</th><th>1 bit Khóa thiên vị?</th><th>2 bit Trạng thái khóa</th></tr></thead><tbody><tr><td>Không khóa</td><td></td><td>0</td><td>01</td></tr><tr><td>Khóa thiên vị</td><td>ID của luồng</td><td>1</td><td>01</td></tr><tr><td>Khóa nhẹ</td><td>Con trỏ tới bản ghi khóa trong ngăn xếp</td><td>Bit này không dùng để đánh dấu khóa thiên vị</td><td>00</td></tr><tr><td>Khóa nặng</td><td>Con trỏ tới khóa nặng</td><td>Bit này không dùng để đánh dấu khóa thiên vị</td><td>10</td></tr><tr><td>Đánh dấu GC</td><td></td><td>Bit này không dùng để đánh dấu khóa thiên vị</td><td>11</td></tr></tbody></table><p>Khi trạng thái của đối tượng là khóa thiên vị, <code>Mark Word</code> lưu trữ ID của luồng đang sở hữu khóa; khi là khóa nhẹ, <code>Mark Word</code> lưu trữ con trỏ tới <code>Lock Record</code> trong ngăn xếp của luồng; khi là khóa nặng, <code>Mark Word</code> là con trỏ tới đối tượng monitor (giám sát) trong bộ nhớ heap.</p><blockquote><p>Trong Java, &quot;monitor&quot; là một công cụ đồng bộ hóa được sử dụng để bảo vệ dữ liệu chia sẻ, tránh việc truy cập không đồng bộ của nhiều luồng gây ra sự không nhất quán trong dữ liệu. Mỗi đối tượng trong Java đều có một monitor tích hợp sẵn.</p></blockquote>`,28)),i("p",null,[n[13]||(n[13]=h("Monitor bao gồm hai phần quan trọng, một là khóa, và phần còn lại là cơ chế chờ/thông báo, được thực hiện thông qua các phương thức ")),n[14]||(n[14]=i("code",null,"wait()",-1)),n[15]||(n[15]=h(", ")),n[16]||(n[16]=i("code",null,"notify()",-1)),n[17]||(n[17]=h(", ")),n[18]||(n[18]=i("code",null,"notifyAll()",-1)),n[19]||(n[19]=h(" của lớp ")),n[20]||(n[20]=i("code",null,"Object",-1)),n[21]||(n[21]=h(" (chúng ta sẽ tìm hiểu chi tiết khi nói về ")),a(t,{to:"/programming/java/Concurency/condition.html"},{default:s(()=>n[12]||(n[12]=[h("Condition")])),_:1}),n[22]||(n[22]=h(" và ")),n[23]||(n[23]=i("a",{href:"./producer-consumer"},"mô hình sản xuất-tiêu thụ",-1)),n[24]||(n[24]=h(")."))]),n[31]||(n[31]=c('<p>Bây giờ, chúng ta sẽ lần lượt giới thiệu các loại khóa này và cách chúng được nâng cấp.</p><p>Dưới đây là bản dịch tiếng Việt của đoạn văn bạn cung cấp:</p><h2 id="khoa-thien-vi" tabindex="-1"><a class="header-anchor" href="#khoa-thien-vi"><span>Khoá thiên vị</span></a></h2><p>Tác giả của Hotspot đã nhận thấy rằng trong hầu hết các trường hợp, <strong>khóa không chỉ không có sự cạnh tranh giữa các luồng, mà còn luôn được cùng một luồng nắm giữ nhiều lần</strong>, vì vậy đã giới thiệu khoá thiên vị.</p><p>khoá thiên vị sẽ thiên về luồng đầu tiên truy cập khóa; nếu trong quá trình chạy tiếp theo, khóa đó không bị truy cập bởi các luồng khác, thì luồng nắm giữ khoá thiên vị sẽ không cần kích hoạt đồng bộ hóa. Nói cách khác, <strong>khoá thiên vị trong trường hợp không có cạnh tranh tài nguyên đã loại bỏ câu lệnh đồng bộ hóa</strong>, không cần thực hiện thao tác <a href="./cas">CAS</a> (sẽ được nói chi tiết hơn sau, nhấn vào liên kết để đến). Điều này đã cải thiện hiệu suất chạy của chương trình một cách đáng kể.</p><p>Nói đơn giản, đó là việc thiết lập một biến cho khóa. Nếu biến này là true, nghĩa là không có cạnh tranh tài nguyên, thì không cần thực hiện các quy trình khóa/mở khóa. Nếu biến này là false, nghĩa là có luồng khác đang cạnh tranh tài nguyên, thì sẽ chuyển sang quy trình sau.</p><h3 id="nguyen-ly-thuc-hien-khoa-thien-vi" tabindex="-1"><a class="header-anchor" href="#nguyen-ly-thuc-hien-khoa-thien-vi"><span>Nguyên lý thực hiện khoá thiên vị</span></a></h3><p>Khi một luồng lần đầu tiên vào khối đồng bộ, nó sẽ lưu trữ ThreadId thiên về khóa trong đầu đối tượng và bản ghi khóa trong khung ngăn xếp. Khi lần sau luồng này vào khối đồng bộ này, nó sẽ kiểm tra xem ThreadId trong Mark Word của khóa có phải là ID của chính nó hay không.</p><p>Nếu đúng, điều đó có nghĩa là luồng này đã nắm giữ khóa, và sau đó luồng này không cần thực hiện thao tác CAS để khóa và mở khóa khi vào và ra khỏi khối đồng bộ; nếu không, điều đó có nghĩa là có một luồng khác đang cạnh tranh khoá thiên vị này. Lúc này, nó sẽ cố gắng sử dụng CAS để thay thế ThreadId trong Mark Word bằng ID của luồng mới. Lúc này, sẽ có hai trường hợp xảy ra:</p><ul><li>Thành công, có nghĩa là luồng trước đó không còn tồn tại, ThreadId trong Mark Word sẽ là ID của luồng mới, khóa sẽ không được nâng cấp, vẫn là khoá thiên vị.</li><li>Thất bại, có nghĩa là luồng trước đó vẫn tồn tại, vì vậy sẽ tạm dừng luồng trước đó, đặt cờ hiệu khoá thiên vị thành 0 và đặt cờ khóa thành 00, nâng cấp thành khóa nhẹ, sẽ cạnh tranh khóa theo cách của khóa nhẹ.</li></ul><p><a href="./cas">CAS: So sánh và Hoán đổi</a> sẽ được nói chi tiết hơn sau, nhưng ở đây chỉ cần biết sơ lược.</p><p>CAS có nghĩa là so sánh và thiết lập, được sử dụng để cung cấp thao tác nguyên tử ở cấp độ phần cứng. Trong một số kiến trúc bộ xử lý (như x86), việc so sánh và hoán đổi được thực hiện thông qua lệnh CMPXCHG (Compare and Exchange), một lệnh nguyên tử, thông qua việc so sánh xem có khớp với giá trị đã cho hay không; nếu có thì sẽ sửa đổi, nếu không khớp thì sẽ không sửa đổi.</p><p>Quá trình cạnh tranh khoá thiên vị của các luồng như sau:</p><figure><img src="https://cdn.tobebetterjavaer.com/stutymore/synchronized-20230728110319.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>Hình ảnh trên liên quan đến con trỏ bản ghi khóa trỏ đến bản ghi khóa gần nhất trong ngăn xếp hiện tại, khóa nhẹ được thực hiện theo kiểu phục vụ theo thứ tự đến.</p><h3 id="huy-bo-khoa-thien-vi" tabindex="-1"><a class="header-anchor" href="#huy-bo-khoa-thien-vi"><span>Hủy bỏ khoá thiên vị</span></a></h3><p>khoá thiên vị sử dụng một <strong>cơ chế giải phóng khóa khi có sự cạnh tranh xảy ra</strong>, vì vậy khi các luồng khác cố gắng cạnh tranh khoá thiên vị, thì luồng đang giữ khoá thiên vị mới giải phóng khóa.</p><p>Khi khoá thiên vị nâng cấp thành khóa nhẹ, sẽ tạm dừng luồng đang nắm giữ khoá thiên vị và thiết lập lại cờ khoá thiên vị. Quá trình này nhìn có vẻ đơn giản, nhưng thực tế tiêu tốn chi phí rất lớn, quá trình tổng quát như sau:</p><ol><li>Tại một điểm an toàn (tại thời điểm này không có mã byte nào đang thực thi), tạm dừng luồng đang nắm giữ khóa.</li><li>Duyệt qua ngăn xếp luồng, nếu có bản ghi khóa, cần sửa chữa bản ghi khóa và Mark Word để chúng trở thành trạng thái không khóa.</li><li>Đánh thức luồng đã bị tạm dừng và nâng cấp khóa hiện tại thành khóa nhẹ.</li></ol><p>Vì vậy, nếu trong ứng dụng của bạn, tất cả các khóa thường ở trong trạng thái cạnh tranh, thì khoá thiên vị sẽ trở thành một gánh nặng. Trong trường hợp này, chúng ta có thể tắt tính năng khoá thiên vị mặc định ngay từ đầu:</p><div class="language-java" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#abb2bf;--shiki-dark:#abb2bf;--shiki-light-bg:#282c34;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-dark-pro one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#56B6C2;--shiki-dark:#56B6C2;">-</span><span style="--shiki-light:#E06C75;--shiki-dark:#E06C75;">XX</span><span style="--shiki-light:#C678DD;--shiki-dark:#C678DD;">:</span><span style="--shiki-light:#E06C75;--shiki-dark:#E06C75;">UseBiasedLocking</span><span style="--shiki-light:#56B6C2;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#D19A66;--shiki-dark:#D19A66;">false</span></span></code></pre></div><p>Hình ảnh dưới đây tóm tắt việc nhận và hủy bỏ khoá thiên vị:</p><figure><img src="https://cdn.tobebetterjavaer.com/stutymore/synchronized-20230728112620.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h2 id="khoa-nhe" tabindex="-1"><a class="header-anchor" href="#khoa-nhe"><span>Khóa nhẹ</span></a></h2><p>Khi nhiều luồng nhận cùng một khóa tại các thời điểm khác nhau, tức là không có sự cạnh tranh khóa, cũng không có luồng nào bị chặn. Để xử lý tình huống này, JVM áp dụng khóa nhẹ nhằm tránh việc chặn và đánh thức luồng.</p><p>JVM sẽ tạo ra một không gian để lưu trữ bản ghi khóa cho mỗi luồng trong khung ngăn xếp của luồng hiện tại, chúng ta gọi là Displaced Mark Word. Nếu một luồng khi nhận khóa thấy đó là khóa nhẹ, nó sẽ sao chép Mark Word của khóa vào Displaced Mark Word của chính nó.</p><p>Sau đó, luồng sẽ cố gắng sử dụng CAS để thay thế Mark Word của khóa bằng con trỏ trỏ đến bản ghi khóa. Nếu thành công, luồng hiện tại sẽ nắm giữ khóa; nếu thất bại, điều đó có nghĩa là Mark Word đã được thay thế bằng bản ghi khóa của luồng khác, tức là luồng hiện tại đang cạnh tranh khóa với luồng khác, và sẽ cố gắng sử dụng vòng lặp để nhận khóa.</p><blockquote><p>Vòng lặp: liên tục cố gắng để nhận khóa, thường được thực hiện bằng vòng lặp.</p></blockquote><p>Vòng lặp tiêu tốn CPU, nếu không thể nhận khóa liên tục, thì luồng đó sẽ ở trong trạng thái vòng lặp, lãng phí tài nguyên CPU. Cách đơn giản nhất để giải quyết vấn đề này là chỉ định số lần vòng lặp, ví dụ như cho nó lặp lại 10 lần, nếu vẫn không nhận được khóa, thì sẽ chuyển vào trạng thái bị chặn.</p><p>Tuy nhiên, JDK đã áp dụng một cách tiếp cận thông minh hơn—vòng lặp thích ứng, đơn giản mà nói, nếu luồng đã thành công trong vòng lặp, số lần vòng lặp tiếp theo sẽ nhiều hơn; nếu vòng lặp thất bại, số lần vòng lặp sẽ giảm đi.</p><p>Vòng lặp cũng không phải diễn ra mãi mãi. Nếu sau một mức độ nhất định (liên quan đến JVM và hệ điều hành), mà vẫn không thể nhận khóa, được gọi là vòng lặp thất bại, thì luồng đó sẽ bị chặn. Đồng thời, khóa này sẽ <strong>nâng cấp thành khóa nặng</strong>.</p><h3 id="giai-phong-khoa-nhe" tabindex="-1"><a class="header-anchor" href="#giai-phong-khoa-nhe"><span>Giải phóng khóa nhẹ</span></a></h3><p>Khi giải phóng khóa, luồng hiện tại sẽ sử dụng thao tác CAS để sao chép nội dung của Displaced Mark Word trở lại Mark Word của khóa. Nếu không xảy ra cạnh tranh, thì thao tác sao chép này sẽ thành công. Nếu có luồng khác đã nhiều lần vòng lặp và dẫn đến việc khóa nhẹ nâng cấp thành khóa nặng, thì thao tác CAS sẽ thất bại. Lúc này, khóa sẽ được giải phóng và đánh thức luồng đã bị chặn.</p><p>Một hình ảnh minh họa quá trình khóa và giải phóng khóa:</p><figure><img src="https://cdn.tobebetterjavaer.com/stutymore/synchronized-20230728114101.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h2 id="khoa-nang" tabindex="-1"><a class="header-anchor" href="#khoa-nang"><span>Khóa nặng</span></a></h2><p>Khóa nặng phụ thuộc vào mutex (khóa tương hỗ, được sử dụng để đảm bảo rằng tại bất kỳ thời điểm nào, chỉ có một luồng có thể thực thi một đoạn mã cụ thể) của hệ điều hành để thực hiện, và việc chuyển đổi trạng thái giữa các luồng trong hệ điều hành cần một khoảng thời gian tương đối dài, vì vậy khóa nặng có hiệu suất rất thấp, nhưng luồng bị chặn sẽ không tiêu tốn CPU.</p><p>Như đã nói trước đó, mỗi đối tượng có thể được coi là một khóa. Khi nhiều luồng đồng thời yêu cầu khóa của một đối tượng nào đó, khóa đối tượng sẽ thiết lập một số trạng thái để phân biệt các luồng yêu cầu:</p><ul><li>Contention List: Tất cả các luồng yêu cầu khóa sẽ được đưa vào hàng đợi cạnh tranh này trước tiên.</li><li>Entry List：Các luồng đủ điều kiện trở thành ứng cử viên từ Connection List sẽ được chuyển vào Entry List.</li><li>Wait Set: Những luồng bị chặn vì gọi phương thức wait sẽ được đặt vào Wait Set.</li><li>OnDeck: Mỗi thời điểm chỉ có một luồng đang cạnh tranh khóa, luồng đó được gọi là OnDeck.</li><li>Owner: Luồng đã nhận khóa được gọi là Owner.</li><li>!Owner: Luồng đã giải phóng khóa.</li></ul><p>Khi một luồng cố gắng nhận khóa, nếu khóa đó đã bị chiếm, luồng đó sẽ được bao gói thành một đối tượng <code>ObjectWaiter</code> và chèn vào đầu danh sách Cạnh tranh, sau đó gọi phương thức <code>park</code> để tạm dừng luồng hiện tại.</p><p>Khi luồng giải phóng khóa, nó sẽ chọn một luồng từ Danh sách Cạnh tranh hoặc Danh sách Nhập để đánh thức, luồng được chọn gọi là <code>Heir presumptive</code> (người thừa kế giả định), người thừa kế giả định sẽ được đánh thức và sẽ cố gắng nhận khóa, nhưng <code>synchronized</code> là không công bằng, vì vậy người thừa kế giả định không nhất thiết phải nhận được khóa.</p><p>Điều này là bởi vì đối với khóa nặng, nếu luồng cố gắng nhận khóa mà thất bại, nó sẽ trực tiếp vào trạng thái bị chặn, chờ đợi sự điều phối của hệ điều hành.</p><p>Nếu luồng đã nhận khóa gọi phương thức <code>Object.wait</code>, thì sẽ đặt luồng đó vào Wait Set. Khi được <code>Object.notify</code> đánh thức, luồng sẽ được di chuyển từ Wait Set đến Danh sách Cạnh tranh hoặc Danh sách Nhập. Cần lưu ý rằng khi gọi phương thức <code>wait</code> hoặc <code>notify</code> của một đối tượng khóa, <strong>nếu trạng thái hiện tại của khóa là khoá thiên vị hoặc khóa nhẹ thì sẽ nâng cấp thành khóa nặng</strong>.</p><h2 id="quy-trinh-nang-cap-khoa" tabindex="-1"><a class="header-anchor" href="#quy-trinh-nang-cap-khoa"><span>Quy trình nâng cấp khóa</span></a></h2><p>Mỗi luồng khi chuẩn bị nhận tài nguyên chia sẻ sẽ thực hiện các bước sau:</p><ol><li><p>Bước đầu tiên, kiểm tra xem Mark Word có chứa ThreadId của chính mình không, nếu có, điều đó có nghĩa là luồng hiện tại đang ở trạng thái &quot;khoá thiên vị&quot;.</p></li><li><p>Bước thứ hai, nếu Mark Word không phải là ThreadId của chính mình, khóa sẽ được nâng cấp. Lúc này, sẽ sử dụng CAS để thực hiện việc chuyển đổi. Luồng mới sẽ thông báo cho luồng trước đó tạm dừng theo ThreadId hiện có trong Mark Word, luồng trước đó sẽ đặt nội dung của Mark Word thành rỗng.</p></li><li><p>Bước thứ ba, cả hai luồng sẽ sao chép HashCode của đối tượng khóa vào không gian bản ghi khóa mà họ mới tạo ra, sau đó bắt đầu cạnh tranh Mark Word bằng cách sửa đổi nội dung của Mark Word của đối tượng khóa thành địa chỉ của không gian bản ghi mà họ vừa tạo.</p></li><li><p>Bước thứ tư, luồng nào thực hiện thành công CAS trong bước ba sẽ nhận được tài nguyên; luồng thất bại sẽ vào trạng thái vòng lặp.</p></li><li><p>Bước thứ năm, luồng trong quá trình vòng lặp, nếu thành công nhận được tài nguyên (tức là luồng trước đó đã hoàn thành và giải phóng tài nguyên chia sẻ), thì trạng thái sẽ vẫn ở trạng thái khóa nhẹ. Nếu vòng lặp thất bại.</p></li><li><p>Bước thứ sáu, sẽ vào trạng thái khóa nặng, lúc này, luồng trong trạng thái vòng lặp sẽ bị chặn, chờ luồng trước đó thực hiện xong và đánh thức mình.</p></li></ol><h2 id="tom-tat" tabindex="-1"><a class="header-anchor" href="#tom-tat"><span>Tóm tắt</span></a></h2><ul><li>Mỗi đối tượng trong Java đều có thể hoạt động như một khóa, và các khóa trong Java đều dựa trên đối tượng.</li><li>Từ khóa synchronized có thể được sử dụng để sửa đổi phương thức và khối mã, đảm bảo rằng tại cùng một thời điểm chỉ có một luồng thực thi đoạn mã đó.</li><li>Từ khóa synchronized khi sửa đổi phương thức sẽ khóa đối tượng hiện tại; khi sửa đổi phương thức tĩnh, khóa sẽ là đối tượng Class hiện tại; khi sửa đổi khối mã, khóa sẽ là đối tượng trong dấu ngoặc đơn.</li><li>Java 6 đã giới thiệu &quot;khoá thiên vị&quot; và &quot;khóa nhẹ&quot; để giảm thiểu chi phí hiệu suất do việc nhận và giải phóng khóa. Trước Java 6, tất cả các khóa đều là &quot;khóa nặng&quot;. Do đó, trong Java 6 và sau đó, mỗi đối tượng thực sự có bốn trạng thái khóa, từ thấp đến cao: trạng thái không khóa, trạng thái khoá thiên vị, trạng thái khóa nhẹ và trạng thái khóa nặng.</li><li>khoá thiên vị thiên về luồng đầu tiên truy cập khóa; nếu trong quá trình chạy tiếp theo, khóa đó không bị truy cập bởi các luồng khác, thì luồng nắm giữ khoá thiên vị sẽ không bao giờ cần kích hoạt đồng bộ hóa. Nói cách khác, khoá thiên vị trong trường hợp không có cạnh tranh tài nguyên đã loại bỏ câu lệnh đồng bộ hóa, không cần thực hiện cả thao tác CAS, và cải thiện hiệu suất chạy của chương trình.</li><li>Khóa nhẹ được thực hiện thông qua thao tác CAS và vòng lặp; nếu vòng lặp thất bại, khóa sẽ nâng cấp thành khóa nặng.</li><li>Khóa nặng phụ thuộc vào mutex của hệ điều hành để thực hiện, và việc chuyển đổi trạng thái giữa các luồng trong hệ điều hành cần một khoảng thời gian tương đối dài, vì vậy khóa nặng có hiệu suất rất thấp, nhưng luồng bị chặn sẽ không tiêu tốn CPU.</li></ul>',48))])}const u=g(r,[["render",e],["__file","synchronized.html.vue"]]),y=JSON.parse('{"path":"/programming/java/Concurency/synchronized.html","title":"Synchronized States","lang":"en-US","frontmatter":{"title":"Synchronized States","tags":["java"],"categories":["java"],"order":13,"description":"Bốn trạng thái của synchronized Trong bài trước, chúng ta đã tìm hiểu về cách sử dụng cơ bản của từ khóa synchronized. Nó có thể được sử dụng để đồng bộ hóa phương thức và khối ...","head":[["meta",{"property":"og:url","content":"https://vanhung4499.github.io/programming/java/Concurency/synchronized.html"}],["meta",{"property":"og:site_name","content":"VanHung4499"}],["meta",{"property":"og:title","content":"Synchronized States"}],["meta",{"property":"og:description","content":"Bốn trạng thái của synchronized Trong bài trước, chúng ta đã tìm hiểu về cách sử dụng cơ bản của từ khóa synchronized. Nó có thể được sử dụng để đồng bộ hóa phương thức và khối ..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://cdn.tobebetterjavaer.com/stutymore/synchronized-20230728110319.png"}],["meta",{"property":"og:locale","content":"en-US"}],["meta",{"property":"og:updated_time","content":"2024-10-02T17:20:50.000Z"}],["meta",{"property":"article:author","content":"Hung Nguyen"}],["meta",{"property":"article:tag","content":"java"}],["meta",{"property":"article:modified_time","content":"2024-10-02T17:20:50.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Synchronized States\\",\\"image\\":[\\"https://cdn.tobebetterjavaer.com/stutymore/synchronized-20230728110319.png\\",\\"https://cdn.tobebetterjavaer.com/stutymore/synchronized-20230728112620.png\\",\\"https://cdn.tobebetterjavaer.com/stutymore/synchronized-20230728114101.png\\"],\\"dateModified\\":\\"2024-10-02T17:20:50.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Hung Nguyen\\",\\"url\\":\\"https://vanhung4499.github.io\\"}]}"]]},"headers":[{"level":2,"title":"Cách sử dụng cơ bản của khóa","slug":"cach-su-dung-co-ban-cua-khoa","link":"#cach-su-dung-co-ban-cua-khoa","children":[]},{"level":2,"title":"Bốn trạng thái của khóa và hạ cấp khóa","slug":"bon-trang-thai-cua-khoa-va-ha-cap-khoa","link":"#bon-trang-thai-cua-khoa-va-ha-cap-khoa","children":[]},{"level":2,"title":"Khóa của đối tượng được lưu ở đâu?","slug":"khoa-cua-đoi-tuong-đuoc-luu-o-đau","link":"#khoa-cua-đoi-tuong-đuoc-luu-o-đau","children":[]},{"level":2,"title":"Khoá thiên vị","slug":"khoa-thien-vi","link":"#khoa-thien-vi","children":[{"level":3,"title":"Nguyên lý thực hiện khoá thiên vị","slug":"nguyen-ly-thuc-hien-khoa-thien-vi","link":"#nguyen-ly-thuc-hien-khoa-thien-vi","children":[]},{"level":3,"title":"Hủy bỏ khoá thiên vị","slug":"huy-bo-khoa-thien-vi","link":"#huy-bo-khoa-thien-vi","children":[]}]},{"level":2,"title":"Khóa nhẹ","slug":"khoa-nhe","link":"#khoa-nhe","children":[{"level":3,"title":"Giải phóng khóa nhẹ","slug":"giai-phong-khoa-nhe","link":"#giai-phong-khoa-nhe","children":[]}]},{"level":2,"title":"Khóa nặng","slug":"khoa-nang","link":"#khoa-nang","children":[]},{"level":2,"title":"Quy trình nâng cấp khóa","slug":"quy-trinh-nang-cap-khoa","link":"#quy-trinh-nang-cap-khoa","children":[]},{"level":2,"title":"Tóm tắt","slug":"tom-tat","link":"#tom-tat","children":[]}],"git":{"createdTime":1727889650000,"updatedTime":1727889650000,"contributors":[{"name":"Hung Nguyen Van","email":"vanhung4499@gmail.com","commits":1}]},"readingTime":{"minutes":18.6,"words":5579},"filePathRelative":"programming/java/Concurency/synchronized.md","localizedDate":"October 2, 2024","excerpt":"\\n<p>Trong bài trước, chúng ta đã tìm hiểu về cách sử dụng cơ bản của từ khóa synchronized. Nó có thể được sử dụng để đồng bộ hóa phương thức và khối mã. Vậy <code>synchronized</code> thực sự khóa cái gì? Khi phiên bản JDK nâng cấp, <code>synchronized</code> đã có những thay đổi gì? Liệu có đúng không rằng \\"hiệu suất của synchronized rất kém\\"?</p>","autoDesc":true}');export{u as comp,y as data};
