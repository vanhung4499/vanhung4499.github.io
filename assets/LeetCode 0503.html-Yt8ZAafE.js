import{_ as t,o as e,c as l,d as a,a as n,e as s}from"./app-eD31-AQ-.js";const i={},o=a('<h1 id="_0503-next-greater-element-ii" tabindex="-1"><a class="header-anchor" href="#_0503-next-greater-element-ii"><span><a href="https://leetcode.com/problems/next-greater-element-ii/" target="_blank" rel="noopener noreferrer">0503. Next Greater Element II</a></span></a></h1><ul><li>Thẻ: Ngăn xếp, Mảng, Ngăn xếp đơn điệu</li><li>Độ khó: Trung bình</li></ul><h2 id="tom-tat-đe-bai" tabindex="-1"><a class="header-anchor" href="#tom-tat-đe-bai"><span>Tóm tắt đề bài</span></a></h2><p>Cho một mảng vòng <code>nums</code> (phần tử tiếp theo của phần tử cuối cùng là phần tử đầu tiên của mảng).</p><p>Yêu cầu: Đưa ra phần tử lớn tiếp theo của mỗi phần tử. Nếu không tồn tại, đưa ra <code>-1</code>.</p><ul><li>Phần tử lớn tiếp theo của số <code>x</code>: Theo thứ tự duyệt qua mảng, đó là số lớn hơn nó đầu tiên sau nó. Điều này có nghĩa là bạn nên tìm kiếm số lớn tiếp theo của nó một cách vòng tròn.</li></ul><h2 id="y-tuong-giai-quyet" tabindex="-1"><a class="header-anchor" href="#y-tuong-giai-quyet"><span>Ý tưởng giải quyết</span></a></h2>',7),p=n("p",null,[s("Cách tiếp cận đầu tiên là tìm kiếm trực tiếp theo yêu cầu đề bài. Duyệt qua mảng "),n("code",null,"nums"),s(" và tìm số đầu tiên bên phải của "),n("code",null,"nums[i]"),s(" mà lớn hơn "),n("code",null,"nums[i]"),s(". Độ phức tạp thời gian của phương pháp này là "),n("span",{class:"katex"},[n("span",{class:"katex-mathml"},[n("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[n("semantics",null,[n("mrow",null,[n("mi",null,"O"),n("mo",{stretchy:"false"},"("),n("msup",null,[n("mi",null,"n"),n("mn",null,"2")]),n("mo",{stretchy:"false"},")")]),n("annotation",{encoding:"application/x-tex"},"O(n^2)")])])]),n("span",{class:"katex-html","aria-hidden":"true"},[n("span",{class:"base"},[n("span",{class:"strut",style:{height:"1.0641em","vertical-align":"-0.25em"}}),n("span",{class:"mord mathnormal",style:{"margin-right":"0.02778em"}},"O"),n("span",{class:"mopen"},"("),n("span",{class:"mord"},[n("span",{class:"mord mathnormal"},"n"),n("span",{class:"msupsub"},[n("span",{class:"vlist-t"},[n("span",{class:"vlist-r"},[n("span",{class:"vlist",style:{height:"0.8141em"}},[n("span",{style:{top:"-3.063em","margin-right":"0.05em"}},[n("span",{class:"pstrut",style:{height:"2.7em"}}),n("span",{class:"sizing reset-size6 size3 mtight"},[n("span",{class:"mord mtight"},"2")])])])])])])]),n("span",{class:"mclose"},")")])])]),s(".")],-1),c=n("p",null,[s("Cách tiếp cận thứ hai là sử dụng ngăn xếp đơn điệu. Duyệt qua mảng "),n("code",null,"nums"),s(", xây dựng ngăn xếp đơn điệu để tìm số lớn tiếp theo của mỗi phần tử trong "),n("code",null,"nums"),s(". Sau đó, lưu trữ kết quả vào một mảng. Độ phức tạp thời gian của phương pháp này là "),n("span",{class:"katex"},[n("span",{class:"katex-mathml"},[n("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[n("semantics",null,[n("mrow",null,[n("mi",null,"O"),n("mo",{stretchy:"false"},"("),n("mi",null,"n"),n("mo",{stretchy:"false"},")")]),n("annotation",{encoding:"application/x-tex"},"O(n)")])])]),n("span",{class:"katex-html","aria-hidden":"true"},[n("span",{class:"base"},[n("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),n("span",{class:"mord mathnormal",style:{"margin-right":"0.02778em"}},"O"),n("span",{class:"mopen"},"("),n("span",{class:"mord mathnormal"},"n"),n("span",{class:"mclose"},")")])])]),s(".")],-1),r=a(`<p>Vì mảng <code>nums</code> là một mảng vòng, ta có thể sao chép <code>nums</code> thành một bản sao và nối nó vào cuối, tạo thành một mảng có độ dài <code>len(nums) * 2</code>, hoặc sử dụng phép chia lấy dư để ánh xạ chỉ số vào khoảng từ <code>0</code> đến <code>len(nums) * 2 - 1</code>.</p><p>Cụ thể như sau:</p><ul><li>Sử dụng mảng <code>res</code> để lưu kết quả, khởi tạo tất cả các giá trị ban đầu là <code>-1</code>. Sử dụng ngăn xếp <code>stack</code> để biểu diễn ngăn xếp đơn điệu.</li><li>Duyệt qua mảng <code>nums</code>, đối với phần tử hiện tại: <ul><li>Nếu giá trị phần tử hiện tại nhỏ hơn giá trị phần tử đỉnh ngăn xếp, thì phần tử hiện tại và phần tử đỉnh ngăn xếp có cùng giá trị &quot;phần tử lớn tiếp theo&quot;. Đưa chỉ số phần tử hiện tại vào ngăn xếp.</li><li>Nếu giá trị phần tử hiện tại lớn hơn giá trị phần tử đỉnh ngăn xếp, thì phần tử hiện tại là &quot;phần tử lớn tiếp theo&quot; của phần tử đỉnh ngăn xếp. Tiếp tục đẩy phần tử ra khỏi ngăn xếp cho đến khi giá trị phần tử hiện tại nhỏ hơn giá trị phần tử đỉnh ngăn xếp. <ul><li>Khi đẩy phần tử ra khỏi ngăn xếp, phần tử đó là &quot;phần tử lớn tiếp theo&quot; của phần tử hiện tại. Lưu giá trị phần tử hiện tại vào mảng kết quả <code>res</code> tại vị trí tương ứng với phần tử đỉnh ngăn xếp.</li></ul></li></ul></li><li>Trả về mảng kết quả <code>res</code>.</li></ul><h2 id="code" tabindex="-1"><a class="header-anchor" href="#code"><span>Code</span></a></h2><div class="language-python" data-ext="python" data-title="python"><pre class="shiki shiki-themes one-dark-pro one-dark-pro vp-code" style="background-color:#282c34;--shiki-dark-bg:#282c34;color:#abb2bf;--shiki-dark:#abb2bf;" tabindex="0"><code><span class="line"><span style="color:#C678DD;--shiki-dark:#C678DD;">class</span><span style="color:#E5C07B;--shiki-dark:#E5C07B;"> Solution</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">:</span></span>
<span class="line"><span style="color:#C678DD;--shiki-dark:#C678DD;">    def</span><span style="color:#61AFEF;--shiki-dark:#61AFEF;"> nextGreaterElements</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">(</span><span style="color:#E5C07B;--shiki-dark:#E5C07B;font-style:italic;--shiki-dark-font-style:italic;">self</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">, </span><span style="color:#D19A66;--shiki-dark:#D19A66;font-style:italic;--shiki-dark-font-style:italic;">nums</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">: List[</span><span style="color:#56B6C2;--shiki-dark:#56B6C2;">int</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">]) -&gt; List[</span><span style="color:#56B6C2;--shiki-dark:#56B6C2;">int</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">]:</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">        size </span><span style="color:#56B6C2;--shiki-dark:#56B6C2;">=</span><span style="color:#56B6C2;--shiki-dark:#56B6C2;"> len</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">(nums)</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">        res </span><span style="color:#56B6C2;--shiki-dark:#56B6C2;">=</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;"> [</span><span style="color:#56B6C2;--shiki-dark:#56B6C2;">-</span><span style="color:#D19A66;--shiki-dark:#D19A66;">1</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">] </span><span style="color:#56B6C2;--shiki-dark:#56B6C2;">*</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;"> size</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">        stack </span><span style="color:#56B6C2;--shiki-dark:#56B6C2;">=</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;"> []</span></span>
<span class="line"><span style="color:#C678DD;--shiki-dark:#C678DD;">        for</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;"> i </span><span style="color:#C678DD;--shiki-dark:#C678DD;">in</span><span style="color:#56B6C2;--shiki-dark:#56B6C2;"> range</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">(size </span><span style="color:#56B6C2;--shiki-dark:#56B6C2;">*</span><span style="color:#D19A66;--shiki-dark:#D19A66;"> 2</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">):</span></span>
<span class="line"><span style="color:#C678DD;--shiki-dark:#C678DD;">            while</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;"> stack </span><span style="color:#C678DD;--shiki-dark:#C678DD;">and</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;"> nums[i </span><span style="color:#56B6C2;--shiki-dark:#56B6C2;">%</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;"> size] </span><span style="color:#56B6C2;--shiki-dark:#56B6C2;">&gt;</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;"> nums[stack[</span><span style="color:#56B6C2;--shiki-dark:#56B6C2;">-</span><span style="color:#D19A66;--shiki-dark:#D19A66;">1</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">]]:</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">                index </span><span style="color:#56B6C2;--shiki-dark:#56B6C2;">=</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;"> stack.</span><span style="color:#61AFEF;--shiki-dark:#61AFEF;">pop</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">()</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">                res[index] </span><span style="color:#56B6C2;--shiki-dark:#56B6C2;">=</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;"> nums[i </span><span style="color:#56B6C2;--shiki-dark:#56B6C2;">%</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;"> size]</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">            stack.</span><span style="color:#61AFEF;--shiki-dark:#61AFEF;">append</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">(i </span><span style="color:#56B6C2;--shiki-dark:#56B6C2;">%</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;"> size)</span></span>
<span class="line"></span>
<span class="line"><span style="color:#C678DD;--shiki-dark:#C678DD;">        return</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;"> res</span></span></code></pre></div><h2 id="y-tuong-đo-phuc-tap" tabindex="-1"><a class="header-anchor" href="#y-tuong-đo-phuc-tap"><span>Ý tưởng: Độ phức tạp</span></a></h2>`,6),h=n("ul",null,[n("li",null,[n("strong",null,"Độ phức tạp thời gian"),s(": "),n("span",{class:"katex"},[n("span",{class:"katex-mathml"},[n("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[n("semantics",null,[n("mrow",null,[n("mi",null,"O"),n("mo",{stretchy:"false"},"("),n("mi",null,"n"),n("mo",{stretchy:"false"},")")]),n("annotation",{encoding:"application/x-tex"},"O(n)")])])]),n("span",{class:"katex-html","aria-hidden":"true"},[n("span",{class:"base"},[n("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),n("span",{class:"mord mathnormal",style:{"margin-right":"0.02778em"}},"O"),n("span",{class:"mopen"},"("),n("span",{class:"mord mathnormal"},"n"),n("span",{class:"mclose"},")")])])]),s(".")]),n("li",null,[n("strong",null,"Độ phức tạp không gian"),s(": "),n("span",{class:"katex"},[n("span",{class:"katex-mathml"},[n("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[n("semantics",null,[n("mrow",null,[n("mi",null,"O"),n("mo",{stretchy:"false"},"("),n("mi",null,"n"),n("mo",{stretchy:"false"},")")]),n("annotation",{encoding:"application/x-tex"},"O(n)")])])]),n("span",{class:"katex-html","aria-hidden":"true"},[n("span",{class:"base"},[n("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),n("span",{class:"mord mathnormal",style:{"margin-right":"0.02778em"}},"O"),n("span",{class:"mopen"},"("),n("span",{class:"mord mathnormal"},"n"),n("span",{class:"mclose"},")")])])]),s(".")])],-1),d=[o,p,c,r,h];function B(m,k){return e(),l("div",null,d)}const g=t(i,[["render",B],["__file","LeetCode 0503.html.vue"]]),y=JSON.parse('{"path":"/dsa/leetcode/LeetCode%200503.html","title":"LeetCode 0503","lang":"en-US","frontmatter":{"title":"LeetCode 0503","tags":["dsa","leetcode"],"categories":["dsa","leetcode"],"date created":"2023-09-24T00:00:00.000Z","date modified":"2023-09-28T00:00:00.000Z","description":"0503. Next Greater Element II Thẻ: Ngăn xếp, Mảng, Ngăn xếp đơn điệu Độ khó: Trung bình Tóm tắt đề bài Cho một mảng vòng nums (phần tử tiếp theo của phần tử cuối cùng là phần tử...","head":[["meta",{"property":"og:url","content":"https://vanhung4499.github.io/dsa/leetcode/LeetCode%200503.html"}],["meta",{"property":"og:site_name","content":"VanHung4499"}],["meta",{"property":"og:title","content":"LeetCode 0503"}],["meta",{"property":"og:description","content":"0503. Next Greater Element II Thẻ: Ngăn xếp, Mảng, Ngăn xếp đơn điệu Độ khó: Trung bình Tóm tắt đề bài Cho một mảng vòng nums (phần tử tiếp theo của phần tử cuối cùng là phần tử..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"en-US"}],["meta",{"property":"og:updated_time","content":"2024-06-28T15:54:38.000Z"}],["meta",{"property":"article:author","content":"Hung Nguyen"}],["meta",{"property":"article:tag","content":"dsa"}],["meta",{"property":"article:tag","content":"leetcode"}],["meta",{"property":"article:modified_time","content":"2024-06-28T15:54:38.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"LeetCode 0503\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2024-06-28T15:54:38.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Hung Nguyen\\",\\"url\\":\\"https://vanhung4499.github.io\\"}]}"]]},"headers":[{"level":2,"title":"Tóm tắt đề bài","slug":"tom-tat-đe-bai","link":"#tom-tat-đe-bai","children":[]},{"level":2,"title":"Ý tưởng giải quyết","slug":"y-tuong-giai-quyet","link":"#y-tuong-giai-quyet","children":[]},{"level":2,"title":"Code","slug":"code","link":"#code","children":[]},{"level":2,"title":"Ý tưởng: Độ phức tạp","slug":"y-tuong-đo-phuc-tap","link":"#y-tuong-đo-phuc-tap","children":[]}],"git":{"createdTime":1719590078000,"updatedTime":1719590078000,"contributors":[{"name":"Hung Nguyen Van","email":"vanhung4499@gmail.com","commits":1}]},"readingTime":{"minutes":2.56,"words":769},"filePathRelative":"dsa/leetcode/LeetCode 0503.md","localizedDate":"June 28, 2024","excerpt":"\\n<ul>\\n<li>Thẻ: Ngăn xếp, Mảng, Ngăn xếp đơn điệu</li>\\n<li>Độ khó: Trung bình</li>\\n</ul>\\n<h2>Tóm tắt đề bài</h2>\\n<p>Cho một mảng vòng <code>nums</code> (phần tử tiếp theo của phần tử cuối cùng là phần tử đầu tiên của mảng).</p>\\n<p>Yêu cầu: Đưa ra phần tử lớn tiếp theo của mỗi phần tử. Nếu không tồn tại, đưa ra <code>-1</code>.</p>","autoDesc":true}');export{g as comp,y as data};
