import{_ as n,g as i,o as l,c as p,e as r,h as s,f as o,w as c,a as e}from"./app-BRTHG7K9.js";const d={},t=e(`<h1 id="本地缓存" tabindex="-1"><a class="header-anchor" href="#本地缓存"><span>本地缓存</span></a></h1><p>重要说明：</p><p>① 由于大家普遍反馈，“本地缓存”学习成本太高，一般 Redis 缓存足够满足大多数场景的性能要求，所以基本使用 <a href="/redis-cache">Spring Cache</a> + Redis 所替代。</p><p>也因此，本章节更多的，是讲解如何在项目中使用本地缓存。如果你不需要本地缓存，可以忽略本章节。</p><p>② 项目中还保留了部分地方使用本地缓存，例如说：短信客户端、文件客户端、敏感词等。主要原因是，它们是“有状态”的 Java 对象，无法缓存到 Redis 中。</p><p>系统使用本地缓存，提升公用逻辑的执行性能。 例如说：</p><ul><li><a href="https://github.com/YunaiV/ruoyi-vue-pro/blob/master/yudao-module-system/yudao-module-system-biz/src/main/java/cn/iocoder/yudao/module/system/service/tenant/TenantServiceImpl.java" target="_blank" rel="noopener noreferrer">租户模块</a> 缓存租户信息，每次 RESTful API 校验租户是否禁用、过期时，无需读库。</li><li><a href="https://github.com/YunaiV/ruoyi-vue-pro/blob/master/yudao-module-system/yudao-module-system-biz/src/main/java/cn/iocoder/yudao/module/system/service/dept/DeptServiceImpl.java" target="_blank" rel="noopener noreferrer">部门模块</a> 缓存部门信息，每次数据权限校验时，无需读库。</li><li><a href="https://github.com/YunaiV/ruoyi-vue-pro/blob/master/yudao-module-system/yudao-module-system-biz/src/main/java/cn/iocoder/yudao/module/system/service/permission/PermissionServiceImpl.java" target="_blank" rel="noopener noreferrer">权限模块</a> 缓存权限信息，每次功能权限校验时，无需读库。</li></ul><h2 id="_1-实现原理" tabindex="-1"><a class="header-anchor" href="#_1-实现原理"><span><a href="#_1-%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86">#</a> 1. 实现原理</span></a></h2><p>本地缓存的实现，一共有两步，如下图所示：</p><figure><img src="https://doc.iocoder.cn/img/本地缓存/04.png" alt="整体流程" tabindex="0" loading="lazy"><figcaption>整体流程</figcaption></figure><ul><li>项目启动时，初始化缓存：从数据库中读取数据，写入到本地缓存（例如说一个 Map 对象）</li><li>数据变化时，实时刷新缓存：（例如说通过管理后台修改数据）重新从数据库中读取数据，重新写入到本地缓存</li></ul><h2 id="_2-实战案例" tabindex="-1"><a class="header-anchor" href="#_2-实战案例"><span><a href="#_2-%E5%AE%9E%E6%88%98%E6%A1%88%E4%BE%8B">#</a> 2. 实战案例</span></a></h2><p>以 <a href="https://github.com/YunaiV/ruoyi-vue-pro/blob/master/yudao-module-system/yudao-module-system-biz/src/main/java/cn/iocoder/yudao/module/system/service/permission/RoleServiceImpl.java" target="_blank" rel="noopener noreferrer">角色模块</a> 为例，讲解如何实现角色信息的本地缓存。</p><h3 id="_2-1-初始化缓存" tabindex="-1"><a class="header-anchor" href="#_2-1-初始化缓存"><span><a href="#_2-1-%E5%88%9D%E5%A7%8B%E5%8C%96%E7%BC%93%E5%AD%98">#</a> 2.1 初始化缓存</span></a></h3><p>① 在 <a href="https://github.com/YunaiV/ruoyi-vue-pro/blob/master/yudao-module-system/yudao-module-system-biz/src/main/java/cn/iocoder/yudao/module/system/service/permission/RoleService.java" target="_blank" rel="noopener noreferrer">RoleService</a> 接口中，定义 <code>#initLocalCache()</code> 方法。代码如下：</p><div class="language-" data-ext="" data-title=""><pre class="shiki shiki-themes one-dark-pro one-dark-pro vp-code" style="background-color:#282c34;--shiki-dark-bg:#282c34;color:#abb2bf;--shiki-dark:#abb2bf;" tabindex="0"><code><span class="line"><span>// RoleService.java</span></span>
<span class="line"><span></span></span>
<span class="line"><span>/**</span></span>
<span class="line"><span> * 初始化角色的本地缓存</span></span>
<span class="line"><span> */</span></span>
<span class="line"><span>void initLocalCache();</span></span></code></pre></div><p>为什么要定义接口方法？</p><p>稍后实时刷新缓存时，会调用 RoleService 接口的该方法。</p><p>② 在 <a href="https://github.com/YunaiV/ruoyi-vue-pro/blob/master/yudao-module-system/yudao-module-system-biz/src/main/java/cn/iocoder/yudao/module/system/service/permission/RoleServiceImpl.java" target="_blank" rel="noopener noreferrer">RoleServiceImpl</a> 类中，实现 <code>#initLocalCache()</code> 方法，通过 <code>@PostConstruct</code> 注解，在项目启动时进行本地缓存的初始化。代码如下：</p><div class="language- line-numbers-mode" data-ext="" data-title=""><pre class="shiki shiki-themes one-dark-pro one-dark-pro vp-code" style="background-color:#282c34;--shiki-dark-bg:#282c34;color:#abb2bf;--shiki-dark:#abb2bf;" tabindex="0"><code><span class="line"><span>// RoleServiceImpl.java</span></span>
<span class="line"><span></span></span>
<span class="line"><span>/**</span></span>
<span class="line"><span> * 角色缓存</span></span>
<span class="line"><span> * key：角色编号 {@link RoleDO#getId()}</span></span>
<span class="line"><span> *</span></span>
<span class="line"><span> * 这里声明 volatile 修饰的原因是，每次刷新时，直接修改指向</span></span>
<span class="line"><span> */</span></span>
<span class="line"><span>@Getter</span></span>
<span class="line"><span>private volatile Map&lt;Long, RoleDO&gt; roleCache;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>/**</span></span>
<span class="line"><span> * 初始化 {@link #roleCache} 缓存</span></span>
<span class="line"><span> */</span></span>
<span class="line"><span>@Override</span></span>
<span class="line"><span>@PostConstruct</span></span>
<span class="line"><span>public void initLocalCache() {</span></span>
<span class="line"><span>    // 注意：忽略自动多租户，因为要全局初始化缓存</span></span>
<span class="line"><span>    TenantUtils.executeIgnore(() -&gt; {</span></span>
<span class="line"><span>        // 第一步：查询数据</span></span>
<span class="line"><span>        List&lt;RoleDO&gt; roleList = roleMapper.selectList();</span></span>
<span class="line"><span>        log.info(&quot;[initLocalCache][缓存角色，数量为:{}]&quot;, roleList.size());</span></span>
<span class="line"><span></span></span>
<span class="line"><span>        // 第二步：构建缓存</span></span>
<span class="line"><span>        roleCache = CollectionUtils.convertMap(roleList, RoleDO::getId);</span></span>
<span class="line"><span>    });</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>疑问：为什么使用 TenantUtils 的 executeIgnore 方法来执行逻辑？</p><p>由于 RoleDO 是多租户隔离，如果使用 TenantUtils 方法，会导致缓存刷新时，只加载某个租户的角色数据，导致本地缓存的错误。</p><p>所以，如果缓存的数据不存在多租户隔离的情况，可以不使用 TenantUtils 方法！！！！</p><h3 id="_2-2-实时刷新缓存" tabindex="-1"><a class="header-anchor" href="#_2-2-实时刷新缓存"><span><a href="#_2-2-%E5%AE%9E%E6%97%B6%E5%88%B7%E6%96%B0%E7%BC%93%E5%AD%98">#</a> 2.2 实时刷新缓存</span></a></h3><p>为什么需要使用 Redis Pub/Sub 来实时刷新缓存？考虑到高可用，线上会部署多个 JVM 实例，需要通过 Redis 广播到所有实例，实现本地缓存的刷新。</p><figure><img src="https://doc.iocoder.cn/img/本地缓存/02.png" alt="实时刷新缓存" tabindex="0" loading="lazy"><figcaption>实时刷新缓存</figcaption></figure><p>友情提示：</p>`,27),u=e(`<h4 id="_2-2-1-rolerefreshmessage" tabindex="-1"><a class="header-anchor" href="#_2-2-1-rolerefreshmessage"><span><a href="#_2-2-1-rolerefreshmessage">#</a> 2.2.1 RoleRefreshMessage</span></a></h4><p>新建 RoleRefreshMessage 类，角色数据刷新 Message。代码如下：</p><div class="language-" data-ext="" data-title=""><pre class="shiki shiki-themes one-dark-pro one-dark-pro vp-code" style="background-color:#282c34;--shiki-dark-bg:#282c34;color:#abb2bf;--shiki-dark:#abb2bf;" tabindex="0"><code><span class="line"><span>@Data</span></span>
<span class="line"><span>@EqualsAndHashCode(callSuper = true)</span></span>
<span class="line"><span>public class RoleRefreshMessage extends AbstractRedisChannelMessage {</span></span>
<span class="line"><span>}</span></span></code></pre></div><h4 id="_2-2-2-roleproducer" tabindex="-1"><a class="header-anchor" href="#_2-2-2-roleproducer"><span><a href="#_2-2-2-roleproducer">#</a> 2.2.2 RoleProducer</span></a></h4><p>① 新建 RoleProducer 类，RoleRefreshMessage 的 Producer 生产者。代码如下：</p><div class="language- line-numbers-mode" data-ext="" data-title=""><pre class="shiki shiki-themes one-dark-pro one-dark-pro vp-code" style="background-color:#282c34;--shiki-dark-bg:#282c34;color:#abb2bf;--shiki-dark:#abb2bf;" tabindex="0"><code><span class="line"><span>@Component</span></span>
<span class="line"><span>public class RoleProducer {</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    @Resource</span></span>
<span class="line"><span>    private RedisMQTemplate redisMQTemplate;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    /**</span></span>
<span class="line"><span>     * 发送 {@link RoleRefreshMessage} 消息</span></span>
<span class="line"><span>     */</span></span>
<span class="line"><span>    public void sendRoleRefreshMessage() {</span></span>
<span class="line"><span>        RoleRefreshMessage message = new RoleRefreshMessage();</span></span>
<span class="line"><span>        redisMQTemplate.send(message);</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>② 在数据的新增 / 修改 / 删除等写入操作时，需要使用 RoleProducer 发送消息。如下图所示：</p><figure><img src="https://doc.iocoder.cn/img/本地缓存/03.png" alt="调用 RoleProducer 示例" tabindex="0" loading="lazy"><figcaption>调用 RoleProducer 示例</figcaption></figure><h4 id="_2-2-3-rolerefreshconsumer" tabindex="-1"><a class="header-anchor" href="#_2-2-3-rolerefreshconsumer"><span><a href="#_2-2-3-rolerefreshconsumer">#</a> 2.2.3 RoleRefreshConsumer</span></a></h4><p>新建 RoleRefreshConsumer 类，RoleRefreshMessage 的 Consumer 消费者，刷新本地缓存。代码如下：</p><div class="language-" data-ext="" data-title=""><pre class="shiki shiki-themes one-dark-pro one-dark-pro vp-code" style="background-color:#282c34;--shiki-dark-bg:#282c34;color:#abb2bf;--shiki-dark:#abb2bf;" tabindex="0"><code><span class="line"><span>@Component</span></span>
<span class="line"><span>@Slf4j</span></span>
<span class="line"><span>public class RoleRefreshConsumer extends AbstractRedisChannelMessageListener&lt;RoleRefreshMessage&gt; {</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    @Resource</span></span>
<span class="line"><span>    private RoleService roleService;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    @Override</span></span>
<span class="line"><span>    public void onMessage(RoleRefreshMessage message) {</span></span>
<span class="line"><span>        log.info(&quot;[onMessage][收到 Role 刷新消息]&quot;);</span></span>
<span class="line"><span>        roleService.initLocalCache();</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>}</span></span></code></pre></div>`,11);function v(m,h){const a=i("RouteLink");return l(),p("div",null,[t,r("p",null,[s("Redis Pub/Sub 的使用与讲解，可见 "),o(a,{to:"/message-queue/redis/"},{default:c(()=>[s("《开发指南 —— 消息队列》")]),_:1}),s(" 文档。")]),u])}const g=n(d,[["render",v],["__file","local-cache.html.vue"]]),f=JSON.parse('{"path":"/project/rouyi-vue-pro/local-cache.html","title":"本地缓存","lang":"en-US","frontmatter":{"title":"本地缓存","tags":["project","java","spring-boot","spring-cloud"],"categories":["project"],"order":42,"feed":false,"seo":false,"head":[]},"headers":[{"level":2,"title":"# 1. 实现原理","slug":"_1-实现原理","link":"#_1-实现原理","children":[]},{"level":2,"title":"# 2. 实战案例","slug":"_2-实战案例","link":"#_2-实战案例","children":[{"level":3,"title":"# 2.1 初始化缓存","slug":"_2-1-初始化缓存","link":"#_2-1-初始化缓存","children":[]},{"level":3,"title":"# 2.2 实时刷新缓存","slug":"_2-2-实时刷新缓存","link":"#_2-2-实时刷新缓存","children":[]}]}],"git":{"createdTime":1720365235000,"updatedTime":1720365235000,"contributors":[{"name":"Hung Nguyen Van","email":"vanhung4499@gmail.com","commits":1}]},"readingTime":{"minutes":3.61,"words":1083},"filePathRelative":"project/rouyi-vue-pro/local-cache.md","localizedDate":"July 7, 2024"}');export{g as comp,f as data};
