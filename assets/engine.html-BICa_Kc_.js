import{_ as n,o as t,c as h,d as c}from"./app-BsgpqssW.js";const i={},a=c(`<h1 id="mysql-storage-engine" tabindex="-1"><a class="header-anchor" href="#mysql-storage-engine"><span>MySQL Storage Engine</span></a></h1><h2 id="cac-storage-engine-trong-mysql" tabindex="-1"><a class="header-anchor" href="#cac-storage-engine-trong-mysql"><span>Các storage engine trong MySQL</span></a></h2><p>Trong hệ thống tệp, MySQL lưu mỗi cơ sở dữ liệu (cũng có thể gọi là schema) dưới dạng một thư mục con trong thư mục dữ liệu. Khi tạo bảng, MySQL sẽ tạo một tệp <code>.frm</code> cùng tên với bảng trong thư mục cơ sở dữ liệu để lưu định nghĩa của bảng. Vì MySQL sử dụng các thư mục và tệp hệ thống tệp để lưu định nghĩa cơ sở dữ liệu và bảng, tính nhạy cảm chữ hoa chữ thường phụ thuộc vào nền tảng cụ thể. Trong Windows, tính nhạy cảm chữ hoa chữ thường không được áp dụng; trong các hệ thống tương tự Unix, tính nhạy cảm chữ hoa chữ thường được áp dụng. <strong>Các storage engine khác nhau lưu trữ dữ liệu và chỉ mục theo cách khác nhau, nhưng định nghĩa bảng thì được xử lý thống nhất ở tầng dịch vụ của MySQL.</strong></p><p>MySQL sử dụng các storage engine dưới dạng plugin, mỗi storage engine nhắm đến một môi trường ứng dụng cơ sở dữ liệu cụ thể. Đồng thời, MySQL mã nguồn mở còn cho phép các nhà phát triển thiết lập các storage engine riêng của họ. Dưới đây là một số storage engine phổ biến:</p><ul><li>storage engine InnoDB: Đây là storage engine mặc định từ phiên bản MySQL 5.5 trở đi, với đặc điểm lớn nhất là hỗ trợ giao dịch, khóa cấp hàng, và ràng buộc khóa ngoại.</li><li>storage engine MyISAM: Là storage engine mặc định trước phiên bản MySQL 5.5, không hỗ trợ giao dịch, cũng không hỗ trợ khóa ngoại, nhưng có đặc điểm lớn nhất là tốc độ nhanh và chiếm ít tài nguyên.</li><li>storage engine Memory: Sử dụng bộ nhớ hệ thống làm phương tiện lưu trữ để có được tốc độ phản hồi nhanh hơn. Tuy nhiên, nếu quá trình mysqld bị sập, tất cả dữ liệu sẽ bị mất, do đó chỉ nên sử dụng storage engine Memory khi dữ liệu là tạm thời.</li><li>storage engine NDB: Còn được gọi là storage engine NDB Cluster, chủ yếu được sử dụng cho môi trường cụm phân tán MySQL Cluster, tương tự như cụm RAC của Oracle.</li><li>storage engine Archive: Có cơ chế nén tốt, dùng để lưu trữ tệp. Khi yêu cầu ghi dữ liệu, sẽ thực hiện nén, do đó thường được dùng để làm kho lưu trữ.</li></ul><h2 id="cac-thao-tac-lien-quan-đen-storage-engine" tabindex="-1"><a class="header-anchor" href="#cac-thao-tac-lien-quan-đen-storage-engine"><span>Các thao tác liên quan đến storage engine</span></a></h2><h3 id="lenh-show-storage-engine" tabindex="-1"><a class="header-anchor" href="#lenh-show-storage-engine"><span>Lệnh show storage engine</span></a></h3><div class="language-sql" data-ext="sql" data-title="sql"><pre class="shiki shiki-themes one-dark-pro one-dark-pro vp-code" style="background-color:#282c34;--shiki-dark-bg:#282c34;color:#abb2bf;--shiki-dark:#abb2bf;" tabindex="0"><code><span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;"># Xem các storage engine được hỗ trợ</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">SHOW ENGINES;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;"># Xem storage engine mặc định</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">SHOW VARIABLES </span><span style="color:#C678DD;--shiki-dark:#C678DD;">LIKE</span><span style="color:#98C379;--shiki-dark:#98C379;"> &#39;storage_engine&#39;</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;"># Xem storage engine của một bảng cụ thể</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">SHOW </span><span style="color:#C678DD;--shiki-dark:#C678DD;">CREATE</span><span style="color:#C678DD;--shiki-dark:#C678DD;"> TABLE</span><span style="color:#98C379;--shiki-dark:#98C379;"> \`table_name\`</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;"># Xem storage engine của một bảng cụ thể trong một cơ sở dữ liệu</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">SHOW </span><span style="color:#C678DD;--shiki-dark:#C678DD;">TABLE</span><span style="color:#C678DD;--shiki-dark:#C678DD;"> STATUS</span><span style="color:#C678DD;--shiki-dark:#C678DD;"> LIKE</span><span style="color:#98C379;--shiki-dark:#98C379;"> &#39;table_name&#39;</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">SHOW </span><span style="color:#C678DD;--shiki-dark:#C678DD;">TABLE</span><span style="color:#C678DD;--shiki-dark:#C678DD;"> STATUS</span><span style="color:#C678DD;--shiki-dark:#C678DD;"> FROM</span><span style="color:#98C379;--shiki-dark:#98C379;"> \`database_name\`</span><span style="color:#C678DD;--shiki-dark:#C678DD;"> WHERE</span><span style="color:#98C379;--shiki-dark:#98C379;"> \`name\`</span><span style="color:#56B6C2;--shiki-dark:#56B6C2;"> =</span><span style="color:#98C379;--shiki-dark:#98C379;"> &quot;table_name&quot;</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">;</span></span></code></pre></div><h2 id="cac-lenh-thiet-lap-storage-engine" tabindex="-1"><a class="header-anchor" href="#cac-lenh-thiet-lap-storage-engine"><span>Các lệnh thiết lập storage engine</span></a></h2><h3 id="lenh-tao-va-thay-đoi-storage-engine" tabindex="-1"><a class="header-anchor" href="#lenh-tao-va-thay-đoi-storage-engine"><span>Lệnh tạo và thay đổi storage engine</span></a></h3><div class="language-sql" data-ext="sql" data-title="sql"><pre class="shiki shiki-themes one-dark-pro one-dark-pro vp-code" style="background-color:#282c34;--shiki-dark-bg:#282c34;color:#abb2bf;--shiki-dark:#abb2bf;" tabindex="0"><code><span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;"># Chỉ định storage engine khi tạo bảng, nếu không chỉ định rõ, mặc định là INNODB</span></span>
<span class="line"><span style="color:#C678DD;--shiki-dark:#C678DD;">CREATE</span><span style="color:#C678DD;--shiki-dark:#C678DD;"> TABLE</span><span style="color:#61AFEF;--shiki-dark:#61AFEF;"> t1</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;"> (i </span><span style="color:#C678DD;--shiki-dark:#C678DD;">INT</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">) ENGINE </span><span style="color:#56B6C2;--shiki-dark:#56B6C2;">=</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;"> INNODB;</span></span>
<span class="line"><span style="color:#C678DD;--shiki-dark:#C678DD;">CREATE</span><span style="color:#C678DD;--shiki-dark:#C678DD;"> TABLE</span><span style="color:#61AFEF;--shiki-dark:#61AFEF;"> t2</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;"> (i </span><span style="color:#C678DD;--shiki-dark:#C678DD;">INT</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">) ENGINE </span><span style="color:#56B6C2;--shiki-dark:#56B6C2;">=</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;"> CSV;</span></span>
<span class="line"><span style="color:#C678DD;--shiki-dark:#C678DD;">CREATE</span><span style="color:#C678DD;--shiki-dark:#C678DD;"> TABLE</span><span style="color:#61AFEF;--shiki-dark:#61AFEF;"> t3</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;"> (i </span><span style="color:#C678DD;--shiki-dark:#C678DD;">INT</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">) ENGINE </span><span style="color:#56B6C2;--shiki-dark:#56B6C2;">=</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;"> MEMORY;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;"># Thay đổi storage engine</span></span>
<span class="line"><span style="color:#C678DD;--shiki-dark:#C678DD;">ALTER</span><span style="color:#C678DD;--shiki-dark:#C678DD;"> TABLE</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;"> t ENGINE </span><span style="color:#56B6C2;--shiki-dark:#56B6C2;">=</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;"> InnoDB;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;"># Thay đổi storage engine mặc định, cũng có thể thay đổi trong tệp cấu hình </span><span style="color:#D19A66;--shiki-dark:#D19A66;">my</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">.</span><span style="color:#D19A66;--shiki-dark:#D19A66;">cnf</span></span>
<span class="line"><span style="color:#C678DD;--shiki-dark:#C678DD;">SET</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;"> default_storage_engine</span><span style="color:#56B6C2;--shiki-dark:#56B6C2;">=</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">NDBCLUSTER;</span></span></code></pre></div><p>Mặc định, mỗi khi <code>CREATE TABLE</code> hoặc <code>ALTER TABLE</code> không thể sử dụng storage engine mặc định, sẽ tạo ra một cảnh báo. Để ngăn chặn hành vi gây nhầm lẫn khi storage engine yêu cầu không khả dụng, có thể kích hoạt chế độ <code>NO_ENGINE_SUBSTITUTION SQL</code>. Nếu bộ máy yêu cầu không khả dụng, thiết lập này sẽ tạo ra lỗi thay vì cảnh báo và sẽ không tạo hoặc thay đổi bảng.</p><h2 id="gioi-thieu-ve-cac-storage-engine-mysql" tabindex="-1"><a class="header-anchor" href="#gioi-thieu-ve-cac-storage-engine-mysql"><span>Giới thiệu về các storage engine MySQL</span></a></h2><h3 id="cac-storage-engine-tich-hop-trong-mysql" tabindex="-1"><a class="header-anchor" href="#cac-storage-engine-tich-hop-trong-mysql"><span>Các storage engine tích hợp trong MySQL</span></a></h3><ul><li><strong>InnoDB</strong> - InnoDB là storage engine mặc định từ phiên bản MySQL 5.5 trở đi. Nó cung cấp khóa cấp hàng và ràng buộc khóa ngoại. Hiệu suất tốt và hỗ trợ tự động phục hồi sau khi gặp sự cố.</li><li><strong>MyISAM</strong> - Trước phiên bản MySQL 5.5, MyISAM là storage engine mặc định. Nó có nhiều tính năng nhưng không hỗ trợ giao dịch, không hỗ trợ khóa cấp hàng và khóa ngoại, và không có khả năng phục hồi sau sự cố.</li><li><strong>CSV</strong> - Có thể xử lý tệp CSV như bảng MySQL, nhưng bảng này không hỗ trợ chỉ mục.</li><li><strong>Memory</strong> - Lưu trữ dữ liệu trong bộ nhớ để có tốc độ phản hồi nhanh hơn. Tuy nhiên, nếu quá trình mysqld gặp sự cố, tất cả dữ liệu sẽ bị mất.</li><li><strong>NDB</strong> - Còn gọi là storage engine NDB Cluster, chủ yếu dùng cho môi trường cụm phân tán MySQL Cluster, tương tự như cụm RAC của Oracle.</li><li><strong>Archive</strong> - storage engine Archive rất phù hợp để lưu trữ dữ liệu. <ul><li>storage engine Archive chỉ hỗ trợ thao tác <code>INSERT</code> và <code>SELECT</code>.</li><li>storage engine Archive sử dụng thuật toán nén zlib, với tỷ lệ nén có thể đạt 1:10.</li></ul></li></ul><h3 id="cach-chon-storage-engine-phu-hop" tabindex="-1"><a class="header-anchor" href="#cach-chon-storage-engine-phu-hop"><span>Cách chọn storage engine phù hợp</span></a></h3><p>Phần lớn trường hợp, InnoDB là lựa chọn đúng đắn, trừ khi cần các tính năng mà InnoDB không có.</p><p>Nếu ứng dụng cần chọn storage engine khác InnoDB, có thể xem xét các yếu tố sau:</p><ul><li><strong>Giao dịch</strong>: Nếu kịch bản kinh doanh là OLTP, thì InnoDB là storage engine được ưu tiên. Nếu không cần hỗ trợ giao dịch và chủ yếu là các thao tác SELECT và INSERT, MyISAM là lựa chọn tốt. Vì vậy, nếu MySQL được triển khai theo mô hình chủ - phụ và tách biệt đọc/ghi, có thể làm như sau: nút chính chỉ hỗ trợ ghi, bộ máy mặc định là InnoDB; nút phụ chỉ hỗ trợ đọc, bộ máy mặc định là MyISAM.</li><li><strong>Đồng thời</strong>: MyISAM chỉ hỗ trợ khóa cấp bảng, trong khi InnoDB hỗ trợ khóa cấp hàng. Do đó, InnoDB có hiệu suất đồng thời cao hơn.</li><li><strong>Khóa ngoại</strong>: InnoDB hỗ trợ khóa ngoại.</li><li><strong>Sao lưu</strong>: InnoDB hỗ trợ sao lưu nóng trực tuyến.</li><li><strong>Phục hồi sau sự cố</strong>: Khả năng hư hỏng sau sự cố của MyISAM cao hơn nhiều so với InnoDB, và tốc độ phục hồi cũng chậm hơn.</li><li><strong>Tính năng khác</strong>: MyISAM hỗ trợ bảng nén và chỉ mục dữ liệu không gian.</li></ul><h2 id="gioi-thieu-ve-innodb" tabindex="-1"><a class="header-anchor" href="#gioi-thieu-ve-innodb"><span>Giới thiệu về InnoDB</span></a></h2><p>InnoDB là storage engine mặc định từ phiên bản MySQL 5.5 trở đi. Chỉ nên sử dụng storage engine khác khi cần các tính năng mà InnoDB không hỗ trợ.</p><p>InnoDB cũng sử dụng cây B+ (B+Tree) làm cấu trúc chỉ mục, nhưng cách thực hiện cụ thể rất khác so với MyISAM. Trong MyISAM, tệp chỉ mục và tệp dữ liệu là tách biệt, tệp chỉ mục chỉ lưu trữ địa chỉ của bản ghi dữ liệu. Trong <strong>InnoDB, tệp dữ liệu của bảng chính là một cấu trúc chỉ mục B+Tree</strong>. Các nút lá (leaf node) của cây này chứa toàn bộ bản ghi dữ liệu. <strong>Chỉ mục này sử dụng khóa chính của bảng làm khóa</strong>, do đó, <strong>tệp dữ liệu của bảng InnoDB chính là chỉ mục chính</strong>.</p><p>InnoDB sử dụng MVCC (Multi-Version Concurrency Control) để hỗ trợ khả năng xử lý đồng thời cao, và thực hiện bốn mức độ cô lập tiêu chuẩn. Mức độ mặc định là đọc lặp lại (REPEATABLE READ) và sử dụng khóa khoảng (next-key locking) để ngăn chặn hiện tượng đọc ảo.</p><p>InnoDB được xây dựng dựa trên chỉ mục nhóm (clustered index), khác biệt lớn so với các storage engine khác. Dữ liệu được lưu trong chỉ mục, giúp tránh việc đọc từ đĩa trực tiếp, do đó cải thiện hiệu suất truy vấn.</p><p>InnoDB đã thực hiện nhiều tối ưu nội bộ, bao gồm đọc dữ liệu từ đĩa theo dự đoán, chỉ mục băm thích ứng tự động tạo để tăng tốc độ đọc, và vùng đệm chèn giúp tăng tốc độ chèn dữ liệu.</p><p>InnoDB hỗ trợ sao lưu nóng trực tuyến thực sự. Các storage engine khác không hỗ trợ sao lưu nóng trực tuyến; để có được chế độ xem nhất quán, cần phải dừng tất cả các thao tác ghi vào bảng, và trong môi trường đọc ghi hỗn hợp, việc dừng ghi cũng có thể đồng nghĩa với việc dừng đọc.</p><h3 id="cau-truc-tep-vat-ly-cua-innodb" tabindex="-1"><a class="header-anchor" href="#cau-truc-tep-vat-ly-cua-innodb"><span>Cấu trúc tệp vật lý của InnoDB:</span></a></h3><ul><li><strong>Tệp <code>.frm</code></strong>: Chứa thông tin siêu dữ liệu liên quan đến bảng, bao gồm thông tin định nghĩa cấu trúc bảng.</li><li><strong>Tệp <code>.ibd</code> hoặc <code>.ibdata</code></strong>: Chứa dữ liệu của InnoDB. Có hai cách lưu trữ dữ liệu InnoDB có thể được cấu hình: <ul><li><strong>Không gian bảng riêng lẻ (file-per-table)</strong>: Sử dụng tệp <code>.ibd</code>, mỗi bảng có một tệp <code>.ibd</code>.</li><li><strong>Không gian bảng chia sẻ (shared-tablespace)</strong>: Sử dụng tệp <code>.ibdata</code>, tất cả các bảng dùng chung một tệp <code>.ibdata</code> (hoặc nhiều tệp, có thể cấu hình).</li></ul></li></ul><h2 id="kien-truc-luu-tru-innodb" tabindex="-1"><a class="header-anchor" href="#kien-truc-luu-tru-innodb"><span>Kiến trúc lưu trữ InnoDB</span></a></h2><figure><img src="https://raw.githubusercontent.com/vanhung4499/images/master/snap/202406241406713.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>Kiến trúc lưu trữ của InnoDB được chia thành cấu trúc bộ nhớ và cấu trúc đĩa.</p><h3 id="cau-truc-bo-nho-cua-innodb" tabindex="-1"><a class="header-anchor" href="#cau-truc-bo-nho-cua-innodb"><span>Cấu trúc bộ nhớ của InnoDB:</span></a></h3><ul><li><strong>Buffer Pool</strong>: Vùng đệm chính lưu trữ dữ liệu và chỉ mục được đọc từ đĩa.</li><li><strong>Change Buffer</strong>: Vùng đệm thay đổi lưu trữ các thay đổi đối với chỉ mục không duy nhất.</li><li><strong>Adaptive Hash Index</strong>: Chỉ mục băm thích ứng tự động tạo để tăng tốc độ truy vấn.</li><li><strong>Log Buffer</strong>: Vùng đệm ghi lại các thay đổi trước khi được ghi vào tệp nhật ký.</li></ul><h3 id="cau-truc-đia-cua-innodb" tabindex="-1"><a class="header-anchor" href="#cau-truc-đia-cua-innodb"><span>Cấu trúc đĩa của InnoDB:</span></a></h3><ul><li><strong>Tablespace</strong>: Không gian lưu trữ các tệp dữ liệu và chỉ mục.</li><li><strong>Doublewrite Buffer</strong>: Vùng đệm ghi đôi để đảm bảo tính toàn vẹn dữ liệu.</li><li><strong>Redo log</strong>: Nhật ký ghi lại các thay đổi để phục hồi sau sự cố.</li><li><strong>Undo log</strong>: Nhật ký hoàn tác giúp hỗ trợ giao dịch và khôi phục trạng thái trước đó của dữ liệu.</li></ul><p>InnoDB mang lại nhiều lợi ích về hiệu suất và độ tin cậy nhờ các tính năng và cấu trúc lưu trữ tiên tiến.</p><h2 id="khong-gian-bang-innodb" tabindex="-1"><a class="header-anchor" href="#khong-gian-bang-innodb"><span>Không gian bảng InnoDB</span></a></h2><figure><img src="https://raw.githubusercontent.com/vanhung4499/images/master/snap/202406241406812.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h3 id="dong-row" tabindex="-1"><a class="header-anchor" href="#dong-row"><span>Dòng (Row)</span></a></h3><p>Các bản ghi trong bảng cơ sở dữ liệu được lưu trữ theo dòng (row), mỗi dòng bản ghi có cấu trúc lưu trữ khác nhau tùy thuộc vào định dạng dòng. Sau này chúng ta sẽ giới thiệu chi tiết về định dạng dòng của InnoDB, đây cũng là nội dung chính của bài viết này.</p><h3 id="trang-page" tabindex="-1"><a class="header-anchor" href="#trang-page"><span>Trang (Page)</span></a></h3><p>Bản ghi được lưu trữ theo dòng, nhưng việc đọc cơ sở dữ liệu không phải theo &quot;dòng&quot;, vì nếu vậy mỗi lần đọc (một lần thao tác I/O) chỉ xử lý một dòng dữ liệu, hiệu quả sẽ rất thấp. Do đó, <strong>dữ liệu của InnoDB được đọc và ghi theo đơn vị &quot;trang&quot;</strong>. Điều này có nghĩa là khi cần đọc một bản ghi, không phải đọc chỉ một dòng từ đĩa, mà là đọc cả một trang vào bộ nhớ.</p><p><strong>Mặc định mỗi trang có kích thước 16KB</strong>, có nghĩa là đảm bảo không gian lưu trữ liên tục tối đa 16KB. Trang là đơn vị quản lý nhỏ nhất của đĩa trong storage engine InnoDB, nghĩa là mỗi lần cơ sở dữ liệu đọc ghi ít nhất là 16KB, đọc từ đĩa vào bộ nhớ ít nhất là 16K, và ghi từ bộ nhớ ra đĩa ít nhất là 16K.</p><p>Có nhiều loại trang, phổ biến nhất là trang dữ liệu, trang nhật ký undo, trang tràn, v.v. Các bản ghi trong bảng được quản lý bởi &quot;trang dữ liệu&quot;, cấu trúc của trang dữ liệu không được đề cập chi tiết ở đây. Bạn có thể tham khảo bài viết này để biết thêm chi tiết: <a href="https://xiaolincoding.com/mysql/index/page.html" target="_blank" rel="noopener noreferrer">Thay đổi góc nhìn về cây B+</a>.</p><p>Nói chung, bạn chỉ cần biết các bản ghi trong bảng được lưu trữ trong &quot;trang dữ liệu&quot;.</p><h3 id="vung-extent" tabindex="-1"><a class="header-anchor" href="#vung-extent"><span>Vùng (Extent)</span></a></h3><p>Chúng ta biết rằng storage engine InnoDB tổ chức dữ liệu bằng cây B+ (B+Tree). Trong cây B+, mỗi tầng được kết nối bằng danh sách liên kết hai chiều. Nếu phân bổ không gian lưu trữ theo đơn vị trang, vị trí vật lý của hai trang liền kề trong danh sách liên kết có thể không liên tiếp, có thể rất xa nhau, điều này dẫn đến nhiều thao tác I/O ngẫu nhiên, rất chậm.</p><p>Giải pháp rất đơn giản, làm cho vị trí vật lý của các trang liền kề trong danh sách liên kết cũng liền kề, như vậy có thể sử dụng I/O tuần tự. Điều này cải thiện hiệu suất khi thực hiện các truy vấn phạm vi (quét các nút lá).</p><p>Cách cụ thể để giải quyết vấn đề này là gì?</p><p><strong>Khi lượng dữ liệu trong bảng lớn, việc phân bổ không gian cho một chỉ mục không còn theo đơn vị trang, mà theo đơn vị vùng (extent). Mỗi vùng có kích thước 1MB, đối với trang 16KB, 64 trang liên tiếp sẽ tạo thành một vùng. Điều này làm cho vị trí vật lý của các trang liền kề trong danh sách liên kết cũng liền kề, và có thể sử dụng I/O tuần tự</strong>.</p><h3 id="đoan-segment" tabindex="-1"><a class="header-anchor" href="#đoan-segment"><span>Đoạn (Segment)</span></a></h3><p>Không gian bảng được tạo thành từ các đoạn (segment), mỗi đoạn gồm nhiều vùng (extent). Các đoạn thường được chia thành đoạn dữ liệu, đoạn chỉ mục và đoạn hoàn tác.</p><ul><li><strong>Đoạn chỉ mục</strong>: Chứa các vùng của các nút không phải lá của cây B+.</li><li><strong>Đoạn dữ liệu</strong>: Chứa các vùng của các nút lá của cây B+.</li><li><strong>Đoạn hoàn tác</strong>: Chứa các vùng của dữ liệu hoàn tác.</li></ul><p>Vậy là chúng ta đã hoàn thành việc mô tả cấu trúc của không gian bảng. Tiếp theo, chúng ta sẽ nói chi tiết về định dạng dòng của InnoDB.</p><p>Việc giới thiệu vòng quanh này nhằm giúp bạn hiểu dòng bản ghi được lưu trữ ở tệp nào và khu vực nào trong không gian bảng này, từ góc nhìn từ trên xuống. Điều này giúp bạn hiểu rõ hơn và không thấy mơ hồ.</p><h2 id="cau-truc-bo-nho-innodb" tabindex="-1"><a class="header-anchor" href="#cau-truc-bo-nho-innodb"><span>Cấu trúc bộ nhớ InnoDB</span></a></h2><h3 id="bo-đem-buffer-pool" tabindex="-1"><a class="header-anchor" href="#bo-đem-buffer-pool"><span>Bộ đệm (Buffer Pool)</span></a></h3><figure><img src="https://raw.githubusercontent.com/vanhung4499/images/master/snap/202406241416178.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>Bộ đệm dùng để tăng tốc độ truy cập và chỉnh sửa dữ liệu bằng cách lưu trữ dữ liệu nóng trong bộ nhớ, giảm thiểu tối đa I/O từ đĩa và tăng tốc độ đọc và ghi dữ liệu nóng.</p><p>Dữ liệu trong Buffer Pool được lưu trữ theo đơn vị trang và được quản lý bằng cấu trúc danh sách liên kết đơn theo đơn vị trang. Do giới hạn của bộ nhớ, Buffer Pool chỉ có thể chứa được dữ liệu nóng nhất. Buffer Pool sử dụng thuật toán LRU (Least Recently Used) để loại bỏ dữ liệu không nóng.</p><p>Dựa trên nguyên lý cục bộ thời gian và không gian, Buffer Pool lưu trữ các trang dữ liệu hoạt động hiện tại bằng cách sử dụng cơ chế đọc trước (Read-ahead) để lưu trữ các trang dữ liệu gần dữ liệu mục tiêu.</p><p>Cơ chế đọc trước dẫn đến vấn đề đọc trước thất bại. InnoDB sử dụng cơ chế phân chia thế hệ để giải quyết vấn đề này: chia Buffer Pool thành hai phần là New SubList và Old SubList, đặt các trang dữ liệu mới đọc vào đầu Old SubList, các trang dữ liệu trong Old SubList được truy cập lại sẽ được đặt vào đầu New SubList; các trang dữ liệu lạnh thất bại trong việc đọc trước sẽ nhanh chóng bị loại bỏ khỏi Old SubList mà không ảnh hưởng đến dữ liệu nóng trong New SubList.</p><p>InnoDB sử dụng cơ chế cửa sổ thời gian (Time Window) để giải quyết vấn đề ô nhiễm bộ đệm: đối với các trang dữ liệu trong Old SubList, chúng phải ở lại Old SubList trong một khoảng thời gian nhất định rồi mới được chuyển vào New SubList nếu được truy cập lại. Cửa sổ mặc định là 1 giây.</p><p>Đối với truy vấn dữ liệu trong Buffer Pool, InnoDB sẽ đọc và trả về trực tiếp; đối với sửa đổi dữ liệu trong Buffer Pool, InnoDB sẽ sửa trực tiếp trong Buffer Pool và ghi sửa đổi vào redo Log. Khi trang dữ liệu bị thuật toán LRU loại bỏ, nó sẽ được ghi vào đĩa, nếu hệ thống gặp sự cố trước khi được ghi vào đĩa, sẽ sử dụng redo Log để khôi phục khi khởi động lại.</p><h3 id="bo-đem-thay-đoi-change-buffer" tabindex="-1"><a class="header-anchor" href="#bo-đem-thay-đoi-change-buffer"><span>Bộ đệm thay đổi (Change Buffer)</span></a></h3><figure><img src="https://raw.githubusercontent.com/vanhung4499/images/master/snap/202406241416527.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>Change Buffer dùng để tăng tốc độ ghi vào chỉ mục thứ cấp của dữ liệu không nóng. Do tính không liên tục của dữ liệu chỉ mục thứ cấp, việc sửa đổi chỉ mục thứ cấp yêu cầu I/O đĩa thường xuyên, tiêu tốn nhiều hiệu năng. Change Buffer lưu trữ các thao tác sửa đổi chỉ mục thứ cấp và ghi vào redo log. Khi Change Buffer đạt đến một lượng nhất định hoặc hệ thống ít bận rộn, nó sẽ thực hiện thao tác <code>ibuf merge</code> để ghi sửa đổi vào đĩa. Change Buffer có vùng lưu trữ bền bỉ trong không gian bảng hệ thống.</p><p>Kích thước Change Buffer mặc định chiếm 25% Buffer Pool, được khởi tạo khi khởi động máy chủ. Cấu trúc vật lý của nó là một cây B-Tree gọi là <code>ibuf</code>. Điều kiện sử dụng Change Buffer là:</p><ul><li>InnoDB bật <code>innodb_change_buffering</code> và bảng hiện tại không có thao tác <code>flush</code>.</li><li>Chỉ sửa đổi các nút lá của cây chỉ mục thứ cấp và trang chỉ mục không nằm trong Buffer Pool.</li><li>Đối với chỉ mục thứ cấp duy nhất, chỉ có thao tác xóa có thể được lưu vào bộ đệm.</li></ul><p>Thời điểm thực hiện <code>ibuf merge</code>:</p><ul><li>Khi người dùng sử dụng chỉ mục thứ cấp để truy vấn.</li><li>Khi dự đoán rằng không gian trang sẽ không đủ khi lưu trữ thao tác chèn, có thể dẫn đến phân chia trang chỉ mục.</li><li>Khi thao tác lưu trữ lần này dẫn đến phân chia trang cây ibuf và kích thước Change Buffer vượt quá giới hạn sau khi phân loại.</li><li>Khi luồng master thực hiện lệnh <code>merge</code>.</li><li>Khi người dùng thực hiện thao tác <code>flush</code> trên bảng.</li></ul><h3 id="chi-muc-bam-thich-nghi-adaptive-hash-index" tabindex="-1"><a class="header-anchor" href="#chi-muc-bam-thich-nghi-adaptive-hash-index"><span>Chỉ mục băm thích nghi (Adaptive Hash Index)</span></a></h3><p>Chỉ mục băm thích nghi (Adaptive Hash Index, AHI) dùng để tăng tốc độ truy vấn cho các trang dữ liệu nóng. Khi sử dụng chỉ mục cụm (clustered index) để định vị trang dữ liệu, cần đi từ nút gốc đến nút lá của cây chỉ mục, thường mất 3-4 lần truy vấn. InnoDB phân tích việc sử dụng chỉ mục và các trường chỉ mục để tạo hoặc xóa chỉ mục băm một cách tự động.</p><p>AHI áp dụng cho các trang dữ liệu và chỉ mục được truy vấn thường xuyên. Vì trang dữ liệu là một phần của chỉ mục cụm, AHI được xây dựng trên chỉ mục. <strong>Đối với chỉ mục thứ cấp, nếu trúng AHI, sẽ lấy trực tiếp con trỏ bản ghi từ chỉ mục thứ cấp trong AHI và sau đó theo khóa chính tìm dữ liệu dọc theo chỉ mục cụm; nếu truy vấn chỉ mục cụm cũng trúng AHI, sẽ trả về trực tiếp con trỏ bản ghi của trang dữ liệu mục tiêu, từ đó có thể định vị trang dữ liệu trực tiếp theo con trỏ bản ghi</strong>.</p><p>Kích thước AHI là 1/64 của Buffer Pool. Từ MySQL 5.7 trở đi, AHI hỗ trợ phân vùng để giảm cạnh tranh trên khóa AHI toàn cục, mặc định là 8 phân vùng.</p><h3 id="bo-đem-nhat-ky-log-buffer" tabindex="-1"><a class="header-anchor" href="#bo-đem-nhat-ky-log-buffer"><span>Bộ đệm nhật ký (Log Buffer)</span></a></h3><p>Bộ đệm nhật ký (Log Buffer) được dùng để lưu trữ tạm thời các dữ liệu nhật ký cần ghi vào đĩa. Tất cả các thao tác sửa đổi của InnoDB sẽ được ghi vào các tệp nhật ký như redo log, undo log. Nếu mỗi lần sửa đổi đều được ghi trực tiếp vào đĩa, sẽ gây ra rất nhiều I/O. Log Buffer tối ưu vấn đề này bằng cách lưu trữ các thao tác sửa đổi trong vùng nhớ này trước, sau đó định kỳ ghi hàng loạt vào đĩa.</p><p>Kích thước của bộ đệm nhật ký có thể được điều chỉnh bằng cấu hình <code>innodb_log_buffer_size</code>, mặc định là 16MB.</p><h2 id="myisam" tabindex="-1"><a class="header-anchor" href="#myisam"><span>MyISAM</span></a></h2><p>MyISAM là hệ thống lưu trữ mặc định của MySQL trước phiên bản 5.5.</p><p>MyISAM được thiết kế đơn giản với dữ liệu được lưu trữ theo định dạng nén. MyISAM thích hợp cho dữ liệu chỉ đọc, hoặc bảng nhỏ có thể chấp nhận các thao tác sửa chữa.</p><p>MyISAM sử dụng cấu trúc B+Tree cho chỉ mục, trong đó <strong>nút lá của trường dữ liệu lưu trữ địa chỉ của các bản ghi dữ liệu</strong>.</p><p>MyISAM cung cấp nhiều tính năng như: chỉ mục toàn văn, bảng nén, và các hàm không gian. Tuy nhiên, MyISAM không hỗ trợ giao dịch và khóa cấp hàng. MyISAM cũng không hỗ trợ khôi phục an toàn sau khi hệ thống gặp sự cố.</p><p>Cấu trúc tệp vật lý của MyISAM:</p><ul><li>Tệp <code>.frm</code>: lưu trữ thông tin siêu dữ liệu liên quan đến bảng, bao gồm định nghĩa cấu trúc bảng.</li><li>Tệp <code>.MYD</code> (<code>MYData</code>): dành riêng cho MyISAM để lưu trữ dữ liệu của bảng MyISAM.</li><li>Tệp <code>.MYI</code> (<code>MYIndex</code>): dành riêng cho MyISAM để lưu trữ thông tin liên quan đến chỉ mục của bảng MyISAM.</li></ul><h2 id="so-sanh-innodb-va-myisam" tabindex="-1"><a class="header-anchor" href="#so-sanh-innodb-va-myisam"><span>So sánh InnoDB và MyISAM</span></a></h2><p>Bảng so sánh giữa InnoDB và MyISAM:</p><table><thead><tr><th>Đối chiếu</th><th>MyISAM</th><th>InnoDB</th></tr></thead><tbody><tr><td>Khóa ngoại</td><td>Không hỗ trợ</td><td>Hỗ trợ</td></tr><tr><td>Giao dịch</td><td>Không hỗ trợ</td><td>Hỗ trợ</td></tr><tr><td>Khóa</td><td>Hỗ trợ khóa cấp bảng</td><td>Hỗ trợ khóa cấp bảng và khóa cấp hàng</td></tr><tr><td>Chỉ mục</td><td>Sử dụng chỉ mục không phân cụm</td><td>Chỉ mục chính sử dụng chỉ mục phân cụm để cải thiện hiệu suất IO</td></tr><tr><td>Không gian bảng</td><td>Nhỏ</td><td>Lớn</td></tr><tr><td>Điểm tập trung</td><td>Hiệu suất</td><td>Giao dịch</td></tr><tr><td>Bộ đếm</td><td>Duy trì bộ đếm, hiệu suất <code>SELECT COUNT(*)</code> là <code>O(1)</code></td><td>Không duy trì bộ đếm, cần quét toàn bộ bảng</td></tr></tbody></table><p>InnoDB thường được chọn khi cần hỗ trợ giao dịch, khóa cấp hàng và khả năng khôi phục sau sự cố, trong khi MyISAM có thể được sử dụng cho các bảng chỉ đọc hoặc bảng nhỏ nơi hiệu suất và không gian lưu trữ là ưu tiên chính.</p>`,89),e=[a];function g(o,s){return t(),h("div",null,e)}const l=n(i,[["render",g],["__file","engine.html.vue"]]),d=JSON.parse('{"path":"/database/mysql/engine.html","title":"MySQL Storage Engine","lang":"en-US","frontmatter":{"title":"MySQL Storage Engine","tags":["mysql"],"categories":["mysql"],"icon":"devicon:mysql","order":4,"description":"MySQL Storage Engine Các storage engine trong MySQL Trong hệ thống tệp, MySQL lưu mỗi cơ sở dữ liệu (cũng có thể gọi là schema) dưới dạng một thư mục con trong thư mục dữ liệu. ...","head":[["meta",{"property":"og:url","content":"https://vanhung4499.github.io/database/mysql/engine.html"}],["meta",{"property":"og:site_name","content":"VanHung4499"}],["meta",{"property":"og:title","content":"MySQL Storage Engine"}],["meta",{"property":"og:description","content":"MySQL Storage Engine Các storage engine trong MySQL Trong hệ thống tệp, MySQL lưu mỗi cơ sở dữ liệu (cũng có thể gọi là schema) dưới dạng một thư mục con trong thư mục dữ liệu. ..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://raw.githubusercontent.com/vanhung4499/images/master/snap/202406241406713.png"}],["meta",{"property":"og:locale","content":"en-US"}],["meta",{"property":"og:updated_time","content":"2024-06-28T15:54:38.000Z"}],["meta",{"property":"article:author","content":"Hung Nguyen"}],["meta",{"property":"article:tag","content":"mysql"}],["meta",{"property":"article:modified_time","content":"2024-06-28T15:54:38.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"MySQL Storage Engine\\",\\"image\\":[\\"https://raw.githubusercontent.com/vanhung4499/images/master/snap/202406241406713.png\\",\\"https://raw.githubusercontent.com/vanhung4499/images/master/snap/202406241406812.png\\",\\"https://raw.githubusercontent.com/vanhung4499/images/master/snap/202406241416178.png\\",\\"https://raw.githubusercontent.com/vanhung4499/images/master/snap/202406241416527.png\\"],\\"dateModified\\":\\"2024-06-28T15:54:38.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Hung Nguyen\\",\\"url\\":\\"https://vanhung4499.github.io\\"}]}"]]},"headers":[{"level":2,"title":"Các storage engine trong MySQL","slug":"cac-storage-engine-trong-mysql","link":"#cac-storage-engine-trong-mysql","children":[]},{"level":2,"title":"Các thao tác liên quan đến storage engine","slug":"cac-thao-tac-lien-quan-đen-storage-engine","link":"#cac-thao-tac-lien-quan-đen-storage-engine","children":[{"level":3,"title":"Lệnh show storage engine","slug":"lenh-show-storage-engine","link":"#lenh-show-storage-engine","children":[]}]},{"level":2,"title":"Các lệnh thiết lập storage engine","slug":"cac-lenh-thiet-lap-storage-engine","link":"#cac-lenh-thiet-lap-storage-engine","children":[{"level":3,"title":"Lệnh tạo và thay đổi storage engine","slug":"lenh-tao-va-thay-đoi-storage-engine","link":"#lenh-tao-va-thay-đoi-storage-engine","children":[]}]},{"level":2,"title":"Giới thiệu về các storage engine MySQL","slug":"gioi-thieu-ve-cac-storage-engine-mysql","link":"#gioi-thieu-ve-cac-storage-engine-mysql","children":[{"level":3,"title":"Các storage engine tích hợp trong MySQL","slug":"cac-storage-engine-tich-hop-trong-mysql","link":"#cac-storage-engine-tich-hop-trong-mysql","children":[]},{"level":3,"title":"Cách chọn storage engine phù hợp","slug":"cach-chon-storage-engine-phu-hop","link":"#cach-chon-storage-engine-phu-hop","children":[]}]},{"level":2,"title":"Giới thiệu về InnoDB","slug":"gioi-thieu-ve-innodb","link":"#gioi-thieu-ve-innodb","children":[{"level":3,"title":"Cấu trúc tệp vật lý của InnoDB:","slug":"cau-truc-tep-vat-ly-cua-innodb","link":"#cau-truc-tep-vat-ly-cua-innodb","children":[]}]},{"level":2,"title":"Kiến trúc lưu trữ InnoDB","slug":"kien-truc-luu-tru-innodb","link":"#kien-truc-luu-tru-innodb","children":[{"level":3,"title":"Cấu trúc bộ nhớ của InnoDB:","slug":"cau-truc-bo-nho-cua-innodb","link":"#cau-truc-bo-nho-cua-innodb","children":[]},{"level":3,"title":"Cấu trúc đĩa của InnoDB:","slug":"cau-truc-đia-cua-innodb","link":"#cau-truc-đia-cua-innodb","children":[]}]},{"level":2,"title":"Không gian bảng InnoDB","slug":"khong-gian-bang-innodb","link":"#khong-gian-bang-innodb","children":[{"level":3,"title":"Dòng (Row)","slug":"dong-row","link":"#dong-row","children":[]},{"level":3,"title":"Trang (Page)","slug":"trang-page","link":"#trang-page","children":[]},{"level":3,"title":"Vùng (Extent)","slug":"vung-extent","link":"#vung-extent","children":[]},{"level":3,"title":"Đoạn (Segment)","slug":"đoan-segment","link":"#đoan-segment","children":[]}]},{"level":2,"title":"Cấu trúc bộ nhớ InnoDB","slug":"cau-truc-bo-nho-innodb","link":"#cau-truc-bo-nho-innodb","children":[{"level":3,"title":"Bộ đệm (Buffer Pool)","slug":"bo-đem-buffer-pool","link":"#bo-đem-buffer-pool","children":[]},{"level":3,"title":"Bộ đệm thay đổi (Change Buffer)","slug":"bo-đem-thay-đoi-change-buffer","link":"#bo-đem-thay-đoi-change-buffer","children":[]},{"level":3,"title":"Chỉ mục băm thích nghi (Adaptive Hash Index)","slug":"chi-muc-bam-thich-nghi-adaptive-hash-index","link":"#chi-muc-bam-thich-nghi-adaptive-hash-index","children":[]},{"level":3,"title":"Bộ đệm nhật ký (Log Buffer)","slug":"bo-đem-nhat-ky-log-buffer","link":"#bo-đem-nhat-ky-log-buffer","children":[]}]},{"level":2,"title":"MyISAM","slug":"myisam","link":"#myisam","children":[]},{"level":2,"title":"So sánh InnoDB và MyISAM","slug":"so-sanh-innodb-va-myisam","link":"#so-sanh-innodb-va-myisam","children":[]}],"git":{"createdTime":1719590078000,"updatedTime":1719590078000,"contributors":[{"name":"Hung Nguyen Van","email":"vanhung4499@gmail.com","commits":1}]},"readingTime":{"minutes":16.82,"words":5047},"filePathRelative":"database/mysql/engine.md","localizedDate":"June 28, 2024","excerpt":"\\n<h2>Các storage engine trong MySQL</h2>\\n<p>Trong hệ thống tệp, MySQL lưu mỗi cơ sở dữ liệu (cũng có thể gọi là schema) dưới dạng một thư mục con trong thư mục dữ liệu. Khi tạo bảng, MySQL sẽ tạo một tệp <code>.frm</code> cùng tên với bảng trong thư mục cơ sở dữ liệu để lưu định nghĩa của bảng. Vì MySQL sử dụng các thư mục và tệp hệ thống tệp để lưu định nghĩa cơ sở dữ liệu và bảng, tính nhạy cảm chữ hoa chữ thường phụ thuộc vào nền tảng cụ thể. Trong Windows, tính nhạy cảm chữ hoa chữ thường không được áp dụng; trong các hệ thống tương tự Unix, tính nhạy cảm chữ hoa chữ thường được áp dụng. <strong>Các storage engine khác nhau lưu trữ dữ liệu và chỉ mục theo cách khác nhau, nhưng định nghĩa bảng thì được xử lý thống nhất ở tầng dịch vụ của MySQL.</strong></p>","autoDesc":true}');export{l as comp,d as data};
