import{_ as a,o as e,c as s,a as n}from"./app-BRTHG7K9.js";const p={},t=n(`<h1 id="http-接口签名-防篡改" tabindex="-1"><a class="header-anchor" href="#http-接口签名-防篡改"><span>HTTP 接口签名（防篡改）</span></a></h1><p><a href="https://github.com/YunaiV/ruoyi-vue-pro/blob/master/yudao-framework/yudao-spring-boot-starter-protection/" target="_blank" rel="noopener noreferrer"><code>yudao-spring-boot-starter-protection</code></a> 技术组件，由它的 <a href="https://github.com/YunaiV/ruoyi-vue-pro/blob/master/yudao-framework/yudao-spring-boot-starter-protection/src/main/java/cn/iocoder/yudao/framework/signature/" target="_blank" rel="noopener noreferrer"><code>signature</code></a> 包，提供 HTTP 接口签名特性，提高安全性。</p><p>例如说：项目给第三方提供 HTTP 接口时，为了提高对接中数据传输的安全性（防止请求参数被篡改），同时校验调用方的有效性，通常都需要增加签名 sign。</p><p>市面上也有非常多的案例，例如说：</p><ul><li><a href="https://pay.weixin.qq.com/wiki/doc/api/jsapi.php?chapter=4_3" target="_blank" rel="noopener noreferrer">《微信支付 —— 安全规范》</a></li><li><a href="https://opendocs.alipay.com/common/02khjm" target="_blank" rel="noopener noreferrer">《支付宝 —— 签名 》</a></li></ul><h2 id="_1-实现原理" tabindex="-1"><a class="header-anchor" href="#_1-实现原理"><span><a href="#_1-%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86">#</a> 1. 实现原理</span></a></h2><p>在 Controller 的方法上，添加 <code>@ApiSignature</code> 注解，声明它需要签名。</p><p>然后，通过 AOP 切面，ApiSignatureAspect 对这些方法进行拦截，校验签名是否正确。它的签名算法如下：</p><div class="language-" data-ext="" data-title=""><pre class="shiki shiki-themes one-dark-pro one-dark-pro vp-code" style="background-color:#282c34;--shiki-dark-bg:#282c34;color:#abb2bf;--shiki-dark:#abb2bf;" tabindex="0"><code><span class="line"><span>// ApiSignatureAspect.java</span></span>
<span class="line"><span></span></span>
<span class="line"><span>String serverSignatureString = buildSignatureString(signature, request, appSecret)</span></span>
<span class="line"><span>DigestUtil.sha256Hex(serverSignatureString);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    private String buildSignatureString(ApiSignature signature, HttpServletRequest request, String appSecret) {</span></span>
<span class="line"><span>        SortedMap&lt;String, String&gt; parameterMap = getRequestParameterMap(request); // 请求头</span></span>
<span class="line"><span>        SortedMap&lt;String, String&gt; headerMap = getRequestHeaderMap(signature, request); // 请求参数</span></span>
<span class="line"><span>        String requestBody = StrUtil.nullToDefault(ServletUtils.getBody(request), &quot;&quot;); // 请求体</span></span>
<span class="line"><span>        return MapUtil.join(parameterMap, &quot;&amp;&quot;, &quot;=&quot;)</span></span>
<span class="line"><span>                + requestBody</span></span>
<span class="line"><span>                + MapUtil.join(headerMap, &quot;&amp;&quot;, &quot;=&quot;)</span></span>
<span class="line"><span>                + appSecret;</span></span>
<span class="line"><span>    }</span></span></code></pre></div><p>① 将请求头、请求体、请求参数，按照一定顺序排列，然后添加密钥，获得需要进行签名的字符串。</p><p>其中，每个调用方 <code>appId</code> 对应一个唯一 <code>appSecret</code>，通过在 Redis 配置，它对应 key 为 <code>api_signature_app</code> 的 HASH 结构，hashKey 为 <code>appId</code>。</p><p>② 之后，通过 SHA256 进行加密，得到签名 sign。</p><hr><p>注意：第三方调用时，每次请求 Header 需要带上 <code>appId</code>、<code>timestamp</code>、<code>nonce</code>、<code>sign</code> 四个参数：</p><ul><li><code>appId</code>：调用方的唯一标识。</li><li><code>timestamp</code>：请求时的时间戳。</li><li><code>nonce</code>：用于请求的防重放攻击，每次请求唯一，例如说 UUID。</li><li><code>sign</code>：HTTP 签名。</li></ul><p>疑问：为什么使用请求 Header 传参？</p><p>避免这四个参数，在请求 QueryString、Request Body 可能重复的问题！</p><h2 id="_2-使用示例" tabindex="-1"><a class="header-anchor" href="#_2-使用示例"><span><a href="#_2-%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B">#</a> 2. 使用示例</span></a></h2><p>① 在需要使用的 <code>xxx-biz</code> 模块的 ，引入 <code>yudao-spring-boot-starter-protection</code> 依赖：</p><div class="language-" data-ext="" data-title=""><pre class="shiki shiki-themes one-dark-pro one-dark-pro vp-code" style="background-color:#282c34;--shiki-dark-bg:#282c34;color:#abb2bf;--shiki-dark:#abb2bf;" tabindex="0"><code><span class="line"><span>&lt;dependency&gt;</span></span>
<span class="line"><span>    &lt;groupId&gt;cn.iocoder.boot&lt;/groupId&gt;</span></span>
<span class="line"><span>    &lt;artifactId&gt;yudao-spring-boot-starter-protection&lt;/artifactId&gt;</span></span>
<span class="line"><span>&lt;/dependency&gt;</span></span></code></pre></div><p>② 在 Redis 添加一个 <code>appId</code> 为 <code>test</code>，密钥为 <code>123456</code> 的配置：</p><div class="language-" data-ext="" data-title=""><pre class="shiki shiki-themes one-dark-pro one-dark-pro vp-code" style="background-color:#282c34;--shiki-dark-bg:#282c34;color:#abb2bf;--shiki-dark:#abb2bf;" tabindex="0"><code><span class="line"><span>hset api_signature_app test 123456</span></span></code></pre></div><p>③ 在 Controller 的方法上，添加 <code>@ApiSignature</code> 注解：</p><div class="language-" data-ext="" data-title=""><pre class="shiki shiki-themes one-dark-pro one-dark-pro vp-code" style="background-color:#282c34;--shiki-dark-bg:#282c34;color:#abb2bf;--shiki-dark:#abb2bf;" tabindex="0"><code><span class="line"><span>// UserController.java</span></span>
<span class="line"><span></span></span>
<span class="line"><span>@GetMapping(&quot;/page&quot;)</span></span>
<span class="line"><span>@Operation(summary = &quot;获得用户分页列表&quot;)</span></span>
<span class="line"><span>@PreAuthorize(&quot;@ss.hasPermission(&#39;system:user:list&#39;)&quot;)</span></span>
<span class="line"><span>@ApiSignature(timeout = 30, timeUnit = TimeUnit.MINUTES) // 关键是此处。ps：设置为 30 分钟，只是为了测试方便，不是必须！</span></span>
<span class="line"><span>public CommonResult&lt;PageResult&lt;UserRespVO&gt;&gt; getUserPage(@Valid UserPageReqVO pageReqVO) {</span></span>
<span class="line"><span>    // ... 省略代码</span></span>
<span class="line"><span>}</span></span></code></pre></div><p>④ 调用该 API 接口，执行成功。如下是一个 IDEA HTTP 的示例：</p><div class="language-" data-ext="" data-title=""><pre class="shiki shiki-themes one-dark-pro one-dark-pro vp-code" style="background-color:#282c34;--shiki-dark-bg:#282c34;color:#abb2bf;--shiki-dark:#abb2bf;" tabindex="0"><code><span class="line"><span>// UserController.http</span></span>
<span class="line"><span></span></span>
<span class="line"><span>GET {{baseUrl}}/system/user/page?pageNo=1&amp;pageSize=10</span></span>
<span class="line"><span>Authorization: Bearer {{token}}</span></span>
<span class="line"><span>appId: test</span></span>
<span class="line"><span>timestamp: 1717494535932</span></span>
<span class="line"><span>nonce: e7eb4265-885d-40eb-ace3-2ecfc34bd639</span></span>
<span class="line"><span>sign: 01e1c3df4d93eafc862753641ebfc1637e70f853733684a139f8b630af5c84cd</span></span>
<span class="line"><span>tenant-id: {{adminTenentId}}</span></span></code></pre></div><ul><li><code>appId</code>、<code>timestamp</code>、<code>nonce</code>、<code>sign</code> 通过请求 Header 传递，避免和请求参数冲突。【必须传递】</li><li><code>timestamp</code>：请求时的时间戳。</li><li><code>nonce</code>：用于请求的防重放攻击，每次请求唯一，例如说 UUID。</li><li><code>sign</code>：HTTP 签名。如果你不知道多少，可以直接 debug ApiSignatureAspect 的 <code>serverSignature</code> 处的代码，进行获得。</li></ul><p>友情提示：强烈建议 ApiSignatureAspect 的实现代码，一共就 100 多行代码。可以通过 ApiSignatureTest 单元测试，直接执行噢！</p>`,28),i=[t];function o(r,c){return e(),s("div",null,i)}const d=a(p,[["render",o],["__file","http-sign.html.vue"]]),g=JSON.parse('{"path":"/project/rouyi-vue-pro/http-sign.html","title":"HTTP 接口签名（防篡改）","lang":"en-US","frontmatter":{"title":"HTTP 接口签名（防篡改）","tags":["project","java","spring-boot","spring-cloud"],"categories":["project"],"order":47,"feed":false,"seo":false,"head":[]},"headers":[{"level":2,"title":"# 1. 实现原理","slug":"_1-实现原理","link":"#_1-实现原理","children":[]},{"level":2,"title":"# 2. 使用示例","slug":"_2-使用示例","link":"#_2-使用示例","children":[]}],"git":{"createdTime":1720365235000,"updatedTime":1720365235000,"contributors":[{"name":"Hung Nguyen Van","email":"vanhung4499@gmail.com","commits":1}]},"readingTime":{"minutes":2.56,"words":769},"filePathRelative":"project/rouyi-vue-pro/http-sign.md","localizedDate":"July 7, 2024"}');export{d as comp,g as data};
