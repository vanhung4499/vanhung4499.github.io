import{_ as a,r as i,o as t,c,b as l,d as n}from"./app-BG8AAbz2.js";const h={},o=n(`<h1 id="thu-gom-rac" tabindex="-1"><a class="header-anchor" href="#thu-gom-rac"><span>Thu gom rác</span></a></h1><blockquote><p>Vì chuỗi, đối tượng và mảng không có kích thước cố định, nên chỉ khi kích thước của chúng được biết, chúng mới có thể được cấp phát bộ nhớ động. Mỗi lần tạo ra một chuỗi, một mảng hoặc một đối tượng trong JavaScript, trình thông dịch phải cấp phát bộ nhớ để lưu trữ thực thể đó. Khi bộ nhớ được cấp phát động như vậy, nó phải được giải phóng để có thể được sử dụng lại. Nếu không, trình thông dịch JavaScript sẽ tiêu thụ hết bộ nhớ có sẵn trong hệ thống và gây ra sự cố hệ thống. - &quot;JavaScript: The Definitive Guide&quot;</p></blockquote><p>Trong các ngôn ngữ như C và C++, việc quản lý bộ nhớ phải được thực hiện thủ công, đây cũng là nguồn gốc của nhiều vấn đề không cần thiết. May mắn thay, khi viết JavaScript, việc cấp phát và thu hồi bộ nhớ đã được tự động quản lý hoàn toàn.</p><p>JavaScript sử dụng <strong>cơ chế thu gom rác tự động</strong> để quản lý bộ nhớ. Cơ chế thu gom rác hoạt động bằng cách sử dụng một bộ thu gom rác để định kỳ tìm ra các biến không còn cần sử dụng và thực hiện việc giải phóng bộ nhớ đã chiếm dụng.</p><blockquote><p>Điều gì được coi là giá trị không còn cần thiết?</p></blockquote><p>Giá trị không còn cần thiết là biến đã kết thúc vòng đời của nó.</p><ul><li><strong>Biến cục bộ</strong>: Trong phạm vi cục bộ, khi một hàm thực thi xong, biến cục bộ không còn cần tồn tại (trừ khi có closure), do đó trình thu gom rác dễ dàng đánh dấu và thu hồi bộ nhớ.</li><li><strong>Biến toàn cục</strong>: Tuy nhiên, vòng đời của biến toàn cục chỉ kết thúc khi trình duyệt gỡ bỏ trang, tức là <strong>biến toàn cục không được coi là biến rác và không được thu hồi</strong>. Vì vậy, khi khai báo một biến toàn cục, chúng ta cần cân nhắc kỹ xem sau khi sử dụng đối tượng này, chúng ta còn cần nó hay không. Nếu không cần thiết nữa, chúng ta nên gán biến này thành <code>null</code>, để khi thu gom rác chạy lần sau, nó có thể giải phóng giá trị trước đó mà biến này đang trỏ tới.</li></ul><h2 id="nguyen-ly" tabindex="-1"><a class="header-anchor" href="#nguyen-ly"><span>Nguyên lý</span></a></h2><p>JavaScript có hai chiến lược để thực hiện thu gom rác:</p><ul><li><a href="#ph%C6%B0%C6%A1ng-ph%C3%A1p-%C4%91%E1%BA%BFm-tham-chi%E1%BA%BFu">Phương pháp đếm tham chiếu</a></li><li><a href="#ph%C6%B0%C6%A1ng-ph%C3%A1p-%C4%91%C3%A1nh-d%E1%BA%A5u-v%C3%A0-thu-h%E1%BB%93i">Phương pháp đánh dấu và thu hồi</a></li></ul><h3 id="phuong-phap-đem-tham-chieu" tabindex="-1"><a class="header-anchor" href="#phuong-phap-đem-tham-chieu"><span>Phương pháp đếm tham chiếu</span></a></h3><p><strong>Phương pháp đếm tham chiếu</strong>: Theo dõi và ghi nhận số lần tham chiếu của mỗi giá trị, khi một biến được khai báo và gán một giá trị kiểu tham chiếu, số lần tham chiếu của giá trị đó là 1, nếu giá trị đó được gán cho một biến khác, số lần tham chiếu tăng lên 1. Ngược lại, nếu biến chứa giá trị đó lại được gán một giá trị khác, số lần tham chiếu giảm đi 1. Khi số lần tham chiếu của một giá trị trở thành 0, có nghĩa là không còn cách nào để truy cập đến giá trị đó nữa, do đó, bộ nhớ mà giá trị đó chiếm giữ có thể được thu hồi. Khi thu gom rác chạy, nó sẽ giải phóng những giá trị có số lần tham chiếu là 0.</p><p>Phương pháp này không thể giải quyết vấn đề vòng lặp tham chiếu, tức là đối tượng <code>a</code> chứa một con trỏ đến <code>b</code>, và đối tượng <code>b</code> cũng chứa một con trỏ đến <code>a</code>. Điều này có thể dẫn đến việc không giải phóng được nhiều bộ nhớ, cũng gọi là rò rỉ bộ nhớ (memory leak), vì số lần tham chiếu của chúng không bao giờ là 0.</p><p>🌰 <strong>Ví dụ</strong>:</p><div class="language-js" data-ext="js" data-title="js"><pre class="shiki shiki-themes one-dark-pro one-dark-pro vp-code" style="background-color:#282c34;--shiki-dark-bg:#282c34;color:#abb2bf;--shiki-dark:#abb2bf;" tabindex="0"><code><span class="line"><span style="color:#C678DD;--shiki-dark:#C678DD;">function</span><span style="color:#61AFEF;--shiki-dark:#61AFEF;"> problem</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">() {</span></span>
<span class="line"><span style="color:#C678DD;--shiki-dark:#C678DD;">  var</span><span style="color:#E06C75;--shiki-dark:#E06C75;"> a</span><span style="color:#56B6C2;--shiki-dark:#56B6C2;"> =</span><span style="color:#C678DD;--shiki-dark:#C678DD;"> new</span><span style="color:#61AFEF;--shiki-dark:#61AFEF;"> Object</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">();</span></span>
<span class="line"><span style="color:#C678DD;--shiki-dark:#C678DD;">  var</span><span style="color:#E06C75;--shiki-dark:#E06C75;"> b</span><span style="color:#56B6C2;--shiki-dark:#56B6C2;"> =</span><span style="color:#C678DD;--shiki-dark:#C678DD;"> new</span><span style="color:#61AFEF;--shiki-dark:#61AFEF;"> Object</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">();</span></span>
<span class="line"><span style="color:#E5C07B;--shiki-dark:#E5C07B;">  a</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">.</span><span style="color:#E06C75;--shiki-dark:#E06C75;">ref</span><span style="color:#56B6C2;--shiki-dark:#56B6C2;"> =</span><span style="color:#E06C75;--shiki-dark:#E06C75;"> b</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#E5C07B;--shiki-dark:#E5C07B;">  b</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">.</span><span style="color:#E06C75;--shiki-dark:#E06C75;">ref</span><span style="color:#56B6C2;--shiki-dark:#56B6C2;"> =</span><span style="color:#E06C75;--shiki-dark:#E06C75;"> a</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">}</span></span></code></pre></div><blockquote><ul><li>Kích thước nông (shallow size): Kích thước của đối tượng bao gồm giá trị nguyên thuỷ và dữ liệu cần thiết khác.</li><li>Kích thước lưu trữ (retained size): Tổng kích thước của đối tượng bao gồm kích thước nông của nó và tất cả các đối tượng mà nó chi phối.</li></ul></blockquote><p>Phương pháp đếm tham chiếu không thể giải quyết vấn đề vòng lặp tham chiếu:</p><div class="language-js" data-ext="js" data-title="js"><pre class="shiki shiki-themes one-dark-pro one-dark-pro vp-code" style="background-color:#282c34;--shiki-dark-bg:#282c34;color:#abb2bf;--shiki-dark:#abb2bf;" tabindex="0"><code><span class="line"><span style="color:#C678DD;--shiki-dark:#C678DD;">function</span><span style="color:#61AFEF;--shiki-dark:#61AFEF;"> fn</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">() {</span></span>
<span class="line"><span style="color:#C678DD;--shiki-dark:#C678DD;">  var</span><span style="color:#E06C75;--shiki-dark:#E06C75;"> x</span><span style="color:#56B6C2;--shiki-dark:#56B6C2;"> =</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;"> {};</span></span>
<span class="line"><span style="color:#C678DD;--shiki-dark:#C678DD;">  var</span><span style="color:#E06C75;--shiki-dark:#E06C75;"> y</span><span style="color:#56B6C2;--shiki-dark:#56B6C2;"> =</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;"> {};</span></span>
<span class="line"><span style="color:#E5C07B;--shiki-dark:#E5C07B;">  x</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">.</span><span style="color:#E06C75;--shiki-dark:#E06C75;">a</span><span style="color:#56B6C2;--shiki-dark:#56B6C2;"> =</span><span style="color:#E06C75;--shiki-dark:#E06C75;"> y</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#E5C07B;--shiki-dark:#E5C07B;">  y</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">.</span><span style="color:#E06C75;--shiki-dark:#E06C75;">a</span><span style="color:#56B6C2;--shiki-dark:#56B6C2;"> =</span><span style="color:#E06C75;--shiki-dark:#E06C75;"> x</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">}</span></span></code></pre></div><h3 id="phuong-phap-đanh-dau-va-xoa" tabindex="-1"><a class="header-anchor" href="#phuong-phap-đanh-dau-va-xoa"><span>Phương pháp đánh dấu và xóa</span></a></h3><p><strong>Phương pháp đánh dấu và xóa</strong>: Khi chương trình thực thi vào một hàm nào đó, một ngữ cảnh thực thi của hàm đó sẽ được tạo ra, và các biến trong ngữ cảnh thực thi này sẽ được đánh dấu là <strong>đang sử dụng</strong>. Lý thuyết là, các biến <strong>đang sử dụng</strong> không thể được giải phóng bộ nhớ. Bởi vì chỉ cần luồng thực thi vào ngữ cảnh thực thi tương ứng, các biến này có thể được sử dụng.</p><p>Quy trình của phương pháp đánh dấu và xóa như sau:</p><ul><li>Trình thu gom rác sẽ đánh dấu tất cả các biến trong bộ nhớ.</li><li>Loại bỏ đánh dấu của các biến trong ngữ cảnh thực thi và các biến được tham chiếu bởi môi trường.</li><li>Các biến vẫn còn đánh dấu sẽ được coi là <strong>sẵn sàng để xóa</strong>.</li><li>Cuối cùng, trình thu gom rác hoàn thành công việc làm sạch bộ nhớ bằng cách hủy các giá trị được đánh dấu và thu hồi không gian bộ nhớ mà chúng chiếm.</li></ul><p>Giải phóng bộ nhớ thủ công:</p><div class="language-js" data-ext="js" data-title="js"><pre class="shiki shiki-themes one-dark-pro one-dark-pro vp-code" style="background-color:#282c34;--shiki-dark-bg:#282c34;color:#abb2bf;--shiki-dark:#abb2bf;" tabindex="0"><code><span class="line"><span style="color:#C678DD;--shiki-dark:#C678DD;">let</span><span style="color:#E06C75;--shiki-dark:#E06C75;"> a</span><span style="color:#56B6C2;--shiki-dark:#56B6C2;"> =</span><span style="color:#D19A66;--shiki-dark:#D19A66;"> 1</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E06C75;--shiki-dark:#E06C75;">a</span><span style="color:#56B6C2;--shiki-dark:#56B6C2;"> =</span><span style="color:#D19A66;--shiki-dark:#D19A66;"> null</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">;</span></span></code></pre></div><p><code>a = null</code> thực ra chỉ là một hoạt động giải phóng tham chiếu, làm cho giá trị mà biến <code>a</code> trước đây tham chiếu mất đi, thoát khỏi ngữ cảnh thực thi. Giá trị này sẽ được tìm thấy và giải phóng trong lần chạy tiếp theo của trình thu gom rác. Việc giải phóng tham chiếu đúng thời điểm là một cách quan trọng để đạt được hiệu suất tốt hơn cho trang web.</p><p>Cơ chế thu gom rác trong trình thông dịch JavaScript là phương pháp đánh dấu và xóa, và tiêu chí để xác định xem một vùng nhớ có thể thu hồi hay không là khả năng truy cập. Điều này là một cải tiến so với phương pháp đếm tham chiếu, vì vấn đề vòng lặp tham chiếu giữa các đối tượng không gây ra vấn đề thu hồi, bởi vì tiêu chí để xác định xem một vùng nhớ có thể thu hồi hay không là khả năng truy cập. Thuật toán này có một nút gốc, nút này không bao giờ bị thu hồi và được gọi là <strong>GC Root</strong>. Ví dụ, đối tượng toàn cầu của JavaScript Runtime được gọi là <code>window</code>, và nút gốc của cây DOM cũng là một <strong>GC Root</strong>. Các đối tượng trong chương trình tạo thành một đồ thị, và bất kỳ đối tượng nào có thể được truy cập từ nút gốc theo các liên kết tham chiếu sẽ được đánh dấu là đối tượng hoạt động, trong khi các đối tượng cô lập với nút gốc sẽ bị thu hồi. Có thể thấy rằng các đối tượng có số lượng tham chiếu bằng 0 trong mã không thể truy cập từ nút gốc, có nghĩa là một đối tượng có số lượng tham chiếu bằng 0 theo phương pháp đếm tham chiếu cũng sẽ bị thu hồi bởi phương pháp đánh dấu và xóa. Vì vậy, phương pháp đánh dấu và xóa có thể thay thế phương pháp đếm tham chiếu.</p><h2 id="tran-ngan-xep" tabindex="-1"><a class="header-anchor" href="#tran-ngan-xep"><span>Tràn ngăn xếp</span></a></h2><p><strong>Tràn ngăn xếp</strong> là khi không còn đủ không gian bộ nhớ stack để cấp phát, và không còn đủ bộ nhớ để sử dụng.</p><h2 id="ro-ri-bo-nho" tabindex="-1"><a class="header-anchor" href="#ro-ri-bo-nho"><span>Rò rỉ bộ nhớ</span></a></h2><p><strong>Rò rỉ bộ nhớ</strong> là khi không giải phóng hoặc hủy bỏ bộ nhớ sau khi sử dụng, làm chiếm dụng bộ nhớ trống. Nếu có quá nhiều rò rỉ bộ nhớ, quá trình sau đó sẽ không thể yêu cầu được bộ nhớ. Do đó, rò rỉ bộ nhớ có thể dẫn đến tràn bộ nhớ nội bộ.</p>`,30),r=n(`<p>Trong phần mềm lập trình truyền thống, ví dụ như trong ngôn ngữ C, cần sử dụng <code>malloc</code> để cấp phát bộ nhớ và sử dụng <code>free</code> để giải phóng nó, cần phải xóa bằng tay. Trong JavaScript, có cơ chế thu gom rác riêng, phương pháp thu gom rác phổ biến là phương pháp đánh dấu và xóa.</p><ul><li>Ngay cả 1 byte bộ nhớ cũng được gọi là rò rỉ bộ nhớ, không nhất thiết phải gây ra sự sụp đổ hoặc đơ máy mới gọi là rò rỉ bộ nhớ.</li><li>Thông thường, rò rỉ bộ nhớ xảy ra trong vùng nhớ heap, không xảy ra trong vùng nhớ ngăn xếp. Giá trị của các kiểu dữ liệu cơ bản được lưu trữ trong ngăn xếp, trong khi các kiểu dữ liệu tham chiếu được lưu trữ trong heap. Do đó, chỉ các đối tượng, mảng và các kiểu dữ liệu tham chiếu khác mới có thể gây ra rò rỉ bộ nhớ.</li></ul><p><strong>Nguyên nhân phổ biến của rò rỉ bộ nhớ</strong>:</p><ul><li>Biến toàn cục gây ra rò rỉ bộ nhớ</li><li>Hẹn giờ không được xóa</li><li>Closure (Đóng gói)</li></ul><p><strong>Cách giải quyết</strong>:</p><ul><li>Giảm số biến toàn cục không cần thiết</li><li>Giảm việc sử dụng closure (vì closure có thể gây rò rỉ bộ nhớ)</li><li>Tránh xảy ra vòng lặp vô hạn</li></ul><h3 id="bien-toan-cuc" tabindex="-1"><a class="header-anchor" href="#bien-toan-cuc"><span>Biến toàn cục</span></a></h3><p>Biến toàn cục không được coi là rác và không được thu gom. Trong quá trình viết mã, chúng ta nên tránh khai báo biến toàn cục.</p><div class="language-html line-numbers-mode" data-ext="html" data-title="html"><pre class="shiki shiki-themes one-dark-pro one-dark-pro vp-code" style="background-color:#282c34;--shiki-dark-bg:#282c34;color:#abb2bf;--shiki-dark:#abb2bf;" tabindex="0"><code><span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">&lt;</span><span style="color:#E06C75;--shiki-dark:#E06C75;">body</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">&gt;</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">  &lt;</span><span style="color:#E06C75;--shiki-dark:#E06C75;">button</span><span style="color:#D19A66;--shiki-dark:#D19A66;"> onclick</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">=</span><span style="color:#98C379;--shiki-dark:#98C379;">&quot;</span><span style="color:#61AFEF;--shiki-dark:#61AFEF;">grow</span><span style="color:#98C379;--shiki-dark:#98C379;">()&quot;</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">&gt;Global Var&lt;/</span><span style="color:#E06C75;--shiki-dark:#E06C75;">button</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">&gt;</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">  &lt;</span><span style="color:#E06C75;--shiki-dark:#E06C75;">script</span><span style="color:#D19A66;--shiki-dark:#D19A66;"> type</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">=</span><span style="color:#98C379;--shiki-dark:#98C379;">&quot;text/javascript&quot;</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">&gt;</span></span>
<span class="line"><span style="color:#C678DD;--shiki-dark:#C678DD;">    function</span><span style="color:#61AFEF;--shiki-dark:#61AFEF;"> LargeObj</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">() {</span></span>
<span class="line"><span style="color:#E5C07B;--shiki-dark:#E5C07B;">      this</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">.</span><span style="color:#E06C75;--shiki-dark:#E06C75;">largeArr</span><span style="color:#56B6C2;--shiki-dark:#56B6C2;"> =</span><span style="color:#C678DD;--shiki-dark:#C678DD;"> new</span><span style="color:#61AFEF;--shiki-dark:#61AFEF;"> Array</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">(</span><span style="color:#D19A66;--shiki-dark:#D19A66;">1000_0000</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#C678DD;--shiki-dark:#C678DD;">    var</span><span style="color:#E06C75;--shiki-dark:#E06C75;"> x</span><span style="color:#56B6C2;--shiki-dark:#56B6C2;"> =</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;"> [];</span></span>
<span class="line"></span>
<span class="line"><span style="color:#C678DD;--shiki-dark:#C678DD;">    function</span><span style="color:#61AFEF;--shiki-dark:#61AFEF;"> grow</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">() {</span></span>
<span class="line"><span style="color:#C678DD;--shiki-dark:#C678DD;">      var</span><span style="color:#E06C75;--shiki-dark:#E06C75;"> o</span><span style="color:#56B6C2;--shiki-dark:#56B6C2;"> =</span><span style="color:#C678DD;--shiki-dark:#C678DD;"> new</span><span style="color:#61AFEF;--shiki-dark:#61AFEF;"> LargeObj</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">();</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E5C07B;--shiki-dark:#E5C07B;">      x</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">.</span><span style="color:#61AFEF;--shiki-dark:#61AFEF;">push</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">(</span><span style="color:#D19A66;--shiki-dark:#D19A66;">0</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">    }</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">  &lt;/</span><span style="color:#E06C75;--shiki-dark:#E06C75;">script</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">&gt;</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">&lt;/</span><span style="color:#E06C75;--shiki-dark:#E06C75;">body</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">&gt;</span></span></code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Khi chúng ta sử dụng [[JS This#Ràng buộc mặc định (Default Binding)|ràng buộc mặc định]], <code>this</code> sẽ trỏ đến đối tượng toàn cục.</p><p>🔧 <strong>Cách giải quyết</strong>: Sử dụng chế độ nghiêm ngặt trong hàm hoặc giải phóng bộ nhớ của biến toàn cục thủ công.</p><p><strong>Cách gỡ lỗi</strong>: <code>More Tools -&gt; Developer Tools -&gt; Performance/Memory</code>, thường hiện tại, bảng điều khiển Performance ghi lại biểu đồ thay đổi bộ nhớ trang theo thời gian, giúp đánh giá rò rỉ bộ nhớ một cách trực quan, sau đó, trong bảng điều khiển Memory, xác định vị trí xảy ra vấn đề.</p><h3 id="tham-chieu-dom-bi-tach-roi" tabindex="-1"><a class="header-anchor" href="#tham-chieu-dom-bi-tach-roi"><span>Tham chiếu DOM bị tách rời</span></a></h3><p>Bộ nhớ của nút DOM được thu hồi khi đáp ứng hai điều kiện: nút DOM bị xóa khỏi cây DOM và không có tham chiếu đến nó trong mã. Rò rỉ bộ nhớ xảy ra khi nút bị xóa khỏi DOM, nhưng vẫn còn tham chiếu đến nó trong mã JavaScript, chúng ta gọi điều này là tham chiếu DOM bị tách rời.</p><p>Ví dụ về rò rỉ bộ nhớ do tham chiếu DOM bị tách rời:</p><div class="language-html" data-ext="html" data-title="html"><pre class="shiki shiki-themes one-dark-pro one-dark-pro vp-code" style="background-color:#282c34;--shiki-dark-bg:#282c34;color:#abb2bf;--shiki-dark:#abb2bf;" tabindex="0"><code><span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">&lt;</span><span style="color:#E06C75;--shiki-dark:#E06C75;">body</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">&gt;</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">  &lt;</span><span style="color:#E06C75;--shiki-dark:#E06C75;">button</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">&gt;Remove List&lt;/</span><span style="color:#E06C75;--shiki-dark:#E06C75;">button</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">&gt;</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">  &lt;</span><span style="color:#E06C75;--shiki-dark:#E06C75;">ul</span><span style="color:#D19A66;--shiki-dark:#D19A66;"> id</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">=</span><span style="color:#98C379;--shiki-dark:#98C379;">&quot;list&quot;</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">&gt;</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">    &lt;</span><span style="color:#E06C75;--shiki-dark:#E06C75;">li</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">&gt;Item 1&lt;/</span><span style="color:#E06C75;--shiki-dark:#E06C75;">li</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">&gt;</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">  &lt;/</span><span style="color:#E06C75;--shiki-dark:#E06C75;">ul</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">&gt;</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">  &lt;</span><span style="color:#E06C75;--shiki-dark:#E06C75;">script</span><span style="color:#D19A66;--shiki-dark:#D19A66;"> type</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">=</span><span style="color:#98C379;--shiki-dark:#98C379;">&quot;text/javascript&quot;</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">&gt;</span></span>
<span class="line"><span style="color:#C678DD;--shiki-dark:#C678DD;">    var</span><span style="color:#E06C75;--shiki-dark:#E06C75;"> button</span><span style="color:#56B6C2;--shiki-dark:#56B6C2;"> =</span><span style="color:#E5C07B;--shiki-dark:#E5C07B;"> document</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">.</span><span style="color:#61AFEF;--shiki-dark:#61AFEF;">querySelector</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">(</span><span style="color:#98C379;--shiki-dark:#98C379;">&#39;button&#39;</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="color:#C678DD;--shiki-dark:#C678DD;">    var</span><span style="color:#E06C75;--shiki-dark:#E06C75;"> list</span><span style="color:#56B6C2;--shiki-dark:#56B6C2;"> =</span><span style="color:#E5C07B;--shiki-dark:#E5C07B;"> document</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">.</span><span style="color:#61AFEF;--shiki-dark:#61AFEF;">getElementById</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">(</span><span style="color:#98C379;--shiki-dark:#98C379;">&#39;list&#39;</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E5C07B;--shiki-dark:#E5C07B;">    button</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">.</span><span style="color:#61AFEF;--shiki-dark:#61AFEF;">addEventListener</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">(</span><span style="color:#98C379;--shiki-dark:#98C379;">&#39;click&#39;</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">, </span><span style="color:#C678DD;--shiki-dark:#C678DD;">function</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;"> () {</span></span>
<span class="line"><span style="color:#E5C07B;--shiki-dark:#E5C07B;">      list</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">.</span><span style="color:#61AFEF;--shiki-dark:#61AFEF;">remove</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">();</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">    });</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">  &lt;/</span><span style="color:#E06C75;--shiki-dark:#E06C75;">script</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">&gt;</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">&lt;/</span><span style="color:#E06C75;--shiki-dark:#E06C75;">body</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">&gt;</span></span></code></pre></div><p>Chúng ta có thể sử dụng Heap Snapshot để gỡ lỗi rò rỉ bộ nhớ, bằng cách điều hướng đến <code>Memory -&gt; Heap Snapshot -&gt; Take Snapshot</code>, Heap Snapshot có thể cho chúng ta biết liệu có tồn tại tham chiếu DOM bị tách rời hay không, chỉ cần nhập <code>detached</code> vào ô lọc trên cùng, nếu có kết quả, có nghĩa là tồn tại tham chiếu DOM bị tách rời.</p><p>Đối với ví dụ trên, chúng ta có thể đặt nút <code>list</code> trong hàm xử lý sự kiện của nút nhấp chuột, điều này có nghĩa là sau khi hàm xử lý sự kiện trả về, biến cục bộ sẽ bị hủy.</p><h3 id="closure-đong-goi" tabindex="-1"><a class="header-anchor" href="#closure-đong-goi"><span>Closure (Đóng gói)</span></a></h3><p>Closure cũng có thể gây ra rò rỉ bộ nhớ vì các con trỏ ẩn trên các phiên bản hàm sẽ giữ lại đối tượng phạm vi được tạo trong môi trường tạo phiên bản.</p><div class="language-html line-numbers-mode" data-ext="html" data-title="html"><pre class="shiki shiki-themes one-dark-pro one-dark-pro vp-code" style="background-color:#282c34;--shiki-dark-bg:#282c34;color:#abb2bf;--shiki-dark:#abb2bf;" tabindex="0"><code><span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">&lt;</span><span style="color:#E06C75;--shiki-dark:#E06C75;">body</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">&gt;</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">  &lt;</span><span style="color:#E06C75;--shiki-dark:#E06C75;">button</span><span style="color:#D19A66;--shiki-dark:#D19A66;"> onclick</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">=</span><span style="color:#98C379;--shiki-dark:#98C379;">&quot;</span><span style="color:#61AFEF;--shiki-dark:#61AFEF;">closure</span><span style="color:#98C379;--shiki-dark:#98C379;">()&quot;</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">&gt;Closure&lt;/</span><span style="color:#E06C75;--shiki-dark:#E06C75;">button</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">&gt;</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">  &lt;</span><span style="color:#E06C75;--shiki-dark:#E06C75;">script</span><span style="color:#D19A66;--shiki-dark:#D19A66;"> type</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">=</span><span style="color:#98C379;--shiki-dark:#98C379;">&quot;text/javascript&quot;</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">&gt;</span></span>
<span class="line"><span style="color:#C678DD;--shiki-dark:#C678DD;">    var</span><span style="color:#E06C75;--shiki-dark:#E06C75;"> funcs</span><span style="color:#56B6C2;--shiki-dark:#56B6C2;"> =</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;"> [];</span></span>
<span class="line"></span>
<span class="line"><span style="color:#C678DD;--shiki-dark:#C678DD;">    function</span><span style="color:#61AFEF;--shiki-dark:#61AFEF;"> outer</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">() {</span></span>
<span class="line"><span style="color:#C678DD;--shiki-dark:#C678DD;">      var</span><span style="color:#E06C75;--shiki-dark:#E06C75;"> someText</span><span style="color:#56B6C2;--shiki-dark:#56B6C2;"> =</span><span style="color:#C678DD;--shiki-dark:#C678DD;"> new</span><span style="color:#61AFEF;--shiki-dark:#61AFEF;"> Array</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">(</span><span style="color:#D19A66;--shiki-dark:#D19A66;">1000_0000</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#C678DD;--shiki-dark:#C678DD;">      return</span><span style="color:#C678DD;--shiki-dark:#C678DD;"> function</span><span style="color:#61AFEF;--shiki-dark:#61AFEF;"> inner</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">() {</span></span>
<span class="line"><span style="color:#C678DD;--shiki-dark:#C678DD;">        return</span><span style="color:#E06C75;--shiki-dark:#E06C75;"> someText</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">      };</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#C678DD;--shiki-dark:#C678DD;">    function</span><span style="color:#61AFEF;--shiki-dark:#61AFEF;"> closure</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">() {</span></span>
<span class="line"><span style="color:#E5C07B;--shiki-dark:#E5C07B;">      funcs</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">.</span><span style="color:#61AFEF;--shiki-dark:#61AFEF;">push</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">(</span><span style="color:#61AFEF;--shiki-dark:#61AFEF;">outer</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">());</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">    }</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">  &lt;/</span><span style="color:#E06C75;--shiki-dark:#E06C75;">script</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">&gt;</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">&lt;/</span><span style="color:#E06C75;--shiki-dark:#E06C75;">body</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">&gt;</span></span></code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Lưu ý: Mã này không nhất thiết phải có vấn đề gì, chỉ là để chỉ ra rằng closure có thể chiếm dụng bộ nhớ, chỉ khi có sự chiếm dụng bộ nhớ không hợp lý mới được xem là rò rỉ bộ nhớ.</p><p>Cách gỡ lỗi: <code>More Tools -&gt; Developer Tools -&gt; Memory -&gt; Allocation instrumentation on timeline</code>.</p><h3 id="hen-gio" tabindex="-1"><a class="header-anchor" href="#hen-gio"><span>Hẹn giờ</span></a></h3><p>Khi không cần sử dụng <code>setInterval</code> hoặc <code>setTimeout</code> nữa, nếu không xóa bỏ hẹn giờ, hàm gọi lại của hẹn giờ và các biến phụ thuộc bên trong nó sẽ không thể được giải phóng, gây ra rò rỉ bộ nhớ.</p><div class="language-js" data-ext="js" data-title="js"><pre class="shiki shiki-themes one-dark-pro one-dark-pro vp-code" style="background-color:#282c34;--shiki-dark-bg:#282c34;color:#abb2bf;--shiki-dark:#abb2bf;" tabindex="0"><code><span class="line"><span style="color:#C678DD;--shiki-dark:#C678DD;">const</span><span style="color:#E5C07B;--shiki-dark:#E5C07B;"> someResource</span><span style="color:#56B6C2;--shiki-dark:#56B6C2;"> =</span><span style="color:#61AFEF;--shiki-dark:#61AFEF;"> getData</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">();</span></span>
<span class="line"></span>
<span class="line"><span style="color:#7F848E;--shiki-dark:#7F848E;font-style:italic;--shiki-dark-font-style:italic;">// node và someResource lưu trữ một lượng lớn dữ liệu không thể giải phóng</span></span>
<span class="line"><span style="color:#C678DD;--shiki-dark:#C678DD;">const</span><span style="color:#E5C07B;--shiki-dark:#E5C07B;"> timerId</span><span style="color:#56B6C2;--shiki-dark:#56B6C2;"> =</span><span style="color:#61AFEF;--shiki-dark:#61AFEF;"> setInterval</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">(</span><span style="color:#C678DD;--shiki-dark:#C678DD;">function</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;"> () {</span></span>
<span class="line"><span style="color:#C678DD;--shiki-dark:#C678DD;">  const</span><span style="color:#E5C07B;--shiki-dark:#E5C07B;"> node</span><span style="color:#56B6C2;--shiki-dark:#56B6C2;"> =</span><span style="color:#E5C07B;--shiki-dark:#E5C07B;"> document</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">.</span><span style="color:#61AFEF;--shiki-dark:#61AFEF;">getElementById</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">(</span><span style="color:#98C379;--shiki-dark:#98C379;">&#39;Node&#39;</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#C678DD;--shiki-dark:#C678DD;">  if</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;"> (</span><span style="color:#E06C75;--shiki-dark:#E06C75;">node</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">) {</span></span>
<span class="line"><span style="color:#7F848E;--shiki-dark:#7F848E;font-style:italic;--shiki-dark-font-style:italic;">    // Hẹn giờ cũng không được xóa bỏ</span></span>
<span class="line"><span style="color:#E5C07B;--shiki-dark:#E5C07B;">    node</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">.</span><span style="color:#E06C75;--shiki-dark:#E06C75;">innerHTML</span><span style="color:#56B6C2;--shiki-dark:#56B6C2;"> =</span><span style="color:#E5C07B;--shiki-dark:#E5C07B;"> JSON</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">.</span><span style="color:#61AFEF;--shiki-dark:#61AFEF;">stringify</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">(</span><span style="color:#E06C75;--shiki-dark:#E06C75;">someResource</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">  }</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">}, </span><span style="color:#D19A66;--shiki-dark:#D19A66;">1000</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#61AFEF;--shiki-dark:#61AFEF;">clearInterval</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">(</span><span style="color:#E06C75;--shiki-dark:#E06C75;">timerId</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">);</span></span></code></pre></div><p>🔧 <strong>Cách giải quyết</strong>: Xóa bỏ hẹn giờ khi công việc của nó hoàn thành.</p><h3 id="in-ra-console" tabindex="-1"><a class="header-anchor" href="#in-ra-console"><span>In ra console</span></a></h3><p>Việc sử dụng câu lệnh <code>console.log</code> để in thông tin gỡ lỗi, vì console luôn giữ tham chiếu của chúng để có thể xem bất kỳ lúc nào, nên bộ nhớ của chúng cũng không thể được giải phóng. Do đó, khuyến nghị loại bỏ việc in ra console trong môi trường product.</p>`,29);function p(e,B){const s=i("Mermaid");return t(),c("div",null,[o,l(s,{id:"mermaid-136",code:"eJxLy8kvT85ILCpR8AnicowOOrxJoejh7k6FpIe7ZyrkZTzcPTtWQVdXIfnwZoUSIK9ZIeXhrtV5CkcmPty1Pw8oY6fgFB1SdHhBnkJe+pHmPIUKoHhBLBcAqA0ncA=="}),r])}const d=a(h,[["render",p],["__file","garbage-collection.html.vue"]]),g=JSON.parse('{"path":"/programming/js/core/excute-and-contexts/memory-management/garbage-collection.html","title":"Garbage Collection","lang":"en-US","frontmatter":{"title":"Garbage Collection","tags":["js","programming"],"categories":["js","programming"],"date created":"2023-08-02T00:00:00.000Z","date modified":"2023-08-03T00:00:00.000Z","order":3,"description":"Thu gom rác Vì chuỗi, đối tượng và mảng không có kích thước cố định, nên chỉ khi kích thước của chúng được biết, chúng mới có thể được cấp phát bộ nhớ động. Mỗi lần tạo ra một c...","head":[["meta",{"property":"og:url","content":"https://vanhung4499.github.io/programming/js/core/excute-and-contexts/memory-management/garbage-collection.html"}],["meta",{"property":"og:site_name","content":"VanHung4499"}],["meta",{"property":"og:title","content":"Garbage Collection"}],["meta",{"property":"og:description","content":"Thu gom rác Vì chuỗi, đối tượng và mảng không có kích thước cố định, nên chỉ khi kích thước của chúng được biết, chúng mới có thể được cấp phát bộ nhớ động. Mỗi lần tạo ra một c..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"en-US"}],["meta",{"property":"og:updated_time","content":"2024-06-28T15:54:38.000Z"}],["meta",{"property":"article:author","content":"Hung Nguyen"}],["meta",{"property":"article:tag","content":"js"}],["meta",{"property":"article:tag","content":"programming"}],["meta",{"property":"article:modified_time","content":"2024-06-28T15:54:38.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Garbage Collection\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2024-06-28T15:54:38.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Hung Nguyen\\",\\"url\\":\\"https://vanhung4499.github.io\\"}]}"]]},"headers":[{"level":2,"title":"Nguyên lý","slug":"nguyen-ly","link":"#nguyen-ly","children":[{"level":3,"title":"Phương pháp đếm tham chiếu","slug":"phuong-phap-đem-tham-chieu","link":"#phuong-phap-đem-tham-chieu","children":[]},{"level":3,"title":"Phương pháp đánh dấu và xóa","slug":"phuong-phap-đanh-dau-va-xoa","link":"#phuong-phap-đanh-dau-va-xoa","children":[]}]},{"level":2,"title":"Tràn ngăn xếp","slug":"tran-ngan-xep","link":"#tran-ngan-xep","children":[]},{"level":2,"title":"Rò rỉ bộ nhớ","slug":"ro-ri-bo-nho","link":"#ro-ri-bo-nho","children":[{"level":3,"title":"Biến toàn cục","slug":"bien-toan-cuc","link":"#bien-toan-cuc","children":[]},{"level":3,"title":"Tham chiếu DOM bị tách rời","slug":"tham-chieu-dom-bi-tach-roi","link":"#tham-chieu-dom-bi-tach-roi","children":[]},{"level":3,"title":"Closure (Đóng gói)","slug":"closure-đong-goi","link":"#closure-đong-goi","children":[]},{"level":3,"title":"Hẹn giờ","slug":"hen-gio","link":"#hen-gio","children":[]},{"level":3,"title":"In ra console","slug":"in-ra-console","link":"#in-ra-console","children":[]}]}],"git":{"createdTime":1719590078000,"updatedTime":1719590078000,"contributors":[{"name":"Hung Nguyen Van","email":"vanhung4499@gmail.com","commits":1}]},"readingTime":{"minutes":9.97,"words":2991},"filePathRelative":"programming/js/core/excute-and-contexts/memory-management/garbage-collection.md","localizedDate":"June 28, 2024","excerpt":"\\n<blockquote>\\n<p>Vì chuỗi, đối tượng và mảng không có kích thước cố định, nên chỉ khi kích thước của chúng được biết, chúng mới có thể được cấp phát bộ nhớ động. Mỗi lần tạo ra một chuỗi, một mảng hoặc một đối tượng trong JavaScript, trình thông dịch phải cấp phát bộ nhớ để lưu trữ thực thể đó. Khi bộ nhớ được cấp phát động như vậy, nó phải được giải phóng để có thể được sử dụng lại. Nếu không, trình thông dịch JavaScript sẽ tiêu thụ hết bộ nhớ có sẵn trong hệ thống và gây ra sự cố hệ thống. - \\"JavaScript: The Definitive Guide\\"</p>\\n</blockquote>","autoDesc":true}');export{d as comp,g as data};
