import{_ as n,o as s,c as h,a as t}from"./app-CmlOSuIY.js";const a={};function l(e,i){return s(),h("div",null,i[0]||(i[0]=[t(`<h1 id="redis-advanced-data-types" tabindex="-1"><a class="header-anchor" href="#redis-advanced-data-types"><span>Redis Advanced Data Types</span></a></h1><p>Redis hỗ trợ các kiểu dữ liệu nâng cao như BitMap, HyperLogLog, GEO và Stream. Hiểu được đặc tính của các kiểu dữ liệu này và áp dụng linh hoạt và hiệu quả vào từng kịch bản nghiệp vụ cụ thể là rất quan trọng khi sử dụng Redis để mô hình hóa dữ liệu.</p><h2 id="bitmap" tabindex="-1"><a class="header-anchor" href="#bitmap"><span>BitMap</span></a></h2><h3 id="gioi-thieu-ve-bitmap" tabindex="-1"><a class="header-anchor" href="#gioi-thieu-ve-bitmap"><span>Giới thiệu về BitMap</span></a></h3><p>BitMap, như tên gọi, là một chuỗi liên tục các số nhị phân (0 và 1) trong đó các phần tử được truy cập bằng các offset. Vì bit là đơn vị nhỏ nhất trong máy tính, việc sử dụng BitMap để lưu trữ có thể <strong>tiết kiệm rất nhiều không gian</strong>, đặc biệt phù hợp cho các kịch bản thống kê nhị phân với tập dữ liệu lớn. Ví dụ, trong một hệ thống nơi mà người dùng được biểu diễn bằng các ID người dùng tăng dần, BitMap có thể lưu trữ hiệu quả trạng thái đăng nhập của từng người dùng. Với BitMap, hệ thống có thể xử lý đến 4 tỷ người dùng (khoảng $$2^{32}$$), chỉ cần 512 MB bộ nhớ để lưu trữ trạng thái đăng nhập.</p><h3 id="thuc-hien-bitmap" tabindex="-1"><a class="header-anchor" href="#thuc-hien-bitmap"><span>Thực hiện BitMap</span></a></h3><p>Trong thực tế, <strong>BitMap không phải là một cấu trúc dữ liệu độc lập mà là một tập hợp các phép toán bit được thực hiện trên chuỗi String</strong>.</p><p>Với Redis, các chuỗi là an toàn cho dữ liệu nhị phân và có thể lưu trữ đến 512 MB độ dài. Do đó, BitMap cho phép thiết lập đến $$2^{32}$$ bit khác nhau, giúp quản lý dữ liệu nhị phân quy mô lớn một cách hiệu quả trong Redis, tận dụng khả năng lưu trữ và thao tác tối ưu của nó.</p><h3 id="cac-lenh-bitmap" tabindex="-1"><a class="header-anchor" href="#cac-lenh-bitmap"><span>Các Lệnh BitMap</span></a></h3><table><thead><tr><th>Lệnh</th><th>Hành động</th></tr></thead><tbody><tr><td><code>SETBIT</code></td><td>Đặt hoặc xóa bit tại vị trí chỉ định của key</td></tr><tr><td><code>GETBIT</code></td><td>Lấy giá trị bit tại vị trí chỉ định của key</td></tr><tr><td><code>BITOP</code></td><td>Thực hiện phép toán bit trên một hoặc nhiều chuỗi</td></tr><tr><td><code>BITPOS</code></td><td>Tìm vị trí đầu tiên xuất hiện của giá trị chỉ định trong key</td></tr></tbody></table><p><strong>Ví dụ về SETBIT và GETBIT</strong></p><p>Giả sử có 1000 cảm biến được đánh số từ 0 đến 999. Bây giờ, muốn nhanh chóng xác định liệu một cảm biến đã thực hiện ping máy chủ trong một giờ nhất định hay không.</p><div class="language-shell" data-highlighter="shiki" data-ext="shell" data-title="shell" style="--shiki-light:#abb2bf;--shiki-dark:#abb2bf;--shiki-light-bg:#282c34;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-dark-pro one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#7F848E;--shiki-dark:#7F848E;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;"># Cảm biến 123 thực hiện ping máy chủ vào ngày 1 tháng 1 năm 2024 lúc 00:00</span></span>
<span class="line"><span style="--shiki-light:#ABB2BF;--shiki-dark:#ABB2BF;">&gt; SETBIT pings:2024-01-01-00:00 123 1</span></span>
<span class="line"><span style="--shiki-light:#ABB2BF;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#61AFEF;--shiki-dark:#61AFEF;">integer</span><span style="--shiki-light:#ABB2BF;--shiki-dark:#ABB2BF;">) </span><span style="--shiki-light:#61AFEF;--shiki-dark:#61AFEF;">0</span></span>
<span class="line"><span style="--shiki-light:#7F848E;--shiki-dark:#7F848E;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;"># Kiểm tra xem cảm biến 123 có thực hiện ping trong ngày 1 tháng 1 năm 2024 lúc 00:00 hay không</span></span>
<span class="line"><span style="--shiki-light:#ABB2BF;--shiki-dark:#ABB2BF;">&gt; GETBIT pings:2024-01-01-00:00 123</span></span>
<span class="line"><span style="--shiki-light:#61AFEF;--shiki-dark:#61AFEF;">1</span></span>
<span class="line"><span style="--shiki-light:#61AFEF;--shiki-dark:#61AFEF;">Còn</span><span style="--shiki-light:#98C379;--shiki-dark:#98C379;"> cảm</span><span style="--shiki-light:#98C379;--shiki-dark:#98C379;"> biến</span><span style="--shiki-light:#D19A66;--shiki-dark:#D19A66;"> 456</span><span style="--shiki-light:#98C379;--shiki-dark:#98C379;"> thì</span><span style="--shiki-light:#98C379;--shiki-dark:#98C379;"> sao?</span></span>
<span class="line"><span style="--shiki-light:#ABB2BF;--shiki-dark:#ABB2BF;">&gt; GETBIT pings:2024-01-01-00:00 456</span></span>
<span class="line"><span style="--shiki-light:#61AFEF;--shiki-dark:#61AFEF;">0</span></span></code></pre></div><p><strong>Ví dụ về BITOP</strong></p><div class="language-shell" data-highlighter="shiki" data-ext="shell" data-title="shell" style="--shiki-light:#abb2bf;--shiki-dark:#abb2bf;--shiki-light-bg:#282c34;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-dark-pro one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#7F848E;--shiki-dark:#7F848E;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;"># Thực hiện phép toán BITOP giữa các BitMap</span></span>
<span class="line"><span style="--shiki-light:#7F848E;--shiki-dark:#7F848E;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;"># operations là toán tử bit, chỉ liệt kê</span></span>
<span class="line"><span style="--shiki-light:#61AFEF;--shiki-dark:#61AFEF;">  AND</span><span style="--shiki-light:#98C379;--shiki-dark:#98C379;"> -</span><span style="--shiki-light:#98C379;--shiki-dark:#98C379;"> Phép</span><span style="--shiki-light:#98C379;--shiki-dark:#98C379;"> toán</span><span style="--shiki-light:#98C379;--shiki-dark:#98C379;"> AND</span><span style="--shiki-light:#ABB2BF;--shiki-dark:#ABB2BF;"> &amp;</span></span>
<span class="line"><span style="--shiki-light:#61AFEF;--shiki-dark:#61AFEF;">  OR</span><span style="--shiki-light:#98C379;--shiki-dark:#98C379;"> -</span><span style="--shiki-light:#98C379;--shiki-dark:#98C379;"> Phép</span><span style="--shiki-light:#98C379;--shiki-dark:#98C379;"> toán</span><span style="--shiki-light:#98C379;--shiki-dark:#98C379;"> OR</span><span style="--shiki-light:#ABB2BF;--shiki-dark:#ABB2BF;"> |</span></span>
<span class="line"><span style="--shiki-light:#61AFEF;--shiki-dark:#61AFEF;">  XOR</span><span style="--shiki-light:#98C379;--shiki-dark:#98C379;"> -</span><span style="--shiki-light:#98C379;--shiki-dark:#98C379;"> Phép</span><span style="--shiki-light:#98C379;--shiki-dark:#98C379;"> toán</span><span style="--shiki-light:#98C379;--shiki-dark:#98C379;"> XOR</span><span style="--shiki-light:#98C379;--shiki-dark:#98C379;"> ^</span></span>
<span class="line"><span style="--shiki-light:#61AFEF;--shiki-dark:#61AFEF;">  NOT</span><span style="--shiki-light:#98C379;--shiki-dark:#98C379;"> -</span><span style="--shiki-light:#98C379;--shiki-dark:#98C379;"> Phép</span><span style="--shiki-light:#98C379;--shiki-dark:#98C379;"> toán</span><span style="--shiki-light:#98C379;--shiki-dark:#98C379;"> NOT</span><span style="--shiki-light:#98C379;--shiki-dark:#98C379;"> ~</span></span>
<span class="line"><span style="--shiki-light:#7F848E;--shiki-dark:#7F848E;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;"># key1 … keyn: Các key tham gia phép toán, có thể có nhiều key, cách nhau bởi khoảng trắng, chỉ có một key</span></span>
<span class="line"><span style="--shiki-light:#7F848E;--shiki-dark:#7F848E;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;"># Khi BITOP xử lý các chuỗi có độ dài khác nhau, các bit của chuỗi ngắn hơn sẽ bị coi là 0. Trả về kích thước của chuỗi (theo byte) trong destkey bằng với chuỗi dài nhất trong chuỗi đầu vào.</span></span>
<span class="line"><span style="--shiki-light:#61AFEF;--shiki-dark:#61AFEF;">BITOP</span><span style="--shiki-light:#ABB2BF;--shiki-dark:#ABB2BF;"> [operations] [result] [key1] [keyn…]</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#7F848E;--shiki-dark:#7F848E;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;"># Trả về vị trí đầu tiên của value(0/1) xuất hiện trong key</span></span>
<span class="line"><span style="--shiki-light:#61AFEF;--shiki-dark:#61AFEF;">BITPOS</span><span style="--shiki-light:#ABB2BF;--shiki-dark:#ABB2BF;"> [key] [value]</span></span></code></pre></div><h3 id="ung-dung-cua-bitmap" tabindex="-1"><a class="header-anchor" href="#ung-dung-cua-bitmap"><span>Ứng dụng của BitMap</span></a></h3><p>Loại dữ liệu BitMap rất thích hợp cho các kịch bản thống kê trạng thái hai giá trị, nơi mà các phần tử tập hợp chỉ có thể có giá trị 0 và 1. Trên thực tế, nó rất hiệu quả trong việc tiết kiệm không gian bộ nhớ khi lưu trữ dữ liệu lượng lớn.</p><h4 id="thong-ke-đang-nhap" tabindex="-1"><a class="header-anchor" href="#thong-ke-đang-nhap"><span>Thống kê đăng nhập</span></a></h4><p>Trong kịch bản đăng nhập, chúng ta chỉ cần ghi nhận đã đăng nhập (1) hoặc chưa đăng nhập (0), điều này là một ví dụ rõ ràng của trạng thái hai giá trị.</p><p>Khi thống kê đăng nhập, mỗi người dùng chỉ cần một bit để biểu thị đăng nhập trong một ngày, 31 bit có thể biểu thị tình trạng đăng nhập trong tháng (giả sử tháng có 31 ngày), và chỉ cần 365 bit để biểu thị đăng nhập trong một năm. Điều này không cần đến các loại tập hợp phức tạp hơn.</p><p>Giả sử chúng ta muốn thống kê người dùng có ID 100 đăng nhập trong tháng 6 năm 2022, chúng ta có thể thực hiện các bước sau.</p><p>Bước 1, thực hiện lệnh sau để ghi nhận người dùng 100 đã đăng nhập vào ngày 3 tháng 6.</p><div class="language-shell" data-highlighter="shiki" data-ext="shell" data-title="shell" style="--shiki-light:#abb2bf;--shiki-dark:#abb2bf;--shiki-light-bg:#282c34;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-dark-pro one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#61AFEF;--shiki-dark:#61AFEF;">SETBIT</span><span style="--shiki-light:#98C379;--shiki-dark:#98C379;"> uid:sign:100:202206</span><span style="--shiki-light:#D19A66;--shiki-dark:#D19A66;"> 2</span><span style="--shiki-light:#D19A66;--shiki-dark:#D19A66;"> 1</span></span></code></pre></div><p>Bước 2, kiểm tra xem người dùng 100 đã đăng nhập vào ngày 3 tháng 6 chưa.</p><div class="language-shell" data-highlighter="shiki" data-ext="shell" data-title="shell" style="--shiki-light:#abb2bf;--shiki-dark:#abb2bf;--shiki-light-bg:#282c34;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-dark-pro one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#61AFEF;--shiki-dark:#61AFEF;">GETBIT</span><span style="--shiki-light:#98C379;--shiki-dark:#98C379;"> uid:sign:100:202206</span><span style="--shiki-light:#D19A66;--shiki-dark:#D19A66;"> 2</span></span></code></pre></div><p>Bước 3, thống kê số lần đăng nhập của người dùng trong tháng 6.</p><div class="language-shell" data-highlighter="shiki" data-ext="shell" data-title="shell" style="--shiki-light:#abb2bf;--shiki-dark:#abb2bf;--shiki-light-bg:#282c34;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-dark-pro one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#61AFEF;--shiki-dark:#61AFEF;">BITCOUNT</span><span style="--shiki-light:#98C379;--shiki-dark:#98C379;"> uid:sign:100:202206</span></span></code></pre></div><p>Như vậy, chúng ta có thể biết được tình trạng đăng nhập của người dùng trong tháng 6.</p><blockquote><p>Làm thế nào để thống kê thời gian đăng nhập đầu tiên trong tháng này?</p></blockquote><p>Redis cung cấp lệnh <code>BITPOS key bitValue [start] [end]</code>, trả về vị trí offset đầu tiên của giá trị <code>bitValue</code> trong BitMap.</p><p>Mặc định, lệnh này sẽ kiểm tra toàn bộ bit map, người dùng có thể sử dụng tham số bắt buộc của &quot;start&quot; và &quot;end&quot; để xác định phạm vi kiểm tra. Vì vậy, chúng tôi có thể lấy người dùng ID = 100 thời gian đăng nhập đầu tiên vào tháng 6 năm 2022 bằng cách thực hiện lệnh sau:</p><div class="language-shell" data-highlighter="shiki" data-ext="shell" data-title="shell" style="--shiki-light:#abb2bf;--shiki-dark:#abb2bf;--shiki-light-bg:#282c34;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-dark-pro one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#61AFEF;--shiki-dark:#61AFEF;">BITPOS</span><span style="--shiki-light:#98C379;--shiki-dark:#98C379;"> uid:sign:100:202206</span><span style="--shiki-light:#D19A66;--shiki-dark:#D19A66;"> 1</span></span></code></pre></div><p>Chú ý rằng, vì offset bắt đầu từ 0, chúng ta cần cộng thêm 1 cho giá trị trả về.</p><h4 id="xac-đinh-trang-thai-đang-nhap-cua-nguoi-dung" tabindex="-1"><a class="header-anchor" href="#xac-đinh-trang-thai-đang-nhap-cua-nguoi-dung"><span>Xác định trạng thái đăng nhập của người dùng</span></a></h4><p>Bitmap cung cấp các hoạt động <code>GETBIT</code> và <code>SETBIT</code>, cho phép thao tác đọc và ghi vào vị trí bit của một mảng bit, với offset bắt đầu từ 0.</p><p>Chỉ cần một key duy nhất là <code>login_status</code> để lưu trữ dữ liệu trạng thái đăng nhập của người dùng, trong đó ID của người dùng được sử dụng làm offset. Khi người dùng đăng nhập, bit tại offset tương ứng được đặt là 1; khi người dùng đăng xuất, bit đó được đặt là 0. Với 50 triệu người dùng, chỉ cần 6 MB không gian lưu trữ.</p><p>Ví dụ, để kiểm tra trạng thái đăng nhập của người dùng có ID = 10086:</p><p>Bước 1: Đặt bit tại offset 10086 để biểu thị người dùng đã đăng nhập.</p><div class="language-shell" data-highlighter="shiki" data-ext="shell" data-title="shell" style="--shiki-light:#abb2bf;--shiki-dark:#abb2bf;--shiki-light-bg:#282c34;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-dark-pro one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#61AFEF;--shiki-dark:#61AFEF;">SETBIT</span><span style="--shiki-light:#98C379;--shiki-dark:#98C379;"> login_status</span><span style="--shiki-light:#D19A66;--shiki-dark:#D19A66;"> 10086</span><span style="--shiki-light:#D19A66;--shiki-dark:#D19A66;"> 1</span></span></code></pre></div><p>Bước 2: Kiểm tra xem người dùng có ID = 10086 có đang đăng nhập hay không. Giá trị trả về là 1 nếu đã đăng nhập.</p><div class="language-shell" data-highlighter="shiki" data-ext="shell" data-title="shell" style="--shiki-light:#abb2bf;--shiki-dark:#abb2bf;--shiki-light-bg:#282c34;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-dark-pro one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#61AFEF;--shiki-dark:#61AFEF;">GETBIT</span><span style="--shiki-light:#98C379;--shiki-dark:#98C379;"> login_status</span><span style="--shiki-light:#D19A66;--shiki-dark:#D19A66;"> 10086</span></span></code></pre></div><p>Bước 3: Để đăng xuất người dùng, đặt giá trị tại offset tương ứng là 0.</p><div class="language-shell" data-highlighter="shiki" data-ext="shell" data-title="shell" style="--shiki-light:#abb2bf;--shiki-dark:#abb2bf;--shiki-light-bg:#282c34;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-dark-pro one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#61AFEF;--shiki-dark:#61AFEF;">SETBIT</span><span style="--shiki-light:#98C379;--shiki-dark:#98C379;"> login_status</span><span style="--shiki-light:#D19A66;--shiki-dark:#D19A66;"> 10086</span><span style="--shiki-light:#D19A66;--shiki-dark:#D19A66;"> 0</span></span></code></pre></div><h4 id="tong-so-nguoi-dung-lien-tuc-đang-ky-7-ngay" tabindex="-1"><a class="header-anchor" href="#tong-so-nguoi-dung-lien-tuc-đang-ky-7-ngay"><span>Tổng số người dùng liên tục đăng ký 7 ngày</span></a></h4><p>Để đếm tổng số người dùng đã đăng ký liên tục trong 7 ngày, chúng ta sử dụng Bitmap với mỗi ngày là một key và userID là offset. Nếu người dùng đã đăng ký trong ngày đó, chúng ta đặt bit tại offset tương ứng thành 1.</p><p>Sau đó, chúng ta thực hiện phép toán &quot;AND&quot; trên 7 Bitmap tương ứng. Nếu bit tại offset của người dùng trong 7 ngày đều là 1, thì người dùng đó đã đăng ký liên tục trong 7 ngày.</p><p>Kết quả sẽ được lưu vào một Bitmap mới và chúng ta sử dụng <code>BITCOUNT</code> để đếm số lượng bit bằng 1 trong Bitmap mới này, từ đó xác định tổng số người dùng đã đăng ký liên tục trong 7 ngày.</p><p>Redis cung cấp lệnh <code>BITOP operation destkey key [key ...]</code> để thực hiện các phép toán bit trên một hoặc nhiều key Bitmap.</p><ul><li><code>operation</code> có thể là <code>and</code>, <code>OR</code>, <code>NOT</code>, <code>XOR</code>. Khi <code>BITOP</code> xử lý các chuỗi có độ dài khác nhau, phần thiếu của chuỗi ngắn hơn sẽ được xem là <code>0</code>. Chuỗi key trống cũng được xem là chuỗi chứa <code>0</code>.</li></ul><p>Ví dụ, để đếm số người dùng đã đăng ký liên tục trong 3 ngày, chúng ta thực hiện phép toán &quot;AND&quot; trên ba Bitmap và lưu kết quả vào <code>destmap</code>, sau đó sử dụng <code>BITCOUNT</code> để đếm số lượng bit bằng 1:</p><div class="language-shell" data-highlighter="shiki" data-ext="shell" data-title="shell" style="--shiki-light:#abb2bf;--shiki-dark:#abb2bf;--shiki-light-bg:#282c34;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-dark-pro one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#7F848E;--shiki-dark:#7F848E;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;"># Phép toán AND</span></span>
<span class="line"><span style="--shiki-light:#61AFEF;--shiki-dark:#61AFEF;">BITOP</span><span style="--shiki-light:#98C379;--shiki-dark:#98C379;"> AND</span><span style="--shiki-light:#98C379;--shiki-dark:#98C379;"> destmap</span><span style="--shiki-light:#98C379;--shiki-dark:#98C379;"> bitmap:01</span><span style="--shiki-light:#98C379;--shiki-dark:#98C379;"> bitmap:02</span><span style="--shiki-light:#98C379;--shiki-dark:#98C379;"> bitmap:03</span></span>
<span class="line"><span style="--shiki-light:#7F848E;--shiki-dark:#7F848E;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;"># Đếm số lượng bit bằng 1</span></span>
<span class="line"><span style="--shiki-light:#61AFEF;--shiki-dark:#61AFEF;">BITCOUNT</span><span style="--shiki-light:#98C379;--shiki-dark:#98C379;"> destmap</span></span></code></pre></div><p>Mặc dù có hàng triệu dữ liệu được tạo mỗi ngày, Bitmap vẫn chiếm ít bộ nhớ, khoảng 12 MB (10^8/8/1024/1024) cho mỗi ngày. Với 7 ngày, Bitmap chỉ chiếm khoảng 84 MB bộ nhớ. Chúng ta cũng nên đặt thời gian hết hạn cho Bitmap để Redis tự động xóa các dữ liệu đăng ký hết hạn, giúp tiết kiệm bộ nhớ.</p><h2 id="hyperloglog" tabindex="-1"><a class="header-anchor" href="#hyperloglog"><span>HyperLogLog</span></a></h2><h3 id="gioi-thieu-ve-hyperloglog" tabindex="-1"><a class="header-anchor" href="#gioi-thieu-ve-hyperloglog"><span>Giới thiệu về HyperLogLog</span></a></h3><p>HyperLogLog là một kiểu dữ liệu mới trong Redis, được thêm vào từ phiên bản 2.8.9, được sử dụng để ước tính &quot;số lượng phần tử duy nhất&quot; trong một tập hợp, còn được gọi là đếm cardinality. Tuy nhiên, phương pháp này là ước tính dựa trên xác suất và không cho kết quả chính xác, với mức độ sai lệch chuẩn là 0.81%.</p><p>HyperLogLog <strong>cung cấp một cách không chính xác để đếm số lượng phần tử duy nhất</strong>.</p><p>Ưu điểm của HyperLogLog là khi số lượng phần tử hoặc dung lượng tập hợp rất lớn, bộ nhớ cần thiết để tính cardinality luôn là cố định và rất nhỏ.</p><p>Trong Redis, mỗi khóa HyperLogLog chỉ cần sử dụng khoảng 12 KB bộ nhớ để ước tính gần <code>2^64</code> phần tử khác nhau. Điều này làm cho HyperLogLog tiết kiệm bộ nhớ hơn đáng kể so với các kiểu dữ liệu Set và Hash, mà càng có nhiều phần tử thì lại càng tiêu tốn nhiều bộ nhớ.</p><p>Để so sánh, một ví dụ trong Java: kiểu dữ liệu long chiếm 8 byte. Một byte có 8 bit, do đó kiểu long có thể biểu diễn số tối đa là <code>2^63-1</code>. Với <code>2^64</code> số lượng phần tử, và giả sử có <code>2^63-1</code> phần tử, tổng dung lượng bộ nhớ theo quy tắc <code>long</code> và <code>1k = 1024 bytes</code> sẽ là <code>((2^63-1) * 8/1024)K</code>, một con số rất lớn, vượt xa 12 KB, trong khi HyperLogLog chỉ cần 12 KB để thực hiện công việc tương tự.</p><p>Điều này cho thấy HyperLogLog là một công cụ hiệu quả để ước tính số lượng phần tử duy nhất trong các tập dữ liệu lớn mà không cần sử dụng quá nhiều bộ nhớ.</p><h3 id="trien-khai-hyperloglog" tabindex="-1"><a class="header-anchor" href="#trien-khai-hyperloglog"><span>Triển khai HyperLogLog</span></a></h3><p>Việc triển khai HyperLogLog liên quan đến rất nhiều vấn đề toán học, quá tốn não và tôi không hiểu nó. Nếu bạn muốn biết thêm về nó, bạn có thể xem phần sau: <a href="https://en.wikipedia.org/wiki/HyperLogLog" target="_blank" rel="noopener noreferrer">HyperLogLog</a></p><h3 id="cac-lenh-hyperloglog" tabindex="-1"><a class="header-anchor" href="#cac-lenh-hyperloglog"><span>Các lệnh HyperLogLog</span></a></h3><p>Redis cung cấp ba lệnh chính để thao tác với HyperLogLog:</p><ol><li><p><strong>PFADD</strong>: Thêm các phần tử vào HyperLogLog.</p><div class="language-shell" data-highlighter="shiki" data-ext="shell" data-title="shell" style="--shiki-light:#abb2bf;--shiki-dark:#abb2bf;--shiki-light-bg:#282c34;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-dark-pro one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#61AFEF;--shiki-dark:#61AFEF;">PFADD</span><span style="--shiki-light:#98C379;--shiki-dark:#98C379;"> key</span><span style="--shiki-light:#98C379;--shiki-dark:#98C379;"> element</span><span style="--shiki-light:#ABB2BF;--shiki-dark:#ABB2BF;"> [element </span><span style="--shiki-light:#98C379;--shiki-dark:#98C379;">...]</span></span></code></pre></div><p>Ví dụ: <code>PFADD hll_logins user1 user2 user3</code></p></li><li><p><strong>PFCOUNT</strong>: Đếm số lượng phần tử duy nhất trong HyperLogLog.</p><div class="language-shell" data-highlighter="shiki" data-ext="shell" data-title="shell" style="--shiki-light:#abb2bf;--shiki-dark:#abb2bf;--shiki-light-bg:#282c34;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-dark-pro one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#61AFEF;--shiki-dark:#61AFEF;">PFCOUNT</span><span style="--shiki-light:#98C379;--shiki-dark:#98C379;"> key</span><span style="--shiki-light:#ABB2BF;--shiki-dark:#ABB2BF;"> [key </span><span style="--shiki-light:#98C379;--shiki-dark:#98C379;">...]</span></span></code></pre></div><p>Ví dụ: <code>PFCOUNT hll_logins</code></p></li><li><p><strong>PFMERGE</strong>: Hợp nhất nhiều HyperLogLog thành một HyperLogLog mới.</p></li></ol><div class="language-shell" data-highlighter="shiki" data-ext="shell" data-title="shell" style="--shiki-light:#abb2bf;--shiki-dark:#abb2bf;--shiki-light-bg:#282c34;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-dark-pro one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#61AFEF;--shiki-dark:#61AFEF;">   PFMERGE</span><span style="--shiki-light:#98C379;--shiki-dark:#98C379;"> destkey</span><span style="--shiki-light:#98C379;--shiki-dark:#98C379;"> sourcekey</span><span style="--shiki-light:#ABB2BF;--shiki-dark:#ABB2BF;"> [sourcekey </span><span style="--shiki-light:#98C379;--shiki-dark:#98C379;">...]</span></span></code></pre></div><p>Ví dụ: <code>PFMERGE hll_total hll_logins_1 hll_logins_2 hll_logins_3</code></p><h3 id="ung-dung-cua-hyperloglog" tabindex="-1"><a class="header-anchor" href="#ung-dung-cua-hyperloglog"><span>Ứng dụng của HyperLogLog</span></a></h3><h4 id="đem-so-luong-uv-trang-web-hang-trieu-nguoi-dung" tabindex="-1"><a class="header-anchor" href="#đem-so-luong-uv-trang-web-hang-trieu-nguoi-dung"><span>Đếm số lượng UV trang web hàng triệu người dùng</span></a></h4><p>HyperLogLog trong Redis rất phù hợp để đếm số lượng người dùng duy nhất (UV) của hàng triệu người dùng trang web. Lợi thế của nó là chỉ cần dùng khoảng 12 KB bộ nhớ, có thể tính được gần <code>2^64</code> phần tử khác nhau, so với các loại dữ liệu Set và Hash truyền thống cần tiêu tốn nhiều bộ nhớ hơn khi số lượng phần tử tăng lên.</p><p>Trong việc đếm số lượng UV, bạn có thể sử dụng lệnh <code>PFADD</code> để thêm từng người dùng truy cập vào trang vào HyperLogLog:</p><div class="language-shell" data-highlighter="shiki" data-ext="shell" data-title="shell" style="--shiki-light:#abb2bf;--shiki-dark:#abb2bf;--shiki-light-bg:#282c34;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-dark-pro one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#61AFEF;--shiki-dark:#61AFEF;">PFADD</span><span style="--shiki-light:#98C379;--shiki-dark:#98C379;"> page1:uv</span><span style="--shiki-light:#98C379;--shiki-dark:#98C379;"> user1</span><span style="--shiki-light:#98C379;--shiki-dark:#98C379;"> user2</span><span style="--shiki-light:#98C379;--shiki-dark:#98C379;"> user3</span><span style="--shiki-light:#98C379;--shiki-dark:#98C379;"> user4</span><span style="--shiki-light:#98C379;--shiki-dark:#98C379;"> user5</span></span></code></pre></div><p>Sau đó, bạn có thể sử dụng lệnh <code>PFCOUNT</code> để lấy kết quả UV của <code>page1</code>, lệnh này trả về kết quả thống kê từ HyperLogLog.</p><div class="language-shell" data-highlighter="shiki" data-ext="shell" data-title="shell" style="--shiki-light:#abb2bf;--shiki-dark:#abb2bf;--shiki-light-bg:#282c34;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-dark-pro one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#61AFEF;--shiki-dark:#61AFEF;">PFCOUNT</span><span style="--shiki-light:#98C379;--shiki-dark:#98C379;"> page1:uv</span></span></code></pre></div><p>Tuy nhiên, có một điều cần lưu ý, HyperLogLog thực hiện thống kê dựa trên xác suất, do đó kết quả thống kê có độ sai số nhất định, tỷ lệ sai số chuẩn là 0.81%.</p><p>Điều này có nghĩa là kết quả UV bạn tính được bằng HyperLogLog có thể là 1 triệu, nhưng số lượng UV thực tế có thể là 1.01 triệu. Mặc dù tỷ lệ sai số không lớn, nhưng nếu bạn cần kết quả thống kê chính xác hơn thì nên tiếp tục sử dụng các loại dữ liệu Set hoặc Hash.</p><h2 id="geo" tabindex="-1"><a class="header-anchor" href="#geo"><span>GEO</span></a></h2><h3 id="gioi-thieu-ve-geo" tabindex="-1"><a class="header-anchor" href="#gioi-thieu-ve-geo"><span>Giới thiệu về GEO</span></a></h3><p>Redis GEO là một loại dữ liệu mới được giới thiệu từ phiên bản Redis 3.2, chủ yếu được sử dụng để lưu trữ thông tin vị trí địa lý và thực hiện các thao tác trên dữ liệu đã lưu.</p><p>Trong cuộc sống hàng ngày, chúng ta ngày càng phụ thuộc vào các ứng dụng dựa trên dịch vụ dựa trên vị trí (Location-Based Service, LBS), như tìm kiếm &quot;nhà hàng gần đây&quot; hoặc gọi xe qua các ứng dụng đặt xe. Các ứng dụng này sử dụng dữ liệu liên quan đến con người hoặc đối tượng, được biểu diễn dưới dạng tập hợp các tọa độ vĩ độ và kinh độ. GEO rất phù hợp với các tình huống yêu cầu dịch vụ LBS.</p><h3 id="trien-khai-geo" tabindex="-1"><a class="header-anchor" href="#trien-khai-geo"><span>Triển khai GEO</span></a></h3><p>GEO trong Redis không thiết kế một cấu trúc dữ liệu mới mà thay vào đó sử dụng kiểu dữ liệu Zset (Sorted Set) đã có sẵn.</p><p>GEO sử dụng phương pháp mã hóa GeoHash để chuyển đổi các tọa độ vĩ độ và kinh độ thành điểm số trong Sorted Set. Hai cơ chế chính trong việc triển khai là &quot;chia bản đồ hai chiều thành các khoảng&quot; và &quot;mã hóa các khoảng này&quot;. Khi một tập hợp các tọa độ vĩ độ và kinh độ rơi vào một khoảng nào đó, chúng sẽ được biểu diễn bằng giá trị mã hóa của khoảng đó, và giá trị mã hóa này sẽ được sử dụng làm điểm số của các phần tử trong Sorted Set.</p><p>Như vậy, chúng ta có thể lưu trữ các tọa độ vĩ độ và kinh độ vào trong Sorted Set và sử dụng tính năng &quot;tìm kiếm theo khoảng có thứ tự dựa trên điểm số&quot; của Sorted Set để thực hiện các yêu cầu &quot;tìm kiếm gần đây&quot; mà dịch vụ dựa trên vị trí (LBS) thường xuyên sử dụng.</p><h3 id="cac-lenh-geo" tabindex="-1"><a class="header-anchor" href="#cac-lenh-geo"><span>Các lệnh GEO</span></a></h3><div class="language-shell" data-highlighter="shiki" data-ext="shell" data-title="shell" style="--shiki-light:#abb2bf;--shiki-dark:#abb2bf;--shiki-light-bg:#282c34;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-dark-pro one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#7F848E;--shiki-dark:#7F848E;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;"># Lưu trữ vị trí địa lý chỉ định, có thể thêm một hoặc nhiều kinh độ (longitude), vĩ độ (latitude), và tên thành viên (member) vào key chỉ định.</span></span>
<span class="line"><span style="--shiki-light:#61AFEF;--shiki-dark:#61AFEF;">GEOADD</span><span style="--shiki-light:#98C379;--shiki-dark:#98C379;"> key</span><span style="--shiki-light:#98C379;--shiki-dark:#98C379;"> longitude</span><span style="--shiki-light:#98C379;--shiki-dark:#98C379;"> latitude</span><span style="--shiki-light:#98C379;--shiki-dark:#98C379;"> member</span><span style="--shiki-light:#ABB2BF;--shiki-dark:#ABB2BF;"> [longitude </span><span style="--shiki-light:#98C379;--shiki-dark:#98C379;">latitude</span><span style="--shiki-light:#98C379;--shiki-dark:#98C379;"> member</span><span style="--shiki-light:#98C379;--shiki-dark:#98C379;"> ...]</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#7F848E;--shiki-dark:#7F848E;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;"># Trả về vị trí (kinh độ và vĩ độ) của các tên thành viên chỉ định từ key chỉ định, các thành viên không tồn tại trả về nil.</span></span>
<span class="line"><span style="--shiki-light:#61AFEF;--shiki-dark:#61AFEF;">GEOPOS</span><span style="--shiki-light:#98C379;--shiki-dark:#98C379;"> key</span><span style="--shiki-light:#98C379;--shiki-dark:#98C379;"> member</span><span style="--shiki-light:#ABB2BF;--shiki-dark:#ABB2BF;"> [member </span><span style="--shiki-light:#98C379;--shiki-dark:#98C379;">...]</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#7F848E;--shiki-dark:#7F848E;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;"># Trả về khoảng cách giữa hai vị trí địa lý chỉ định.</span></span>
<span class="line"><span style="--shiki-light:#61AFEF;--shiki-dark:#61AFEF;">GEODIST</span><span style="--shiki-light:#98C379;--shiki-dark:#98C379;"> key</span><span style="--shiki-light:#98C379;--shiki-dark:#98C379;"> member1</span><span style="--shiki-light:#98C379;--shiki-dark:#98C379;"> member2</span><span style="--shiki-light:#ABB2BF;--shiki-dark:#ABB2BF;"> [m|</span><span style="--shiki-light:#61AFEF;--shiki-dark:#61AFEF;">km</span><span style="--shiki-light:#ABB2BF;--shiki-dark:#ABB2BF;">|</span><span style="--shiki-light:#61AFEF;--shiki-dark:#61AFEF;">ft</span><span style="--shiki-light:#ABB2BF;--shiki-dark:#ABB2BF;">|</span><span style="--shiki-light:#61AFEF;--shiki-dark:#61AFEF;">mi]</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#7F848E;--shiki-dark:#7F848E;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;"># Dựa trên tọa độ vĩ độ và kinh độ mà người dùng cung cấp, trả về tập hợp các vị trí địa lý nằm trong phạm vi chỉ định.</span></span>
<span class="line"><span style="--shiki-light:#61AFEF;--shiki-dark:#61AFEF;">GEORADIUS</span><span style="--shiki-light:#98C379;--shiki-dark:#98C379;"> key</span><span style="--shiki-light:#98C379;--shiki-dark:#98C379;"> longitude</span><span style="--shiki-light:#98C379;--shiki-dark:#98C379;"> latitude</span><span style="--shiki-light:#98C379;--shiki-dark:#98C379;"> radius</span><span style="--shiki-light:#98C379;--shiki-dark:#98C379;"> m</span><span style="--shiki-light:#ABB2BF;--shiki-dark:#ABB2BF;">|</span><span style="--shiki-light:#61AFEF;--shiki-dark:#61AFEF;">km</span><span style="--shiki-light:#ABB2BF;--shiki-dark:#ABB2BF;">|</span><span style="--shiki-light:#61AFEF;--shiki-dark:#61AFEF;">ft</span><span style="--shiki-light:#ABB2BF;--shiki-dark:#ABB2BF;">|</span><span style="--shiki-light:#61AFEF;--shiki-dark:#61AFEF;">mi</span><span style="--shiki-light:#ABB2BF;--shiki-dark:#ABB2BF;"> [WITHCOORD] [WITHDIST] [WITHHASH] [COUNT count] [ASC|DESC] [STORE key] [STOREDIST key]</span></span></code></pre></div><h3 id="ung-dung-cua-geo" tabindex="-1"><a class="header-anchor" href="#ung-dung-cua-geo"><span>Ứng dụng của GEO</span></a></h3><h4 id="goi-xe-qua-ung-dung-nhu-cua-didi" tabindex="-1"><a class="header-anchor" href="#goi-xe-qua-ung-dung-nhu-cua-didi"><span>Gọi xe qua ứng dụng như của Didi</span></a></h4><p>Ví dụ về cách sử dụng lệnh GEOADD và GEORADIUS trong kịch bản gọi xe của Didi.</p><p>Giả sử xe có ID là 33, vị trí kinh độ và vĩ độ là (116.034579, 39.030452), chúng ta có thể lưu trữ vị trí hiện tại của xe số ID 33 vào tập hợp GEO bằng cách sau:</p><div class="language-shell" data-highlighter="shiki" data-ext="shell" data-title="shell" style="--shiki-light:#abb2bf;--shiki-dark:#abb2bf;--shiki-light-bg:#282c34;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-dark-pro one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#61AFEF;--shiki-dark:#61AFEF;">GEOADD</span><span style="--shiki-light:#98C379;--shiki-dark:#98C379;"> cars:locations</span><span style="--shiki-light:#D19A66;--shiki-dark:#D19A66;"> 116.034579</span><span style="--shiki-light:#D19A66;--shiki-dark:#D19A66;"> 39.030452</span><span style="--shiki-light:#D19A66;--shiki-dark:#D19A66;"> 33</span></span></code></pre></div><p>Khi người dùng muốn tìm xe gần nhất, ứng dụng LBS có thể sử dụng lệnh GEORADIUS.</p><p>Ví dụ, khi ứng dụng LBS thực thi lệnh sau đây, Redis sẽ dựa trên thông tin tọa độ vĩ độ và kinh độ (116.054579, 39.030452) được cung cấp, tìm kiếm thông tin xe trong bán kính 5 km tính từ tọa độ này và trả về cho ứng dụng LBS.</p><div class="language-shell" data-highlighter="shiki" data-ext="shell" data-title="shell" style="--shiki-light:#abb2bf;--shiki-dark:#abb2bf;--shiki-light-bg:#282c34;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-dark-pro one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#61AFEF;--shiki-dark:#61AFEF;">GEORADIUS</span><span style="--shiki-light:#98C379;--shiki-dark:#98C379;"> cars:locations</span><span style="--shiki-light:#D19A66;--shiki-dark:#D19A66;"> 116.054579</span><span style="--shiki-light:#D19A66;--shiki-dark:#D19A66;"> 39.030452</span><span style="--shiki-light:#D19A66;--shiki-dark:#D19A66;"> 5</span><span style="--shiki-light:#98C379;--shiki-dark:#98C379;"> km</span><span style="--shiki-light:#98C379;--shiki-dark:#98C379;"> ASC</span><span style="--shiki-light:#98C379;--shiki-dark:#98C379;"> COUNT</span><span style="--shiki-light:#D19A66;--shiki-dark:#D19A66;"> 10</span></span></code></pre></div><h2 id="stream" tabindex="-1"><a class="header-anchor" href="#stream"><span>Stream</span></a></h2><h3 id="gioi-thieu-ve-stream" tabindex="-1"><a class="header-anchor" href="#gioi-thieu-ve-stream"><span>Giới thiệu về Stream</span></a></h3><p>Redis Stream là một loại dữ liệu mới được thêm vào từ phiên bản Redis 5.0, được Redis thiết kế đặc biệt cho các hệ thống hàng đợi tin nhắn.</p><p>Trước khi có Redis Stream trong Redis 5.0, các cách triển khai hàng đợi tin nhắn đều có những hạn chế riêng, ví dụ như:</p><ul><li>Mô hình publish-subscribe không hỗ trợ lưu trữ vĩnh viễn, do đó không đảm bảo việc lưu trữ tin nhắn một cách đáng tin cậy và không thể đọc các tin nhắn lịch sử cho các khách hàng kết nối lại sau khi mất kết nối.</li><li>Danh sách (List) không thể hỗ trợ tiêu thụ lại (reconsume) các tin nhắn, một khi tin nhắn đã được tiêu thụ thì sẽ bị xóa, và nhà sản xuất (producer) phải tự thực hiện việc tạo ID duy nhất toàn cầu.</li></ul><p>Dựa trên các vấn đề này, Redis 5.0 đã ra mắt loại dữ liệu Stream, là tính năng quan trọng nhất của phiên bản này, được thiết kế để hoàn thành hệ thống hàng đợi tin nhắn một cách hoàn hảo. Stream hỗ trợ lưu trữ tin nhắn một cách vĩnh viễn, tự động tạo ID duy nhất toàn cầu, hỗ trợ phương thức xác nhận (ack) tin nhắn, hỗ trợ mô hình nhóm tiêu thụ (consumer group), giúp cho hệ thống hàng đợi tin nhắn trở nên ổn định và tin cậy hơn.</p><h3 id="cac-lenh-cua-stream" tabindex="-1"><a class="header-anchor" href="#cac-lenh-cua-stream"><span>Các lệnh của Stream</span></a></h3><p>Các lệnh hoạt động với hàng đợi tin nhắn Stream:</p><ul><li><strong>XADD</strong>: Thêm tin nhắn vào hàng đợi, đảm bảo thứ tự và có thể tự động tạo ID duy nhất toàn cầu.</li><li><strong>XLEN</strong>: Truy vấn độ dài của hàng đợi tin nhắn.</li><li><strong>XREAD</strong>: Đọc tin nhắn từ hàng đợi, có thể đọc dữ liệu theo ID.</li><li><strong>XDEL</strong>: Xóa tin nhắn dựa trên ID của tin nhắn.</li><li><strong>DEL</strong>: Xóa toàn bộ Stream.</li><li><strong>XRANGE</strong>: Đọc tin nhắn trong một khoảng cụ thể.</li><li><strong>XREADGROUP</strong>: Đọc tin nhắn dưới dạng nhóm tiêu thụ.</li><li><strong>XPENDING</strong> và <strong>XACK</strong>: <ul><li><strong>XPENDING</strong>: Truy vấn các tin nhắn &quot;đã đọc nhưng chưa được xác nhận&quot; của mỗi nhóm tiêu thụ.</li><li><strong>XACK</strong>: Xác nhận rằng việc xử lý tin nhắn đã hoàn thành đối với hàng đợi tin nhắn.</li></ul></li></ul><p>Các lệnh này giúp trong việc quản lý và điều khiển các tin nhắn trong hệ thống hàng đợi Stream của Redis một cách linh hoạt và hiệu quả.</p><h3 id="ung-dung-stream" tabindex="-1"><a class="header-anchor" href="#ung-dung-stream"><span>Ứng dụng Stream</span></a></h3><h4 id="hang-đoi-tin-nhan" tabindex="-1"><a class="header-anchor" href="#hang-đoi-tin-nhan"><span>Hàng đợi tin nhắn</span></a></h4><p>Nhà sản xuất sử dụng lệnh XADD để chèn một tin nhắn:</p><div class="language-shell" data-highlighter="shiki" data-ext="shell" data-title="shell" style="--shiki-light:#abb2bf;--shiki-dark:#abb2bf;--shiki-light-bg:#282c34;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-dark-pro one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#7F848E;--shiki-dark:#7F848E;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;"># * biểu thị để Redis tự động tạo một ID duy nhất toàn cầu cho dữ liệu được chèn</span></span>
<span class="line"><span style="--shiki-light:#7F848E;--shiki-dark:#7F848E;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;"># Chèn một tin nhắn vào hàng đợi tin nhắn có tên là mymq, với khóa là name và giá trị là xiaolin</span></span>
<span class="line"><span style="--shiki-light:#ABB2BF;--shiki-dark:#ABB2BF;">&gt; XADD mymq * name xiaolin</span></span>
<span class="line"><span style="--shiki-light:#61AFEF;--shiki-dark:#61AFEF;">&quot;1654254953808-0&quot;</span></span></code></pre></div><p>Sau khi chèn thành công, Redis sẽ trả về một ID duy nhất toàn cầu là &quot;1654254953808-0&quot;. ID này bao gồm hai phần:</p><ul><li>Phần đầu tiên &quot;1654254953808&quot; là thời gian hiện tại tính bằng mili giây khi dữ liệu được chèn vào;</li><li>Phần thứ hai chỉ ra số thứ tự của tin nhắn trong cùng một mili giây. Ví dụ, &quot;1654254953808-0&quot; biểu thị tin nhắn đầu tiên trong mili giây &quot;1654254953808&quot;.</li></ul><p>Người tiêu thụ sử dụng lệnh XREAD để đọc tin nhắn từ hàng đợi khi có thể chỉ định một ID tin nhắn và bắt đầu đọc tin nhắn tiếp theo sau ID này (lưu ý là đọc tin nhắn bắt đầu từ ID tin nhắn nhập vào mà không phải là ID đã nhập vào).</p><div class="language-shell" data-highlighter="shiki" data-ext="shell" data-title="shell" style="--shiki-light:#abb2bf;--shiki-dark:#abb2bf;--shiki-light-bg:#282c34;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-dark-pro one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#7F848E;--shiki-dark:#7F848E;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;"># Bắt đầu đọc tất cả các tin nhắn sau ID &quot;1654254953807-0&quot; (trong ví dụ này là có 1 tin nhắn)</span></span>
<span class="line"><span style="--shiki-light:#ABB2BF;--shiki-dark:#ABB2BF;">&gt; XREAD STREAMS mymq 1654254953807-0</span></span>
<span class="line"><span style="--shiki-light:#61AFEF;--shiki-dark:#61AFEF;">1</span><span style="--shiki-light:#ABB2BF;--shiki-dark:#ABB2BF;">) 1) </span><span style="--shiki-light:#98C379;--shiki-dark:#98C379;">&quot;mymq&quot;</span></span>
<span class="line"><span style="--shiki-light:#61AFEF;--shiki-dark:#61AFEF;">   2</span><span style="--shiki-light:#ABB2BF;--shiki-dark:#ABB2BF;">) 1) 1) </span><span style="--shiki-light:#98C379;--shiki-dark:#98C379;">&quot;1654254953808-0&quot;</span></span>
<span class="line"><span style="--shiki-light:#61AFEF;--shiki-dark:#61AFEF;">         2</span><span style="--shiki-light:#ABB2BF;--shiki-dark:#ABB2BF;">) 1) </span><span style="--shiki-light:#98C379;--shiki-dark:#98C379;">&quot;name&quot;</span></span>
<span class="line"><span style="--shiki-light:#61AFEF;--shiki-dark:#61AFEF;">            2</span><span style="--shiki-light:#ABB2BF;--shiki-dark:#ABB2BF;">) </span><span style="--shiki-light:#98C379;--shiki-dark:#98C379;">&quot;xiaolin&quot;</span></span></code></pre></div><p>Nếu bạn muốn thực hiện đọc chặn (block-read) khi không có dữ liệu, bạn có thể thiết lập BLOCK khi sử dụng lệnh XREAD, tương tự như hoạt động BRPOP.</p><p>Ví dụ, lệnh sau đây thiết lập BLOCK là 10000, đơn vị là mili giây, cho biết rằng XREAD sẽ chặn trong 10000 mili giây (tức là 10 giây) khi đọc tin nhắn mới nhất và sau đó trả về.</p><div class="language-shell" data-highlighter="shiki" data-ext="shell" data-title="shell" style="--shiki-light:#abb2bf;--shiki-dark:#abb2bf;--shiki-light-bg:#282c34;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-dark-pro one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#7F848E;--shiki-dark:#7F848E;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;"># Ký tự “$” cuối cùng của lệnh biểu thị rằng đang đọc tin nhắn mới nhất</span></span>
<span class="line"><span style="--shiki-light:#ABB2BF;--shiki-dark:#ABB2BF;">&gt; XREAD BLOCK 10000 STREAMS mymq $</span></span>
<span class="line"><span style="--shiki-light:#ABB2BF;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#61AFEF;--shiki-dark:#61AFEF;">nil</span><span style="--shiki-light:#ABB2BF;--shiki-dark:#ABB2BF;">)</span></span>
<span class="line"><span style="--shiki-light:#ABB2BF;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#61AFEF;--shiki-dark:#61AFEF;">10.00s</span><span style="--shiki-light:#ABB2BF;--shiki-dark:#ABB2BF;">)</span></span></code></pre></div><p>Các phương pháp cơ bản của Stream, sử dụng XADD để lưu trữ tin nhắn và XREAD để đọc tin nhắn chặn có thể triển khai một phiên bản đơn giản của hàng đợi tin nhắn, các quy trình tương tác như hình dưới đây:</p><blockquote><p>Các thao tác này đã được hỗ trợ bởi List, và sau đó chúng ta sẽ xem xét các tính năng đặc biệt của Stream.</p></blockquote><p>Stream có thể sử dụng <strong>XGROUP để tạo nhóm tiêu thụ</strong>, sau đó Stream có thể sử dụng lệnh XREADGROUP để các tiêu thụ trong nhóm đọc tin nhắn.</p><p>Tạo hai nhóm tiêu thụ, mỗi nhóm đọc từ hàng đợi tin nhắn mymq, bắt đầu từ tin nhắn đầu tiên:</p><div class="language-shell" data-highlighter="shiki" data-ext="shell" data-title="shell" style="--shiki-light:#abb2bf;--shiki-dark:#abb2bf;--shiki-light-bg:#282c34;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-dark-pro one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#7F848E;--shiki-dark:#7F848E;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;"># Tạo nhóm tiêu thụ có tên là group1, bắt đầu từ tin nhắn đầu tiên (0-0).</span></span>
<span class="line"><span style="--shiki-light:#ABB2BF;--shiki-dark:#ABB2BF;">&gt; XGROUP CREATE mymq group1 0-0</span></span>
<span class="line"><span style="--shiki-light:#61AFEF;--shiki-dark:#61AFEF;">OK</span></span>
<span class="line"><span style="--shiki-light:#7F848E;--shiki-dark:#7F848E;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;"># Tạo nhóm tiêu thụ có tên là group2, bắt đầu từ tin nhắn đầu tiên (0-0).</span></span>
<span class="line"><span style="--shiki-light:#ABB2BF;--shiki-dark:#ABB2BF;">&gt; XGROUP CREATE mymq group2 0-0</span></span>
<span class="line"><span style="--shiki-light:#61AFEF;--shiki-dark:#61AFEF;">OK</span></span></code></pre></div><p>Lệnh để tiêu thụ consumer1 trong nhóm group1 đọc tất cả các tin nhắn từ hàng đợi tin nhắn mymq như sau:</p><div class="language-shell" data-highlighter="shiki" data-ext="shell" data-title="shell" style="--shiki-light:#abb2bf;--shiki-dark:#abb2bf;--shiki-light-bg:#282c34;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-dark-pro one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#7F848E;--shiki-dark:#7F848E;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;"># Tham số cuối cùng của lệnh là “&gt;”, chỉ định đọc từ tin nhắn chưa được tiêu thụ đầu tiên.</span></span>
<span class="line"><span style="--shiki-light:#ABB2BF;--shiki-dark:#ABB2BF;">&gt; XREADGROUP GROUP group1 consumer1 STREAMS mymq &gt;</span></span>
<span class="line"><span style="--shiki-light:#61AFEF;--shiki-dark:#61AFEF;">1</span><span style="--shiki-light:#ABB2BF;--shiki-dark:#ABB2BF;">) 1) </span><span style="--shiki-light:#98C379;--shiki-dark:#98C379;">&quot;mymq&quot;</span></span>
<span class="line"><span style="--shiki-light:#61AFEF;--shiki-dark:#61AFEF;">   2</span><span style="--shiki-light:#ABB2BF;--shiki-dark:#ABB2BF;">) 1) 1) </span><span style="--shiki-light:#98C379;--shiki-dark:#98C379;">&quot;1654254953808-0&quot;</span></span>
<span class="line"><span style="--shiki-light:#61AFEF;--shiki-dark:#61AFEF;">         2</span><span style="--shiki-light:#ABB2BF;--shiki-dark:#ABB2BF;">) 1) </span><span style="--shiki-light:#98C379;--shiki-dark:#98C379;">&quot;name&quot;</span></span>
<span class="line"><span style="--shiki-light:#61AFEF;--shiki-dark:#61AFEF;">            2</span><span style="--shiki-light:#ABB2BF;--shiki-dark:#ABB2BF;">) </span><span style="--shiki-light:#98C379;--shiki-dark:#98C379;">&quot;xiaolin&quot;</span></span></code></pre></div><p><strong>Một khi một tin nhắn trong hàng đợi tin nhắn đã được tiêu thụ bởi một tiêu thụ trong nhóm, thì không thể tiêu thụ lại bởi các tiêu thụ khác trong cùng một nhóm</strong>, điều này có nghĩa là các tiêu thụ trong cùng một nhóm không thể tiêu thụ cùng một tin nhắn.</p><p>Ví dụ, nếu chúng ta thực hiện lại lệnh XREADGROUP đã nêu, kết quả sẽ là giá trị null:</p><div class="language-shell" data-highlighter="shiki" data-ext="shell" data-title="shell" style="--shiki-light:#abb2bf;--shiki-dark:#abb2bf;--shiki-light-bg:#282c34;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-dark-pro one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#ABB2BF;--shiki-dark:#ABB2BF;">&gt; XREADGROUP GROUP group1 consumer1 STREAMS mymq &gt;</span></span>
<span class="line"><span style="--shiki-light:#ABB2BF;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#61AFEF;--shiki-dark:#61AFEF;">nil</span><span style="--shiki-light:#ABB2BF;--shiki-dark:#ABB2BF;">)</span></span></code></pre></div><p>Tuy nhiên, <strong>các tiêu thụ trong các nhóm khác nhau có thể tiêu thụ cùng một tin nhắn (với điều kiện rằng các nhóm tiêu thụ đã chỉ định cùng một vị trí bắt đầu đọc tin nhắn)</strong>.</p><p>Ví dụ, sau khi tiêu thụ consumer1 trong nhóm group1 đã tiêu thụ tin nhắn với ID 1654254953808-0, consumer1 trong nhóm group2 có thể tiếp tục tiêu thụ tin nhắn:</p><div class="language-shell" data-highlighter="shiki" data-ext="shell" data-title="shell" style="--shiki-light:#abb2bf;--shiki-dark:#abb2bf;--shiki-light-bg:#282c34;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-dark-pro one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#ABB2BF;--shiki-dark:#ABB2BF;">&gt; XREADGROUP GROUP group2 consumer1 STREAMS mymq &gt;</span></span>
<span class="line"><span style="--shiki-light:#61AFEF;--shiki-dark:#61AFEF;">1</span><span style="--shiki-light:#ABB2BF;--shiki-dark:#ABB2BF;">) 1) </span><span style="--shiki-light:#98C379;--shiki-dark:#98C379;">&quot;mymq&quot;</span></span>
<span class="line"><span style="--shiki-light:#61AFEF;--shiki-dark:#61AFEF;">   2</span><span style="--shiki-light:#ABB2BF;--shiki-dark:#ABB2BF;">) 1) 1) </span><span style="--shiki-light:#98C379;--shiki-dark:#98C379;">&quot;1654254953808-0&quot;</span></span>
<span class="line"><span style="--shiki-light:#61AFEF;--shiki-dark:#61AFEF;">         2</span><span style="--shiki-light:#ABB2BF;--shiki-dark:#ABB2BF;">) 1) </span><span style="--shiki-light:#98C379;--shiki-dark:#98C379;">&quot;name&quot;</span></span>
<span class="line"><span style="--shiki-light:#61AFEF;--shiki-dark:#61AFEF;">            2</span><span style="--shiki-light:#ABB2BF;--shiki-dark:#ABB2BF;">) </span><span style="--shiki-light:#98C379;--shiki-dark:#98C379;">&quot;xiaolin&quot;</span></span></code></pre></div><p>Vì tôi đã tạo hai nhóm tiêu thụ để đọc từ tin nhắn đầu tiên, bạn có thể thấy rằng tiêu thụ trong nhóm thứ hai vẫn có thể tiêu thụ tin nhắn với ID 1654254953808-0. Do đó, các tiêu thụ trong các nhóm khác nhau có thể tiêu thụ cùng một tin nhắn.</p><p>Mục đích của việc sử dụng nhóm tiêu thụ là để các tiêu thụ trong nhóm chia sẻ việc đọc tin nhắn, do đó, thường ta sẽ cho mỗi tiêu thụ đọc một phần tin nhắn để phân phối tải đọc tin nhắn đều đặn giữa các tiêu thụ.</p><p>Ví dụ, chúng ta thực hiện các lệnh sau để cho consumer1, 2, 3 trong group2 mỗi người đọc một tin nhắn.</p><div class="language-shell line-numbers-mode" data-highlighter="shiki" data-ext="shell" data-title="shell" style="--shiki-light:#abb2bf;--shiki-dark:#abb2bf;--shiki-light-bg:#282c34;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-dark-pro one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#7F848E;--shiki-dark:#7F848E;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;"># Cho consumer1 trong group2 đọc một tin nhắn từ hàng đợi tin nhắn mymq</span></span>
<span class="line"><span style="--shiki-light:#ABB2BF;--shiki-dark:#ABB2BF;">&gt; XREADGROUP GROUP group2 consumer1 COUNT 1 STREAMS mymq &gt;</span></span>
<span class="line"><span style="--shiki-light:#61AFEF;--shiki-dark:#61AFEF;">1</span><span style="--shiki-light:#ABB2BF;--shiki-dark:#ABB2BF;">) 1) </span><span style="--shiki-light:#98C379;--shiki-dark:#98C379;">&quot;mymq&quot;</span></span>
<span class="line"><span style="--shiki-light:#61AFEF;--shiki-dark:#61AFEF;">   2</span><span style="--shiki-light:#ABB2BF;--shiki-dark:#ABB2BF;">) 1) 1) </span><span style="--shiki-light:#98C379;--shiki-dark:#98C379;">&quot;1654254953808-0&quot;</span></span>
<span class="line"><span style="--shiki-light:#61AFEF;--shiki-dark:#61AFEF;">         2</span><span style="--shiki-light:#ABB2BF;--shiki-dark:#ABB2BF;">) 1) </span><span style="--shiki-light:#98C379;--shiki-dark:#98C379;">&quot;name&quot;</span></span>
<span class="line"><span style="--shiki-light:#61AFEF;--shiki-dark:#61AFEF;">            2</span><span style="--shiki-light:#ABB2BF;--shiki-dark:#ABB2BF;">) </span><span style="--shiki-light:#98C379;--shiki-dark:#98C379;">&quot;xiaolin&quot;</span></span>
<span class="line"><span style="--shiki-light:#7F848E;--shiki-dark:#7F848E;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;"># Cho consumer2 trong group2 đọc một tin nhắn từ hàng đợi tin nhắn mymq</span></span>
<span class="line"><span style="--shiki-light:#ABB2BF;--shiki-dark:#ABB2BF;">&gt; XREADGROUP GROUP group2 consumer2 COUNT 1 STREAMS mymq &gt;</span></span>
<span class="line"><span style="--shiki-light:#61AFEF;--shiki-dark:#61AFEF;">1</span><span style="--shiki-light:#ABB2BF;--shiki-dark:#ABB2BF;">) 1) </span><span style="--shiki-light:#98C379;--shiki-dark:#98C379;">&quot;mymq&quot;</span></span>
<span class="line"><span style="--shiki-light:#61AFEF;--shiki-dark:#61AFEF;">   2</span><span style="--shiki-light:#ABB2BF;--shiki-dark:#ABB2BF;">) 1) 1) </span><span style="--shiki-light:#98C379;--shiki-dark:#98C379;">&quot;1654256265584-0&quot;</span></span>
<span class="line"><span style="--shiki-light:#61AFEF;--shiki-dark:#61AFEF;">         2</span><span style="--shiki-light:#ABB2BF;--shiki-dark:#ABB2BF;">) 1) </span><span style="--shiki-light:#98C379;--shiki-dark:#98C379;">&quot;name&quot;</span></span>
<span class="line"><span style="--shiki-light:#61AFEF;--shiki-dark:#61AFEF;">            2</span><span style="--shiki-light:#ABB2BF;--shiki-dark:#ABB2BF;">) </span><span style="--shiki-light:#98C379;--shiki-dark:#98C379;">&quot;xiaolincoding&quot;</span></span>
<span class="line"><span style="--shiki-light:#7F848E;--shiki-dark:#7F848E;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;"># Cho consumer3 trong group2 đọc một tin nhắn từ hàng đợi tin nhắn mymq</span></span>
<span class="line"><span style="--shiki-light:#ABB2BF;--shiki-dark:#ABB2BF;">&gt; XREADGROUP GROUP group2 consumer3 COUNT 1 STREAMS mymq &gt;</span></span>
<span class="line"><span style="--shiki-light:#61AFEF;--shiki-dark:#61AFEF;">1</span><span style="--shiki-light:#ABB2BF;--shiki-dark:#ABB2BF;">) 1) </span><span style="--shiki-light:#98C379;--shiki-dark:#98C379;">&quot;mymq&quot;</span></span>
<span class="line"><span style="--shiki-light:#61AFEF;--shiki-dark:#61AFEF;">   2</span><span style="--shiki-light:#ABB2BF;--shiki-dark:#ABB2BF;">) 1) 1) </span><span style="--shiki-light:#98C379;--shiki-dark:#98C379;">&quot;1654256271337-0&quot;</span></span>
<span class="line"><span style="--shiki-light:#61AFEF;--shiki-dark:#61AFEF;">         2</span><span style="--shiki-light:#ABB2BF;--shiki-dark:#ABB2BF;">) 1) </span><span style="--shiki-light:#98C379;--shiki-dark:#98C379;">&quot;name&quot;</span></span>
<span class="line"><span style="--shiki-light:#61AFEF;--shiki-dark:#61AFEF;">            2</span><span style="--shiki-light:#ABB2BF;--shiki-dark:#ABB2BF;">) </span><span style="--shiki-light:#98C379;--shiki-dark:#98C379;">&quot;Tom&quot;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>Dựa trên Stream để triển khai hàng đợi tin nhắn, làm thế nào để đảm bảo rằng người tiêu thụ có thể đọc tin nhắn chưa được xử lý khi gặp sự cố hoặc khởi động lại sau khi bị gián đoạn?</p></blockquote><p>Streams tự động sử dụng danh sách nội bộ (gọi là PENDING List) để lưu trữ tin nhắn mà mỗi tiêu thụ trong nhóm đã đọc, cho đến khi tiêu thụ gửi lệnh XACK cho Streams để thông báo rằng &quot;tin nhắn đã được xử lý xong&quot;.</p><p>Xác nhận tiêu thụ tăng cường tính tin cậy của tin nhắn. Thông thường, sau khi xử lý công việc, cần thực hiện lệnh XACK để xác nhận rằng tin nhắn đã được xử lý. Toàn bộ quy trình hoạt động được thực hiện như trong hình dưới đây:</p><p>Nếu tiêu thụ không xử lý tin nhắn thành công, nó sẽ không gửi lệnh XACK cho Streams, và tin nhắn sẽ tiếp tục được lưu trữ. Khi đó, <strong>tiêu thụ có thể sử dụng lệnh XPENDING để xem các tin nhắn đã được đọc nhưng chưa được xác nhận đã xử lý</strong> sau khi khởi động lại.</p><p>Ví dụ, chúng ta sẽ xem xét số lượng các tin nhắn mà từng người tiêu thụ trong group2 đã đọc nhưng chưa xác nhận, các lệnh như sau:</p><div class="language-shell" data-highlighter="shiki" data-ext="shell" data-title="shell" style="--shiki-light:#abb2bf;--shiki-dark:#abb2bf;--shiki-light-bg:#282c34;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-dark-pro one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#61AFEF;--shiki-dark:#61AFEF;">127.0.0.1:6379</span><span style="--shiki-light:#ABB2BF;--shiki-dark:#ABB2BF;">&gt; </span><span style="--shiki-light:#98C379;--shiki-dark:#98C379;">XPENDING</span><span style="--shiki-light:#98C379;--shiki-dark:#98C379;"> mymq</span><span style="--shiki-light:#98C379;--shiki-dark:#98C379;"> group2</span></span>
<span class="line"><span style="--shiki-light:#61AFEF;--shiki-dark:#61AFEF;">1</span><span style="--shiki-light:#ABB2BF;--shiki-dark:#ABB2BF;">) (</span><span style="--shiki-light:#61AFEF;--shiki-dark:#61AFEF;">integer</span><span style="--shiki-light:#ABB2BF;--shiki-dark:#ABB2BF;">) 3</span></span>
<span class="line"><span style="--shiki-light:#61AFEF;--shiki-dark:#61AFEF;">2</span><span style="--shiki-light:#ABB2BF;--shiki-dark:#ABB2BF;">) </span><span style="--shiki-light:#98C379;--shiki-dark:#98C379;">&quot;1654254953808-0&quot;</span><span style="--shiki-light:#7F848E;--shiki-dark:#7F848E;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;">  # Đại diện cho ID tin nhắn nhỏ nhất mà từng người tiêu thụ trong group2 đã đọc</span></span>
<span class="line"><span style="--shiki-light:#61AFEF;--shiki-dark:#61AFEF;">3</span><span style="--shiki-light:#ABB2BF;--shiki-dark:#ABB2BF;">) </span><span style="--shiki-light:#98C379;--shiki-dark:#98C379;">&quot;1654256271337-0&quot;</span><span style="--shiki-light:#7F848E;--shiki-dark:#7F848E;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;">  # Đại diện cho ID tin nhắn lớn nhất mà từng người tiêu thụ trong group2 đã đọc</span></span>
<span class="line"><span style="--shiki-light:#61AFEF;--shiki-dark:#61AFEF;">4</span><span style="--shiki-light:#ABB2BF;--shiki-dark:#ABB2BF;">) 1) 1) </span><span style="--shiki-light:#98C379;--shiki-dark:#98C379;">&quot;consumer1&quot;</span></span>
<span class="line"><span style="--shiki-light:#61AFEF;--shiki-dark:#61AFEF;">      2</span><span style="--shiki-light:#ABB2BF;--shiki-dark:#ABB2BF;">) </span><span style="--shiki-light:#98C379;--shiki-dark:#98C379;">&quot;1&quot;</span></span>
<span class="line"><span style="--shiki-light:#61AFEF;--shiki-dark:#61AFEF;">   2</span><span style="--shiki-light:#ABB2BF;--shiki-dark:#ABB2BF;">) 1) </span><span style="--shiki-light:#98C379;--shiki-dark:#98C379;">&quot;consumer2&quot;</span></span>
<span class="line"><span style="--shiki-light:#61AFEF;--shiki-dark:#61AFEF;">      2</span><span style="--shiki-light:#ABB2BF;--shiki-dark:#ABB2BF;">) </span><span style="--shiki-light:#98C379;--shiki-dark:#98C379;">&quot;1&quot;</span></span>
<span class="line"><span style="--shiki-light:#61AFEF;--shiki-dark:#61AFEF;">   3</span><span style="--shiki-light:#ABB2BF;--shiki-dark:#ABB2BF;">) 1) </span><span style="--shiki-light:#98C379;--shiki-dark:#98C379;">&quot;consumer3&quot;</span></span>
<span class="line"><span style="--shiki-light:#61AFEF;--shiki-dark:#61AFEF;">      2</span><span style="--shiki-light:#ABB2BF;--shiki-dark:#ABB2BF;">) </span><span style="--shiki-light:#98C379;--shiki-dark:#98C379;">&quot;1&quot;</span></span></code></pre></div><p>Nếu muốn xem những dữ liệu cụ thể nào mà một người tiêu thụ đã đọc, bạn có thể thực thi các lệnh như sau:</p><div class="language-shell" data-highlighter="shiki" data-ext="shell" data-title="shell" style="--shiki-light:#abb2bf;--shiki-dark:#abb2bf;--shiki-light-bg:#282c34;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-dark-pro one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#7F848E;--shiki-dark:#7F848E;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;"># Xem group2 trong consumer2 đã đọc tin nhắn từ hàng đợi tin nhắn mymq</span></span>
<span class="line"><span style="--shiki-light:#ABB2BF;--shiki-dark:#ABB2BF;">&gt; XPENDING mymq group2 - + 10 consumer2</span></span>
<span class="line"><span style="--shiki-light:#61AFEF;--shiki-dark:#61AFEF;">1</span><span style="--shiki-light:#ABB2BF;--shiki-dark:#ABB2BF;">) 1) </span><span style="--shiki-light:#98C379;--shiki-dark:#98C379;">&quot;1654256265584-0&quot;</span></span>
<span class="line"><span style="--shiki-light:#61AFEF;--shiki-dark:#61AFEF;">   2</span><span style="--shiki-light:#ABB2BF;--shiki-dark:#ABB2BF;">) </span><span style="--shiki-light:#98C379;--shiki-dark:#98C379;">&quot;consumer2&quot;</span></span>
<span class="line"><span style="--shiki-light:#61AFEF;--shiki-dark:#61AFEF;">   3</span><span style="--shiki-light:#ABB2BF;--shiki-dark:#ABB2BF;">) (</span><span style="--shiki-light:#61AFEF;--shiki-dark:#61AFEF;">integer</span><span style="--shiki-light:#ABB2BF;--shiki-dark:#ABB2BF;">) 410700</span></span>
<span class="line"><span style="--shiki-light:#61AFEF;--shiki-dark:#61AFEF;">   4</span><span style="--shiki-light:#ABB2BF;--shiki-dark:#ABB2BF;">) (</span><span style="--shiki-light:#61AFEF;--shiki-dark:#61AFEF;">integer</span><span style="--shiki-light:#ABB2BF;--shiki-dark:#ABB2BF;">) 1</span></span></code></pre></div><p>Có thể thấy rằng, consumer2 đã đọc ID tin nhắn là 1654256265584-0.</p><p><strong>Một khi tin nhắn 1654256265584-0 đã được consumer2 xử lý, consumer2 có thể sử dụng lệnh XACK để thông báo cho Streams, và sau đó tin nhắn này sẽ được xóa</strong>.</p><div class="language-shell" data-highlighter="shiki" data-ext="shell" data-title="shell" style="--shiki-light:#abb2bf;--shiki-dark:#abb2bf;--shiki-light-bg:#282c34;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-dark-pro one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#ABB2BF;--shiki-dark:#ABB2BF;">&gt; XACK mymq group2 1654256265584-0</span></span>
<span class="line"><span style="--shiki-light:#ABB2BF;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#61AFEF;--shiki-dark:#61AFEF;">integer</span><span style="--shiki-light:#ABB2BF;--shiki-dark:#ABB2BF;">) </span><span style="--shiki-light:#61AFEF;--shiki-dark:#61AFEF;">1</span></span></code></pre></div><p>Khi chúng ta sử dụng lại lệnh XPENDING để xem, chúng ta có thể thấy rằng consumer2 đã không còn tin nhắn nào đã đọc nhưng chưa xác nhận xử lý.</p><div class="language-shell" data-highlighter="shiki" data-ext="shell" data-title="shell" style="--shiki-light:#abb2bf;--shiki-dark:#abb2bf;--shiki-light-bg:#282c34;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-dark-pro one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#ABB2BF;--shiki-dark:#ABB2BF;">&gt; XPENDING mymq group2 - + 10 consumer2</span></span>
<span class="line"><span style="--shiki-light:#ABB2BF;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#61AFEF;--shiki-dark:#61AFEF;">empty</span><span style="--shiki-light:#98C379;--shiki-dark:#98C379;"> array</span><span style="--shiki-light:#ABB2BF;--shiki-dark:#ABB2BF;">)</span></span></code></pre></div><p>Tóm lại, đây là cách thực hiện hàng đợi tin nhắn dựa trên Stream, và những điểm cần nhớ:</p><ul><li>Bảo đảm thứ tự tin nhắn: XADD/XREAD</li><li>Đọc chặn: XREAD block</li><li>Xử lý tin nhắn lặp lại: Stream khi sử dụng lệnh XADD sẽ tự động tạo ID duy nhất toàn cầu;</li><li>Độ tin cậy của tin nhắn: Sử dụng PENDING List nội bộ để tự động lưu trữ tin nhắn, sử dụng lệnh XPENDING để xem tin nhắn đã được nhóm tiêu thụ đọc nhưng chưa được xác nhận, tiêu thụ sử dụng lệnh XACK để xác nhận tin nhắn;</li><li>Hỗ trợ tiêu thụ dạng nhóm cho dữ liệu.</li></ul><blockquote><p>Sự khác biệt giữa hàng đợi tin nhắn dựa trên Stream của Redis và hàng đợi tin nhắn chuyên nghiệp là gì?</p></blockquote><p>Một hệ thống hàng đợi tin nhắn chuyên nghiệp cần đảm bảo hai điều quan trọng:</p><ul><li>Không mất tin nhắn.</li><li>Có thể tích lũy tin nhắn.</li></ul><p><em>1. Redis Stream có mất tin nhắn không?</em></p><p>Việc sử dụng một hệ thống hàng đợi tin nhắn chia thành ba phần chính: <strong>nhà sản xuất, hàng đợi tin nhắn (MQ), người tiêu thụ</strong>, vì vậy để đảm bảo tin nhắn không mất có nghĩa là cần đảm bảo không mất dữ liệu ở ba mắt xích này.</p><p>Hệ thống hàng đợi tin nhắn Redis Stream có thể đảm bảo không mất dữ liệu ở ba mắt xích này không?</p><ul><li><p>Nhà sản xuất Redis có mất tin nhắn không? Việc mất tin nhắn của nhà sản xuất Redis phụ thuộc vào cách xử lý các tình huống ngoại lệ của nhà sản xuất. Quá trình từ khi tin nhắn được tạo ra, sau đó gửi đến MQ, chỉ cần nhận được phản hồi xác nhận ack từ MQ (hàng đợi tin nhắn), nghĩa là quá trình gửi thành công. Vì vậy, chỉ cần xử lý giá trị trả về và ngoại lệ, nếu trả về ngoại lệ thì thực hiện gửi lại tin nhắn, giai đoạn này sẽ không bao giờ mất tin nhắn.</p></li><li><p>Người tiêu thụ Redis có mất tin nhắn không? Không, vì Redis Stream sử dụng danh sách PENDING trong nội bộ để lưu giữ các tin nhắn mà từng người tiêu thụ trong nhóm đã đọc, nhưng chưa được xác nhận. Người tiêu thụ có thể sử dụng lệnh XPENDING để xem các tin nhắn đã được đọc nhưng chưa được xác nhận xử lý hoàn thành sau khi khởi động lại. Khi hoàn thành logic kinh doanh, người tiêu thụ gửi lệnh xác nhận tiêu thụ XACK, cũng có thể đảm bảo rằng tin nhắn không bị mất.</p></li><li><p>Hàng đợi tin nhắn tin nhắn Redis có mất tin nhắn không? Có, Redis trong hai tình huống sau đây, sẽ dẫn đến mất dữ liệu:</p><ul><li>Cấu hình bền vững AOF mỗi giây ghi đĩa, nhưng quá trình này viết vào đĩa là không đồng bộ, Redis bị ngừng khi có thể mất dữ liệu.</li><li>Sao chép Master-Slave cũng là bất đồng bộ, có thể gây mất dữ liệu trong quá trình chuyển đổi giữa master và slave.</li></ul></li></ul><p>Có thể thấy rằng, Redis không thể đảm bảo không mất tin nhắn trong giai đoạn trung tâm hàng đợi. Như RabbitMQ hoặc Kafka, các trung tâm hàng đợi chuyên nghiệp như vậy khi triển khai là một cụm, nhà sản xuất khi phát hành tin nhắn, trung tâm hàng đợi thường viết &quot;nhiều nút&quot;, nghĩa là có nhiều bản sao, như vậy ngay cả khi một trong số đó lỗi, cũng có thể đảm bảo rằng không có dữ liệu bị mất.</p><p><em>2. Redis Stream có thể tích lũy tin nhắn không?</em></p><p>Dữ liệu của Redis được lưu trữ trong bộ nhớ, điều này có nghĩa là khi có sự tích lũy tin nhắn, bộ nhớ của Redis sẽ tăng lên liên tục. Nếu vượt quá giới hạn bộ nhớ của máy, sẽ gặp rủi ro bị OOM (Out of Memory).</p><p>Vì vậy, Redis Stream cung cấp tính năng cho phép chỉ định độ dài tối đa của hàng đợi, để tránh tình trạng này xảy ra.</p><p>Khi chỉ định độ dài tối đa của hàng đợi, nếu độ dài hàng đợi vượt quá giới hạn, các tin nhắn cũ sẽ bị xóa, chỉ giữ lại các tin nhắn mới có độ dài cố định. Xét về mặt này, khi có sự tích lũy tin nhắn, nếu đã chỉ định độ dài tối đa, Redis Stream vẫn có thể mất tin nhắn.</p><p>Tuy nhiên, các hệ thống hàng đợi tin nhắn chuyên nghiệp như Kafka, RabbitMQ lưu trữ dữ liệu trên đĩa cứng, khi có sự tích lũy tin nhắn, chỉ đơn giản là chiếm thêm một ít không gian đĩa cứng.</p><p>Do đó, khi sử dụng Redis làm hàng đợi sẽ gặp phải hai vấn đề:</p><ul><li>Redis bản thân có thể mất dữ liệu.</li><li>Khi có sự tích lũy tin nhắn, tài nguyên bộ nhớ sẽ trở nên căng thẳng.</li></ul><p>Vì vậy, liệu có thể sử dụng Redis làm hàng đợi tin nhắn hay không, phụ thuộc vào tình huống cụ thể của doanh nghiệp của bạn:</p><ul><li>Nếu tình huống doanh nghiệp của bạn đủ đơn giản, không nhạy cảm với việc mất dữ liệu và xác suất tích lũy tin nhắn khá nhỏ, thì việc sử dụng Redis làm hàng đợi là hoàn toàn có thể.</li><li>Nếu doanh nghiệp của bạn có một lượng lớn tin nhắn, xác suất tích lũy tin nhắn lớn, và không chấp nhận mất dữ liệu, thì nên sử dụng các hệ thống hàng đợi tin nhắn chuyên nghiệp.</li></ul><p><strong>Bổ sung: Tại sao cơ chế xuất bản/đăng ký của Redis không thể được sử dụng như một hàng đợi tin nhắn?</strong></p><p>Cơ chế xuất bản/đăng ký có những nhược điểm sau, tất cả đều liên quan đến việc mất dữ liệu:</p><ol><li>Cơ chế xuất bản/đăng ký không dựa trên bất kỳ loại dữ liệu nào, do đó không có khả năng &quot;lưu trữ dữ liệu bền vững&quot;. Các thao tác liên quan đến cơ chế xuất bản/đăng ký sẽ không được ghi vào RDB và AOF. Khi Redis bị sập và khởi động lại, dữ liệu của cơ chế xuất bản/đăng ký sẽ bị mất hết.</li><li>Mô hình xuất bản/đăng ký hoạt động theo kiểu &quot;phát sau quên&quot;, nếu có người đăng ký nào đó bị ngắt kết nối và kết nối lại, họ sẽ không thể nhận được các tin nhắn lịch sử trước đó.</li><li>Khi bên tiêu thụ có sự tích lũy tin nhắn, tức là người sản xuất gửi tin nhắn mà người tiêu thụ không thể tiêu thụ kịp, nếu vượt quá 32MB hoặc liên tục duy trì trên 8MB trong vòng 60 giây, kết nối của bên tiêu thụ sẽ bị ngắt tự động. Tham số này được thiết lập trong tệp cấu hình, giá trị mặc định là <code>client-output-buffer-limit pubsub 32mb 8mb 60</code>.</li></ol><p>Vì vậy, cơ chế xuất bản/đăng ký chỉ thích hợp cho các tình huống truyền thông tức thời, ví dụ như trong trường hợp <a href="https://xiaolincoding.com/redis/cluster/sentinel.html#%E5%93%A8%E5%85%B5%E9%9B%86%E7%BE%A4%E6%98%AF%E5%A6%82%E4%BD%95%E7%BB%84%E6%88%90%E7%9A%84" target="_blank" rel="noopener noreferrer">xây dựng cụm Sentinel</a> sử dụng cơ chế xuất bản/đăng ký.</p>`,168)]))}const p=n(a,[["render",l],["__file","advanced-data-types.html.vue"]]),k=JSON.parse('{"path":"/database/redis/advanced-data-types.html","title":"Redis Advanced Data Types","lang":"en-US","frontmatter":{"title":"Redis Advanced Data Types","tags":["redis","nosql"],"categories":["redis"],"icon":"devicon:redis","order":4,"description":"Redis Advanced Data Types Redis hỗ trợ các kiểu dữ liệu nâng cao như BitMap, HyperLogLog, GEO và Stream. Hiểu được đặc tính của các kiểu dữ liệu này và áp dụng linh hoạt và hiệu...","head":[["meta",{"property":"og:url","content":"https://vanhung4499.github.io/database/redis/advanced-data-types.html"}],["meta",{"property":"og:site_name","content":"VanHung4499"}],["meta",{"property":"og:title","content":"Redis Advanced Data Types"}],["meta",{"property":"og:description","content":"Redis Advanced Data Types Redis hỗ trợ các kiểu dữ liệu nâng cao như BitMap, HyperLogLog, GEO và Stream. Hiểu được đặc tính của các kiểu dữ liệu này và áp dụng linh hoạt và hiệu..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"en-US"}],["meta",{"property":"og:updated_time","content":"2024-06-28T15:54:38.000Z"}],["meta",{"property":"article:author","content":"Hung Nguyen"}],["meta",{"property":"article:tag","content":"redis"}],["meta",{"property":"article:tag","content":"nosql"}],["meta",{"property":"article:modified_time","content":"2024-06-28T15:54:38.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Redis Advanced Data Types\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2024-06-28T15:54:38.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Hung Nguyen\\",\\"url\\":\\"https://vanhung4499.github.io\\"}]}"]]},"headers":[{"level":2,"title":"BitMap","slug":"bitmap","link":"#bitmap","children":[{"level":3,"title":"Giới thiệu về BitMap","slug":"gioi-thieu-ve-bitmap","link":"#gioi-thieu-ve-bitmap","children":[]},{"level":3,"title":"Thực hiện BitMap","slug":"thuc-hien-bitmap","link":"#thuc-hien-bitmap","children":[]},{"level":3,"title":"Các Lệnh BitMap","slug":"cac-lenh-bitmap","link":"#cac-lenh-bitmap","children":[]},{"level":3,"title":"Ứng dụng của BitMap","slug":"ung-dung-cua-bitmap","link":"#ung-dung-cua-bitmap","children":[]}]},{"level":2,"title":"HyperLogLog","slug":"hyperloglog","link":"#hyperloglog","children":[{"level":3,"title":"Giới thiệu về HyperLogLog","slug":"gioi-thieu-ve-hyperloglog","link":"#gioi-thieu-ve-hyperloglog","children":[]},{"level":3,"title":"Triển khai HyperLogLog","slug":"trien-khai-hyperloglog","link":"#trien-khai-hyperloglog","children":[]},{"level":3,"title":"Các lệnh HyperLogLog","slug":"cac-lenh-hyperloglog","link":"#cac-lenh-hyperloglog","children":[]},{"level":3,"title":"Ứng dụng của HyperLogLog","slug":"ung-dung-cua-hyperloglog","link":"#ung-dung-cua-hyperloglog","children":[]}]},{"level":2,"title":"GEO","slug":"geo","link":"#geo","children":[{"level":3,"title":"Giới thiệu về GEO","slug":"gioi-thieu-ve-geo","link":"#gioi-thieu-ve-geo","children":[]},{"level":3,"title":"Triển khai GEO","slug":"trien-khai-geo","link":"#trien-khai-geo","children":[]},{"level":3,"title":"Các lệnh GEO","slug":"cac-lenh-geo","link":"#cac-lenh-geo","children":[]},{"level":3,"title":"Ứng dụng của GEO","slug":"ung-dung-cua-geo","link":"#ung-dung-cua-geo","children":[]}]},{"level":2,"title":"Stream","slug":"stream","link":"#stream","children":[{"level":3,"title":"Giới thiệu về Stream","slug":"gioi-thieu-ve-stream","link":"#gioi-thieu-ve-stream","children":[]},{"level":3,"title":"Các lệnh của Stream","slug":"cac-lenh-cua-stream","link":"#cac-lenh-cua-stream","children":[]},{"level":3,"title":"Ứng dụng Stream","slug":"ung-dung-stream","link":"#ung-dung-stream","children":[]}]}],"git":{"createdTime":1719590078000,"updatedTime":1719590078000,"contributors":[{"name":"Hung Nguyen Van","email":"vanhung4499@gmail.com","commits":1}]},"readingTime":{"minutes":25.69,"words":7708},"filePathRelative":"database/redis/advanced-data-types.md","localizedDate":"June 28, 2024","excerpt":"\\n<p>Redis hỗ trợ các kiểu dữ liệu nâng cao như BitMap, HyperLogLog, GEO và Stream. Hiểu được đặc tính của các kiểu dữ liệu này và áp dụng linh hoạt và hiệu quả vào từng kịch bản nghiệp vụ cụ thể là rất quan trọng khi sử dụng Redis để mô hình hóa dữ liệu.</p>\\n<h2>BitMap</h2>\\n<h3>Giới thiệu về BitMap</h3>","autoDesc":true}');export{p as comp,k as data};
