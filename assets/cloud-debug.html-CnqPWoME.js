import{_ as a,o as t,c as o,a as n}from"./app-5QVbWi7Z.js";const r={};function i(s,e){return t(),o("div",null,e[0]||(e[0]=[n('<h1 id="微服务调试-必读" tabindex="-1"><a class="header-anchor" href="#微服务调试-必读"><span>微服务调试（必读）</span></a></h1><h2 id="_1-多环境-env-组件" tabindex="-1"><a class="header-anchor" href="#_1-多环境-env-组件"><span><a href="#_1-%E5%A4%9A%E7%8E%AF%E5%A2%83-env-%E7%BB%84%E4%BB%B6">#</a> 1. 多环境 env 组件</span></a></h2><p>在微服务架构下，多服务的调试是个非常大的痛点：在大家使用 <strong>同一个</strong> 注册中心时，如果多个人在本地启动 <strong>相同</strong> 服务，可能需要调试的一个请求会打到其他开发的本地服务，实际是期望达到自己本地的服务。</p><p>一般的解决方案是，使用 <strong>不同</strong> 注册中心，避免出现这个情况。但是，服务一多之后，就会产生新的痛点，同时本地启动所有服务很占用电脑内存。</p><p>因此，我们实现了 <a href="https://github.com/YunaiV/yudao-cloud/tree/master/yudao-framework/yudao-spring-boot-starter-env" target="_blank" rel="noopener noreferrer"><code>yudao-spring-boot-starter-env</code></a> 组件，通过 Tag 给服务打标，实现在使用 <strong>同一个</strong> 注册中心的情况下，本地只需要启动需要调试的服务，并且保证自己的请求，必须达到自己本地的服务。如下图所示：</p><figure><img src="https://cloud.iocoder.cn/img/微服务手册/微服务联调/整体流程.png" alt="整体流程" tabindex="0" loading="lazy"><figcaption>整体流程</figcaption></figure><ul><li>测试环境：启动了 gateway、system、infra 服务；本地环境：只启动了 system 服务</li><li>请求时，带上 <code>tag = yunai</code>，优先请求本地环境 + <code>tag = yunai</code> 的服务： <ul><li>① 由于本地未启动 gateway 服务，所以请求打到测试环境的 gateway 服务</li><li>② 由于请求 <code>tag = yunai</code>，所以转发到本地环境的 system 服务</li><li>③ 由于本地未启动 infra 服务，所以转发回测试环境的 infra 服务</li></ul></li></ul><h2 id="_2-功能演示" tabindex="-1"><a class="header-anchor" href="#_2-功能演示"><span><a href="#_2-%E5%8A%9F%E8%83%BD%E6%BC%94%E7%A4%BA">#</a> 2. 功能演示</span></a></h2><p>在本地模拟，启动三个进程，如下图所示：</p><ul><li><code>tag</code> 为空的 gateway、system 服务</li><li><code>tag</code> 为本机 <code>hostname</code>（例如说我本地是 <code>Yunai.local</code>）的 system 服务</li></ul><p>注意！！！</p><p><code>hostname</code> 是你的主机名：</p><ul><li>Windows 在 cmd 里输入 hostname</li><li>MacOS 在 terminal 里输入 hostname</li></ul><h3 id="第一步-启动-gateway-服务" tabindex="-1"><a class="header-anchor" href="#第一步-启动-gateway-服务"><span><a href="#%E7%AC%AC%E4%B8%80%E6%AD%A5-%E5%90%AF%E5%8A%A8-gateway-%E6%9C%8D%E5%8A%A1">#</a> 第一步，启动 gateway 服务</span></a></h3><p>直接运行 GatewayServerApplication 类，启动 gateway 服务。此时，我们可以在 Nacos 看到该实例，它是没 <code>tag</code> 属性。如下图所示：</p><figure><img src="https://cloud.iocoder.cn/img/微服务手册/微服务联调/功能演示-gateway服务.png" alt="gateway 服务" tabindex="0" loading="lazy"><figcaption>gateway 服务</figcaption></figure><h3 id="第二步-启动-system-服务【有-tag】" tabindex="-1"><a class="header-anchor" href="#第二步-启动-system-服务【有-tag】"><span><a href="#%E7%AC%AC%E4%BA%8C%E6%AD%A5-%E5%90%AF%E5%8A%A8-system-%E6%9C%8D%E5%8A%A1%E3%80%90%E6%9C%89-tag%E3%80%91">#</a> 第二步，启动 system 服务【有 tag】</span></a></h3><p>运行 SystemServerApplication 类，启动 system 服务。此时，我们可以在 Nacos 看到该实例，它是有 <code>tag</code> 属性。如下图所示：</p><figure><img src="https://cloud.iocoder.cn/img/微服务手册/微服务联调/功能演示-system服务①.png" alt="system 服务" tabindex="0" loading="lazy"><figcaption>system 服务</figcaption></figure><p>因为我们默认在 <code>application-local.yaml</code> 配置文件里，添加了 <code>yudao.env.tag</code> 配置项为 <code>${HOSTNAME}</code>。如下图所示：</p><figure><img src="https://cloud.iocoder.cn/img/微服务手册/微服务联调/yudao-env-tag配置项.png" alt=" 配置项" tabindex="0" loading="lazy"><figcaption> 配置项</figcaption></figure><h3 id="第三步-启动-system-服务-【无-tag】" tabindex="-1"><a class="header-anchor" href="#第三步-启动-system-服务-【无-tag】"><span><a href="#%E7%AC%AC%E4%B8%89%E6%AD%A5-%E5%90%AF%E5%8A%A8-system-%E6%9C%8D%E5%8A%A1-%E3%80%90%E6%97%A0-tag%E3%80%91">#</a> 第三步，启动 system 服务 【无 tag】</span></a></h3><p>① 修改 system 服务的端口为 28081，<code>yudao.env.tag</code> 配置项为空。如下图所示：</p><figure><img src="https://cloud.iocoder.cn/img/微服务手册/微服务联调/修改system服务的配置.png" alt="修改 system 服务的配置" tabindex="0" loading="lazy"><figcaption>修改 system 服务的配置</figcaption></figure><p>② 再一个 SystemServerApplication，<strong>额外</strong>启动 system 服务。此时，我们可以在 Nacos 看到该实例，它是没 <code>tag</code> 属性。如下图所示：</p><figure><img src="https://cloud.iocoder.cn/img/微服务手册/微服务联调/功能演示-system服务②.png" alt="system 服务" tabindex="0" loading="lazy"><figcaption>system 服务</figcaption></figure><h3 id="第四步-请求测试" tabindex="-1"><a class="header-anchor" href="#第四步-请求测试"><span><a href="#%E7%AC%AC%E5%9B%9B%E6%AD%A5-%E8%AF%B7%E6%B1%82%E6%B5%8B%E8%AF%95">#</a> 第四步，请求测试</span></a></h3><p>① 打开 <code>AuthController.http</code> 文件，设置第一个请求的 <code>tag</code> 为 <code>Yunai.local</code>（要替换成你的 hostname），如下图所示：</p><figure><img src="https://cloud.iocoder.cn/img/微服务手册/微服务联调/AuthController请求.png" alt="AuthController 请求" tabindex="0" loading="lazy"><figcaption>AuthController 请求</figcaption></figure><p>② 点击前面的绿色小箭头，发起请求。从 IDEA 控制台的日志可以看到，只有有 tag 的 system 服务才会被调用。</p><p>你可以多点几次，依然是这样的情况噢！</p><h2 id="_3-实现原理" tabindex="-1"><a class="header-anchor" href="#_3-实现原理"><span><a href="#_3-%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86">#</a> 3. 实现原理</span></a></h2><p>① 在服务注册时，会将 <code>yudao.env.tag</code> 配置项，写到 Nacos 服务实例的元数据，通过 <a href="https://github.com/YunaiV/yudao-cloud/blob/master/yudao-framework/yudao-spring-boot-starter-env/src/main/java/cn/iocoder/yudao/framework/env/config/EnvEnvironmentPostProcessor.java#L22-L27" target="_blank" rel="noopener noreferrer">EnvEnvironmentPostProcessor</a> 类实现。</p><p>② 在服务调用时，通过 <a href="https://github.com/YunaiV/yudao-cloud/blob/master/yudao-framework/yudao-spring-boot-starter-env/src/main/java/cn/iocoder/yudao/framework/env/core/fegin/EnvLoadBalancerClient.java#L70-L75" target="_blank" rel="noopener noreferrer">EnvLoadBalancerClient</a> 类，筛选服务实例，通过服务实例的 <code>tag</code> 元数据，匹配请求的 <code>tag</code> 请求头。</p><p>③ 在网关转发时，通过 <a href="https://github.com/YunaiV/yudao-cloud/blob/master/yudao-gateway/src/main/java/cn/iocoder/yudao/gateway/filter/grey/GrayLoadBalancer.java#L86-L109" target="_blank" rel="noopener noreferrer">GrayLoadBalancer</a> 类，效果和 EnvLoadBalancerClient 一致。</p><h2 id="_4-未来的拓展" tabindex="-1"><a class="header-anchor" href="#_4-未来的拓展"><span><a href="#_4-%E6%9C%AA%E6%9D%A5%E7%9A%84%E6%8B%93%E5%B1%95">#</a> 4. 未来的拓展</span></a></h2><p>除了微服务调试比较麻烦外，MQ 消息队列的消费调试也是个麻烦的事儿，未来也会进行支持。实现的效果如下：</p><ul><li>本地发送的 MQ 消息，优先被本地启动的消费者进行处理，方便调试。</li><li>如果本地没有启动消费者，则被测试环境的消费者进行处理，避免一致不被消费。</li></ul>',38)]))}const c=a(r,[["render",i],["__file","cloud-debug.html.vue"]]),d=JSON.parse('{"path":"/project/yudao-cloud/cloud-debug.html","title":"微服务调试（必读）","lang":"en-US","frontmatter":{"title":"微服务调试（必读）","tags":["project","java","spring-boot","spring-cloud"],"categories":["project"],"order":50,"feed":false,"seo":false,"head":[]},"headers":[{"level":2,"title":"# 1. 多环境 env 组件","slug":"_1-多环境-env-组件","link":"#_1-多环境-env-组件","children":[]},{"level":2,"title":"# 2. 功能演示","slug":"_2-功能演示","link":"#_2-功能演示","children":[{"level":3,"title":"# 第一步，启动 gateway 服务","slug":"第一步-启动-gateway-服务","link":"#第一步-启动-gateway-服务","children":[]},{"level":3,"title":"# 第二步，启动 system 服务【有 tag】","slug":"第二步-启动-system-服务【有-tag】","link":"#第二步-启动-system-服务【有-tag】","children":[]},{"level":3,"title":"# 第三步，启动 system 服务 【无 tag】","slug":"第三步-启动-system-服务-【无-tag】","link":"#第三步-启动-system-服务-【无-tag】","children":[]},{"level":3,"title":"# 第四步，请求测试","slug":"第四步-请求测试","link":"#第四步-请求测试","children":[]}]},{"level":2,"title":"# 3. 实现原理","slug":"_3-实现原理","link":"#_3-实现原理","children":[]},{"level":2,"title":"# 4. 未来的拓展","slug":"_4-未来的拓展","link":"#_4-未来的拓展","children":[]}],"git":{"createdTime":1720365235000,"updatedTime":1720365235000,"contributors":[{"name":"Hung Nguyen Van","email":"vanhung4499@gmail.com","commits":1}]},"readingTime":{"minutes":4.51,"words":1353},"filePathRelative":"project/yudao-cloud/cloud-debug.md","localizedDate":"July 7, 2024"}');export{c as comp,d as data};
