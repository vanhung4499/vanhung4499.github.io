import{_ as a,o as n,c as r,a as o}from"./app-5QVbWi7Z.js";const t={};function i(s,e){return n(),r("div",null,e[0]||(e[0]=[o(`<h1 id="saas-多租户【字段隔离】" tabindex="-1"><a class="header-anchor" href="#saas-多租户【字段隔离】"><span>SaaS 多租户【字段隔离】</span></a></h1><p>本章节，将介绍多租户的基础知识、以及怎样使用多租户的功能。</p><p>相关的视频教程：</p><ul><li><a href="https://t.zsxq.com/06ufyFAeM" target="_blank" rel="noopener noreferrer">01、如何实现多租户的 DB 封装？</a></li><li><a href="https://t.zsxq.com/067eQfAQN" target="_blank" rel="noopener noreferrer">02、如何实现多租户的 Redis 封装？</a></li><li><a href="https://t.zsxq.com/06Nnm6QBE" target="_blank" rel="noopener noreferrer">03、如何实现多租户的 Web 与 Security 封装？</a></li><li><a href="https://t.zsxq.com/06AYJUR3V" target="_blank" rel="noopener noreferrer">04、如何实现多租户的 Job 封装？</a></li><li><a href="https://t.zsxq.com/06aq3nuNF" target="_blank" rel="noopener noreferrer">05、如何实现多租户的 MQ 与 Async 封装？</a></li><li><a href="https://t.zsxq.com/06vFQVJIe" target="_blank" rel="noopener noreferrer">06、如何实现多租户的 AOP 与 Util 封装？</a></li><li><a href="https://t.zsxq.com/063bqRrNZ" target="_blank" rel="noopener noreferrer">07、如何实现多租户的管理？</a></li><li><a href="https://t.zsxq.com/06rBI66yV" target="_blank" rel="noopener noreferrer">08、如何实现多租户的套餐？</a></li></ul><h2 id="_1-多租户是什么" tabindex="-1"><a class="header-anchor" href="#_1-多租户是什么"><span><a href="#_1-%E5%A4%9A%E7%A7%9F%E6%88%B7%E6%98%AF%E4%BB%80%E4%B9%88">#</a> 1. 多租户是什么？</span></a></h2><p>多租户，简单来说是指<strong>一个</strong>业务系统，可以为<strong>多个</strong>组织服务，并且组织之间的数据是<strong>隔离</strong>的。</p><p>例如说，在服务上部署了一个 <a href="https://github.com/YunaiV/yudao-cloud" target="_blank" rel="noopener noreferrer"><code>yudao-cloud</code></a> 系统，可以支持多个不同的公司使用。这里的<strong>一个公司就是一个租户</strong>，每个用户必然属于某个租户。因此，用户也只能看见自己租户下面的内容，其它租户的内容对他是不可见的。</p><h2 id="_2-数据隔离方案" tabindex="-1"><a class="header-anchor" href="#_2-数据隔离方案"><span><a href="#_2-%E6%95%B0%E6%8D%AE%E9%9A%94%E7%A6%BB%E6%96%B9%E6%A1%88">#</a> 2. 数据隔离方案</span></a></h2><p>多租户的数据隔离方案，可以分成分成三种：</p><ol><li>DATASOURCE 模式：独立数据库</li><li>SCHEMA 模式：共享数据库，独立 Schema</li><li>COLUMN 模式：共享数据库，共享 Schema，共享数据表</li></ol><h3 id="_2-1-datasource-模式" tabindex="-1"><a class="header-anchor" href="#_2-1-datasource-模式"><span><a href="#_2-1-datasource-%E6%A8%A1%E5%BC%8F">#</a> 2.1 DATASOURCE 模式</span></a></h3><p>一个租户一个数据库，这种方案的用户数据隔离级别最高，安全性最好，但成本也高。</p><figure><img src="https://cloud.iocoder.cn/img/Saas多租户/DATASOURCE模式.png" alt="DATASOURCE 模式" tabindex="0" loading="lazy"><figcaption>DATASOURCE 模式</figcaption></figure><ul><li>优点：为不同的租户提供独立的数据库，有助于简化数据模型的扩展设计，满足不同租户的独特需求；如果出现故障，恢复数据比较简单。</li><li>缺点：增大了数据库的安装数量，随之带来维护成本和购置成本的增加。</li></ul><h3 id="_2-2-schema-模式" tabindex="-1"><a class="header-anchor" href="#_2-2-schema-模式"><span><a href="#_2-2-schema-%E6%A8%A1%E5%BC%8F">#</a> 2.2 SCHEMA 模式</span></a></h3><p>多个或所有租户共享数据库，但一个租户一个表。</p><figure><img src="https://cloud.iocoder.cn/img/Saas多租户/SCHEMA模式.png" alt="SCHEMA 模式" tabindex="0" loading="lazy"><figcaption>SCHEMA 模式</figcaption></figure><ul><li>优点：为安全性要求较高的租户提供了一定程度的逻辑数据隔离，并不是完全隔离；每个数据库可以支持更多的租户数量。</li><li>缺点：如果出现故障，数据恢复比较困难，因为恢复数据库将牵扯到其他租户的数据； 如果需要跨租户统计数据，存在一定困难。</li></ul><h3 id="_2-3-column-模式" tabindex="-1"><a class="header-anchor" href="#_2-3-column-模式"><span><a href="#_2-3-column-%E6%A8%A1%E5%BC%8F">#</a> 2.3 COLUMN 模式</span></a></h3><p>共享数据库，共享数据架构。租户共享同一个数据库、同一个表，但在表中通过 <code>tenant_id</code> 字段区分租户的数据。这是共享程度最高、隔离级别最低的模式。</p><figure><img src="https://cloud.iocoder.cn/img/Saas多租户/COLUMN模式.png" alt="COLUMN 模式" tabindex="0" loading="lazy"><figcaption>COLUMN 模式</figcaption></figure><ul><li>优点：维护和购置成本最低，允许每个数据库支持的租户数量最多。</li><li>缺点：隔离级别最低，安全性最低，需要在设计开发时加大对安全的开发量；数据备份和恢复最困难，需要逐表逐条备份和还原。</li></ul><h3 id="_2-4-方案选择" tabindex="-1"><a class="header-anchor" href="#_2-4-方案选择"><span><a href="#_2-4-%E6%96%B9%E6%A1%88%E9%80%89%E6%8B%A9">#</a> 2.4 方案选择</span></a></h3><figure><img src="https://cloud.iocoder.cn/img/Saas多租户/模式选择.png" alt="模式选择" tabindex="0" loading="lazy"><figcaption>模式选择</figcaption></figure><ul><li>一般情况下，可以考虑采用 COLUMN 模式，开发、运维简单，以最少的服务器为最多的租户提供服务。</li><li>租户规模比较大，或者一些租户对安全性要求较高，可以考虑采用 DATASOURCE 模式，当然它也相对复杂的多。</li><li>不推荐采用 SCHEMA 模式，因为它的优点并不明显，而且它的缺点也很明显，同时对复杂 SQL 支持一般。</li></ul><p>提问：项目支持哪些模式？</p><p>目前支持最主流的 DATASOURCE 和 COLUMN 两种模式。而 SCHEMA 模式不推荐使用，所以暂时不考虑实现。</p><p>考虑到让大家更好的理解 DATASOURCE 和 COLUMN 模式，拆成了两篇文章：</p><ul><li><a href="/saas-tenant">《SaaS 多租户【字段隔离】》</a>：讲解 COLUMN 模式</li><li><a href="/saas-tenant/dynamic">《SaaS 多租户【数据库隔离】》</a>：讲解 DATASOURCE 模式</li></ul><h2 id="_3-多租户的开关" tabindex="-1"><a class="header-anchor" href="#_3-多租户的开关"><span><a href="#_3-%E5%A4%9A%E7%A7%9F%E6%88%B7%E7%9A%84%E5%BC%80%E5%85%B3">#</a> 3. 多租户的开关</span></a></h2><p>系统有两个配置项，设置为 <code>true</code> 时开启多租户，设置为 <code>false</code> 时关闭多租户。</p><p>注意，两者需要保持一致，否则会报错！</p><table><thead><tr><th>配置项</th><th>说明</th><th>配置文件</th></tr></thead><tbody><tr><td><code>yudao.server.tenant</code></td><td>后端开关</td><td>示例</td></tr><tr><td><code>VUE_APP_TENANT_ENABLE</code></td><td>前端开关</td><td>示例</td></tr></tbody></table><p>疑问：为什么要设置两个配置项？</p><p>前端登录界面需要使用到多租户的配置项，从后端加载配置项的话，体验会比较差。</p><h2 id="_3-多租户的业务功能" tabindex="-1"><a class="header-anchor" href="#_3-多租户的业务功能"><span><a href="#_3-%E5%A4%9A%E7%A7%9F%E6%88%B7%E7%9A%84%E4%B8%9A%E5%8A%A1%E5%8A%9F%E8%83%BD">#</a> 3. 多租户的业务功能</span></a></h2><p>多租户主要有两个业务功能：</p><table><thead><tr><th>业务功能</th><th>说明</th><th>界面</th><th>代码</th></tr></thead><tbody><tr><td>租户管理</td><td>配置系统租户，创建对应的租户管理员</td><td>租户管理</td><td><a href="https://github.com/YunaiV/yudao-cloud/blob/master/yudao-module-system/yudao-module-system-biz/src/main/java/cn/iocoder/yudao/module/system/service/tenant/TenantServiceImpl.java" target="_blank" rel="noopener noreferrer">后端</a> <a href="https://github.com/YunaiV/yudao-cloud/blob/master/yudao-ui-admin/src/views/system/tenant/index.vue" target="_blank" rel="noopener noreferrer">前端</a></td></tr><tr><td>租户套餐</td><td>配置租户套餐，自定每个租户的菜单、操作、按钮的权限</td><td>租户套餐</td><td><a href="https://github.com/YunaiV/yudao-cloud/blob/master/yudao-module-system/yudao-module-system-biz/src/main/java/cn/iocoder/yudao/module/system/service/tenant/TenantPackageServiceImpl.java" target="_blank" rel="noopener noreferrer">后端</a> <a href="https://github.com/YunaiV/yudao-cloud/blob/master/yudao-ui-admin/src/views/system/tenantPackage/index.vue" target="_blank" rel="noopener noreferrer">前端</a></td></tr></tbody></table><p><strong>下面，我们来新增一个租户，它使用 COLUMN 模式。</strong></p><p>① 点击 [租户套餐] 菜单，点击 [新增] 按钮，填写租户的信息。</p><figure><img src="https://cloud.iocoder.cn/img/Saas多租户/05.png" alt="新增租户" tabindex="0" loading="lazy"><figcaption>新增租户</figcaption></figure><p>② 点击 [确认] 按钮，完成租户的创建，它会自动创建对应的租户管理员、角色等信息。</p><figure><img src="https://cloud.iocoder.cn/img/Saas多租户/06.png" alt="租户的管理员、角色" tabindex="0" loading="lazy"><figcaption>租户的管理员、角色</figcaption></figure><p>③ 退出系统，登录刚创建的租户。</p><figure><img src="https://cloud.iocoder.cn/img/Saas多租户/07.png" alt="登录界面" tabindex="0" loading="lazy"><figcaption>登录界面</figcaption></figure><p>至此，我们已经完成了租户的创建。</p><h2 id="_4-多租户的技术组件" tabindex="-1"><a class="header-anchor" href="#_4-多租户的技术组件"><span><a href="#_4-%E5%A4%9A%E7%A7%9F%E6%88%B7%E7%9A%84%E6%8A%80%E6%9C%AF%E7%BB%84%E4%BB%B6">#</a> 4. 多租户的技术组件</span></a></h2><p>技术组件 <a href="https://github.com/YunaiV/yudao-cloud/tree/master/yudao-framework/yudao-spring-boot-starter-biz-tenant/" target="_blank" rel="noopener noreferrer"><code>yudao-spring-boot-starter-biz-tenant</code></a>，实现透明化的多租户能力，针对 Web、Security、DB、Redis、AOP、Job、MQ、Async 等多个层面进行封装。</p><h3 id="_4-1-租户上下文" tabindex="-1"><a class="header-anchor" href="#_4-1-租户上下文"><span><a href="#_4-1-%E7%A7%9F%E6%88%B7%E4%B8%8A%E4%B8%8B%E6%96%87">#</a> 4.1 租户上下文</span></a></h3><p><a href="https://github.com/YunaiV/yudao-cloud/blob/master/yudao-framework/yudao-spring-boot-starter-biz-tenant/src/main/java/cn/iocoder/yudao/framework/tenant/core/context/TenantContextHolder.java" target="_blank" rel="noopener noreferrer">TenantContextHolder</a> 是租户上下文，通过 ThreadLocal 实现租户编号的共享与传递。</p><p>通过调用 TenantContextHolder 的 <code>#getTenantId()</code> <strong>静态</strong>方法，获得当前的租户编号。绝绝绝大多数情况下，并不需要。</p><h3 id="_4-2-web-层【重要】" tabindex="-1"><a class="header-anchor" href="#_4-2-web-层【重要】"><span><a href="#_4-2-web-%E5%B1%82%E3%80%90%E9%87%8D%E8%A6%81%E3%80%91">#</a> 4.2 Web 层【重要】</span></a></h3><blockquote><p>实现可见 <a href="https://github.com/YunaiV/yudao-cloud/tree/master/yudao-framework/yudao-spring-boot-starter-biz-tenant/src/main/java/cn/iocoder/yudao/framework/tenant/core/web" target="_blank" rel="noopener noreferrer"><code>web</code></a> 包。</p></blockquote><p>默认情况下，前端的每个请求 Header <strong>必须</strong>带上 <code>tenant-id</code>，值为租户编号，即 <code>system_tenant</code> 表的主键编号。</p><figure><img src="https://cloud.iocoder.cn/img/Saas多租户/08.png" alt="请求示例" tabindex="0" loading="lazy"><figcaption>请求示例</figcaption></figure><p>如果不带该请求头，会报“租户的请求未传递，请进行排查”错误提示。</p><p>😜 通过 <code>yudao.tenant.ignore-urls</code> 配置项，可以设置哪些 URL 无需带该请求头。例如说：</p><figure><img src="https://cloud.iocoder.cn/img/Saas多租户/09.png" alt=" 配置项" tabindex="0" loading="lazy"><figcaption> 配置项</figcaption></figure><h3 id="_4-3-security-层" tabindex="-1"><a class="header-anchor" href="#_4-3-security-层"><span><a href="#_4-3-security-%E5%B1%82">#</a> 4.3 Security 层</span></a></h3><blockquote><p>实现可见 <a href="https://github.com/YunaiV/yudao-cloud/tree/master/yudao-framework/yudao-spring-boot-starter-biz-tenant/src/main/java/cn/iocoder/yudao/framework/tenant/core/security" target="_blank" rel="noopener noreferrer"><code>security</code></a> 包。</p></blockquote><p>主要是校验登录的用户，校验是否有权限访问该租户，避免越权问题。</p><h3 id="_4-4-db-层【重要】" tabindex="-1"><a class="header-anchor" href="#_4-4-db-层【重要】"><span><a href="#_4-4-db-%E5%B1%82%E3%80%90%E9%87%8D%E8%A6%81%E3%80%91">#</a> 4.4 DB 层【重要】</span></a></h3><blockquote><p>实现可见 <a href="https://github.com/YunaiV/yudao-cloud/tree/master/yudao-framework/yudao-spring-boot-starter-biz-tenant/src/main/java/cn/iocoder/yudao/framework/tenant/core/db" target="_blank" rel="noopener noreferrer"><code>db</code></a> 包。</p></blockquote><p>COLUMN 模式，基于 MyBatis Plus 自带的<a href="https://baomidou.com/pages/aef2f2/" target="_blank" rel="noopener noreferrer">多租户</a>功能实现。</p><p>核心：每次对数据库操作时，它会<strong>自动</strong>拼接 <code>WHERE tenant_id = ?</code> 条件来进行租户的过滤，并且基本支持所有的 SQL 场景。</p><p>如下是具体方式：</p><p>① <strong>需要</strong>开启多租户的表，必须添加 <code>tenant_id</code> 字段。例如说 <code>system_users</code>、<code>system_role</code> 等表。</p><div class="language-" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#abb2bf;--shiki-dark:#abb2bf;--shiki-light-bg:#282c34;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-dark-pro one-dark-pro vp-code"><code><span class="line"><span>CREATE TABLE \`system_role\` (</span></span>
<span class="line"><span>   \`id\` bigint NOT NULL AUTO_INCREMENT COMMENT &#39;角色ID&#39;,</span></span>
<span class="line"><span>   \`name\` varchar(30) CHARACTER NOT NULL COMMENT &#39;角色名称&#39;,</span></span>
<span class="line"><span>   \`tenant_id\` bigint NOT NULL DEFAULT &#39;0&#39; COMMENT &#39;租户编号&#39;,</span></span>
<span class="line"><span>   PRIMARY KEY (\`id\`) USING BTREE</span></span>
<span class="line"><span>) ENGINE=InnoDB AUTO_INCREMENT=1 COMMENT=&#39;角色信息表&#39;;</span></span></code></pre></div><p>并且该表对应的 DO 需要使用到 <code>tenantId</code> 属性时，建议继承 <a href="https://github.com/YunaiV/yudao-cloud/blob/master/yudao-framework/yudao-spring-boot-starter-biz-tenant/src/main/java/cn/iocoder/yudao/framework/tenant/core/db/TenantBaseDO.java" target="_blank" rel="noopener noreferrer">TenantBaseDO</a> 类。</p><p>② <strong>无需</strong>开启多租户的表，需要添加表名到 <code>yudao.tenant.ignore-tables</code> 配置项目。例如说：</p><figure><img src="https://cloud.iocoder.cn/img/Saas多租户/10.png" alt=" 配置项" tabindex="0" loading="lazy"><figcaption> 配置项</figcaption></figure><p>如果不配置的话，MyBatis Plus 会自动拼接 <code>WHERE tenant_id = ?</code> 条件，导致报 <code>tenant_id</code> 字段不存在的错误。</p><h3 id="_4-5-redis-层" tabindex="-1"><a class="header-anchor" href="#_4-5-redis-层"><span><a href="#_4-5-redis-%E5%B1%82">#</a> 4.5 Redis 层</span></a></h3><blockquote><p>实现可见 <a href="https://github.com/YunaiV/yudao-cloud/tree/master/yudao-framework/yudao-spring-boot-starter-biz-tenant/src/main/java/cn/iocoder/yudao/framework/tenant/core/redis" target="_blank" rel="noopener noreferrer"><code>redis</code></a> 包。</p></blockquote><h4 id="使用方式一-基于-spring-cache-redis【推荐】" tabindex="-1"><a class="header-anchor" href="#使用方式一-基于-spring-cache-redis【推荐】"><span><a href="#%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F%E4%B8%80-%E5%9F%BA%E4%BA%8E-spring-cache-redis%E3%80%90%E6%8E%A8%E8%8D%90%E3%80%91">#</a> 使用方式一：基于 Spring Cache + Redis【推荐】</span></a></h4><p>只需要一步，在方法上添加 Spring Cache 注解，例如说 <code>@Cachable</code>、<code>@CachePut</code>、<code>@CacheEvict</code>。</p><p>具体的实现原理，可见 <a href="https://github.com/YunaiV/yudao-cloud/blob/master/yudao-framework/yudao-spring-boot-starter-biz-tenant/src/main/java/cn/iocoder/yudao/framework/tenant/core/redis/TenantRedisCacheManager.java" target="_blank" rel="noopener noreferrer">TenantRedisCacheManager</a> 的源码。</p><p>注意！！！默认配置下，Spring Cache 都开启 Redis Key 的多租户隔离。如果不需要，可以将 Key 添加到 <code>yudao.tenant.ignore-cache</code> 配置项中。如下图所示：</p><figure><img src="https://cloud.iocoder.cn/img/Saas多租户/忽略多租户RedisKey.png" alt=" 配置项" tabindex="0" loading="lazy"><figcaption> 配置项</figcaption></figure><h4 id="使用方式二-基于-redistemplate-tenantrediskeydefine" tabindex="-1"><a class="header-anchor" href="#使用方式二-基于-redistemplate-tenantrediskeydefine"><span><a href="#%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F%E4%BA%8C-%E5%9F%BA%E4%BA%8E-redistemplate-tenantrediskeydefine">#</a> 使用方式二：基于 RedisTemplate + TenantRedisKeyDefine</span></a></h4><p>暂时没有合适的封装，需要在自己 format Redis Key 的时候，手动将 <code>:t{tenantId}</code> 后缀拼接上。</p><p>这也是为什么，我推荐你使用 Spring Cache + Redis 的原因！</p><h3 id="_4-6-aop【重要】" tabindex="-1"><a class="header-anchor" href="#_4-6-aop【重要】"><span><a href="#_4-6-aop%E3%80%90%E9%87%8D%E8%A6%81%E3%80%91">#</a> 4.6 AOP【重要】</span></a></h3><blockquote><p>实现可见 <a href="https://github.com/YunaiV/yudao-cloud/tree/master/yudao-framework/yudao-spring-boot-starter-biz-tenant/src/main/java/cn/iocoder/yudao/framework/tenant/core/aop" target="_blank" rel="noopener noreferrer"><code>aop</code></a> 包。</p></blockquote><p>① 声明 <a href="https://github.com/YunaiV/yudao-cloud/blob/master/yudao-framework/yudao-spring-boot-starter-biz-tenant/src/main/java/cn/iocoder/yudao/framework/tenant/core/aop/TenantIgnore.java" target="_blank" rel="noopener noreferrer"><code>@TenantIgnore</code></a> 注解在方法上，标记指定方法不进行租户的自动过滤，避免<strong>自动</strong>拼接 <code>WHERE tenant_id = ?</code> 条件等等。</p><p>例如说：<a href="https://github.com/YunaiV/yudao-cloud/blob/master/yudao-module-system/yudao-module-system-biz/src/main/java/cn/iocoder/yudao/module/system/service/permission/RoleServiceImpl.java" target="_blank" rel="noopener noreferrer">RoleServiceImpl</a> 的 <a href="https://github.com/YunaiV/yudao-cloud/blob/master/yudao-module-system/yudao-module-system-biz/src/main/java/cn/iocoder/yudao/module/system/service/permission/RoleServiceImpl.java#L83-L100" target="_blank" rel="noopener noreferrer"><code>#initLocalCache()</code></a> 方法，加载<strong>所有</strong>租户的角色到内存进行缓存，如果不声明 <code>@TenantIgnore</code> 注解，会导致租户的自动过滤，只加载了某个租户的角色。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#abb2bf;--shiki-dark:#abb2bf;--shiki-light-bg:#282c34;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-dark-pro one-dark-pro vp-code"><code><span class="line"><span>// RoleServiceImpl.java</span></span>
<span class="line"><span>public class RoleServiceImpl implements RoleService {</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    @Resource</span></span>
<span class="line"><span>    @Lazy // 注入自己，所以延迟加载</span></span>
<span class="line"><span>    private RoleService self;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    @Override</span></span>
<span class="line"><span>    @PostConstruct</span></span>
<span class="line"><span>    @TenantIgnore // 忽略自动多租户，全局初始化缓存</span></span>
<span class="line"><span>    public void initLocalCache() {</span></span>
<span class="line"><span>        // ... 从数据库中，加载角色</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    @Scheduled(fixedDelay = SCHEDULER_PERIOD, initialDelay = SCHEDULER_PERIOD)</span></span>
<span class="line"><span>    public void schedulePeriodicRefresh() {</span></span>
<span class="line"><span>        self.initLocalCache(); // &lt;x&gt; 通过 self 引用到 Spring 代理对象</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>有一点要格外注意，由于 <code>@TenantIgnore</code> 注解是基于 Spring AOP 实现，如果是<strong>方法内部的调用</strong>，避免使用 <code>this</code> 导致不生效，可以采用上述示例的 <code>&lt;x&gt;</code> 处的 <code>self</code> 方式。</p><p>② 使用 <a href="https://github.com/YunaiV/yudao-cloud/blob/master/yudao-framework/yudao-spring-boot-starter-biz-tenant/src/main/java/cn/iocoder/yudao/framework/tenant/core/util/TenantUtils.java" target="_blank" rel="noopener noreferrer">TenantUtils</a> 的 <code>#execute(Long tenantId, Runnable runnable)</code> 方法，模拟指定租户( <code>tenantId</code> )，执行某段业务逻辑( <code>runnable</code> )。</p><p>例如说：在 <a href="https://github.com/YunaiV/yudao-cloud/blob/master/yudao-module-system/yudao-module-system-biz/src/main/java/cn/iocoder/yudao/module/system/service/tenant/TenantServiceImpl.java" target="_blank" rel="noopener noreferrer">TenantServiceImpl</a> 的 <code>#createTenant(...)</code> 方法，在创建完租户时，需要模拟该租户，进行用户和角色的创建。如下图所示：</p><figure><img src="https://cloud.iocoder.cn/img/Saas多租户/11.png" alt="TenantUtils 模拟租户" tabindex="0" loading="lazy"><figcaption>TenantUtils 模拟租户</figcaption></figure><h3 id="_4-7-job【重要】" tabindex="-1"><a class="header-anchor" href="#_4-7-job【重要】"><span><a href="#_4-7-job%E3%80%90%E9%87%8D%E8%A6%81%E3%80%91">#</a> 4.7 Job【重要】</span></a></h3><blockquote><p>实现可见 <a href="https://github.com/YunaiV/yudao-cloud/tree/master/yudao-framework/yudao-spring-boot-starter-biz-tenant/src/main/java/cn/iocoder/yudao/framework/tenant/core/job" target="_blank" rel="noopener noreferrer"><code>job</code></a> 包。</p></blockquote><p>声明 <a href="https://github.com/YunaiV/yudao-cloud/blob/master/yudao-framework/yudao-spring-boot-starter-biz-tenant/src/main/java/cn/iocoder/yudao/framework/tenant/core/job/TenantJob.java" target="_blank" rel="noopener noreferrer"><code>@TenantJob</code></a> 注解在 Job 方法上，实现<strong>并行</strong>遍历每个租户，执行定时任务的逻辑。</p><h3 id="_4-8-mq" tabindex="-1"><a class="header-anchor" href="#_4-8-mq"><span><a href="#_4-8-mq">#</a> 4.8 MQ</span></a></h3><blockquote><p>实现可见 <a href="https://github.com/YunaiV/yudao-cloud/tree/master/yudao-framework/yudao-spring-boot-starter-biz-tenant/src/main/java/cn/iocoder/yudao/framework/tenant/core/mq" target="_blank" rel="noopener noreferrer"><code>mq</code></a> 包。</p></blockquote><p>通过租户对 MQ 层面的封装，实现租户上下文，可以继续传递到 MQ 消费的逻辑中，避免丢失的问题。实现原理是：</p><ul><li>发送消息时，MQ 会将租户上下文的租户编号，记录到 Message 消息头 <code>tenant-id</code> 上。</li><li>消费消息时，MQ 会将 Message 消息头 <code>tenant-id</code>，设置到租户上下文的租户编号。</li></ul><h3 id="_4-9-async" tabindex="-1"><a class="header-anchor" href="#_4-9-async"><span><a href="#_4-9-async">#</a> 4.9 Async</span></a></h3><blockquote><p>实现可见 <a href="https://github.com/YunaiV/yudao-cloud/blob/master/yudao-framework/yudao-spring-boot-starter-job/src/main/java/cn/iocoder/yudao/framework/quartz/config/YudaoAsyncAutoConfiguration.java" target="_blank" rel="noopener noreferrer"><code>YudaoAsyncAutoConfiguration</code></a> 类。</p></blockquote><p>通过使用阿里开源的 <a href="https://github.com/alibaba/transmittable-thread-local" target="_blank" rel="noopener noreferrer">TransmittableThreadLocal</a> 组件，实现 Spring Async 执行异步逻辑时，租户上下文可以继续传递，避免丢失的问题。</p><h3 id="_4-10-rpc" tabindex="-1"><a class="header-anchor" href="#_4-10-rpc"><span><a href="#_4-10-rpc">#</a> 4.10 RPC</span></a></h3><blockquote><p>实现可见 <a href="https://github.com/YunaiV/yudao-cloud/tree/master/yudao-framework/yudao-spring-boot-starter-biz-tenant/src/main/java/cn/iocoder/yudao/framework/tenant/core/rpc" target="_blank" rel="noopener noreferrer"><code>mq</code></a> 包。</p></blockquote><p>RPC 使用 Feign 调用时，会自动将租户上下文的租户编号，设置到 HTTP 请求头 <code>tenant-id</code> 上。</p><p>在 Provider 服务端，会自动将 HTTP 请求头 <code>tenant-id</code>，设置到租户上下文的租户编号。</p><h2 id="_5-租户独立域名" tabindex="-1"><a class="header-anchor" href="#_5-租户独立域名"><span><a href="#_5-%E7%A7%9F%E6%88%B7%E7%8B%AC%E7%AB%8B%E5%9F%9F%E5%90%8D">#</a> 5. 租户独立域名</span></a></h2><p>在我们使用 SaaS 云产品的时候，每个租户会拥有 <strong>独立的子域名</strong>，例如说：租户 A 对应 <code>a.iocoder.cn</code>，租户 B 对应 <code>b.iocoder.cn</code>。</p><p>目前管理后台已经提供类似的能力，更多大家可以基于它去拓展。实现方式：</p><ol><li>在 <code>system_tenant</code> 表里，有个 <code>website</code> 字段为该租户的独立域名，你可以填写你希望分配给它的子域名。</li><li>在 Nginx 上做 <strong>泛域名解析</strong> 到你的前端项目，例如说 Nginx 的 <code>server_name</code> <code>*.iocoder.cn</code> 解析到 Vue3 管理后台。</li></ol><p>这样用户在访问管理后台的登录界面，会自动根据当前访问域名的 <code>host</code>，向后端获得对应的 <code>tenant-id</code> 编号，后续请求都带上它！</p><p>ps：商城 uniapp 暂时还没做，感兴趣可以 pull request 贡献下噢！</p>`,111)]))}const l=a(t,[["render",i],["__file","saas-tenant.html.vue"]]),c=JSON.parse('{"path":"/project/yudao-cloud/saas-tenant.html","title":"SaaS 多租户【字段隔离】","lang":"en-US","frontmatter":{"title":"SaaS 多租户【字段隔离】","tags":["project","java","spring-boot","spring-cloud"],"categories":["project"],"order":27,"feed":false,"seo":false,"head":[]},"headers":[{"level":2,"title":"# 1. 多租户是什么？","slug":"_1-多租户是什么","link":"#_1-多租户是什么","children":[]},{"level":2,"title":"# 2. 数据隔离方案","slug":"_2-数据隔离方案","link":"#_2-数据隔离方案","children":[{"level":3,"title":"# 2.1 DATASOURCE 模式","slug":"_2-1-datasource-模式","link":"#_2-1-datasource-模式","children":[]},{"level":3,"title":"# 2.2 SCHEMA 模式","slug":"_2-2-schema-模式","link":"#_2-2-schema-模式","children":[]},{"level":3,"title":"# 2.3 COLUMN 模式","slug":"_2-3-column-模式","link":"#_2-3-column-模式","children":[]},{"level":3,"title":"# 2.4 方案选择","slug":"_2-4-方案选择","link":"#_2-4-方案选择","children":[]}]},{"level":2,"title":"# 3. 多租户的开关","slug":"_3-多租户的开关","link":"#_3-多租户的开关","children":[]},{"level":2,"title":"# 3. 多租户的业务功能","slug":"_3-多租户的业务功能","link":"#_3-多租户的业务功能","children":[]},{"level":2,"title":"# 4. 多租户的技术组件","slug":"_4-多租户的技术组件","link":"#_4-多租户的技术组件","children":[{"level":3,"title":"# 4.1 租户上下文","slug":"_4-1-租户上下文","link":"#_4-1-租户上下文","children":[]},{"level":3,"title":"# 4.2 Web 层【重要】","slug":"_4-2-web-层【重要】","link":"#_4-2-web-层【重要】","children":[]},{"level":3,"title":"# 4.3 Security 层","slug":"_4-3-security-层","link":"#_4-3-security-层","children":[]},{"level":3,"title":"# 4.4 DB 层【重要】","slug":"_4-4-db-层【重要】","link":"#_4-4-db-层【重要】","children":[]},{"level":3,"title":"# 4.5 Redis 层","slug":"_4-5-redis-层","link":"#_4-5-redis-层","children":[]},{"level":3,"title":"# 4.6 AOP【重要】","slug":"_4-6-aop【重要】","link":"#_4-6-aop【重要】","children":[]},{"level":3,"title":"# 4.7 Job【重要】","slug":"_4-7-job【重要】","link":"#_4-7-job【重要】","children":[]},{"level":3,"title":"# 4.8 MQ","slug":"_4-8-mq","link":"#_4-8-mq","children":[]},{"level":3,"title":"# 4.9 Async","slug":"_4-9-async","link":"#_4-9-async","children":[]},{"level":3,"title":"# 4.10 RPC","slug":"_4-10-rpc","link":"#_4-10-rpc","children":[]}]},{"level":2,"title":"# 5. 租户独立域名","slug":"_5-租户独立域名","link":"#_5-租户独立域名","children":[]}],"git":{"createdTime":1720365235000,"updatedTime":1720365235000,"contributors":[{"name":"Hung Nguyen Van","email":"vanhung4499@gmail.com","commits":1}]},"readingTime":{"minutes":10.81,"words":3242},"filePathRelative":"project/yudao-cloud/saas-tenant.md","localizedDate":"July 7, 2024"}');export{l as comp,c as data};
