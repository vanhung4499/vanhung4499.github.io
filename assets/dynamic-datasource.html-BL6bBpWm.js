import{_ as e,o as n,c as s,a as i}from"./app-5QVbWi7Z.js";const r={};function l(t,a){return n(),s("div",null,a[0]||(a[0]=[i(`<h1 id="多数据源-读写分离-、事务" tabindex="-1"><a class="header-anchor" href="#多数据源-读写分离-、事务"><span>多数据源（读写分离）、事务</span></a></h1><p><a href="https://github.com/YunaiV/ruoyi-vue-pro/blob/master/yudao-framework/yudao-spring-boot-starter-mybatis/" target="_blank" rel="noopener noreferrer"><code>yudao-spring-boot-starter-mybatis</code></a> 技术组件，除了提供 MyBatis 数据库操作，还提供了如下 2 种功能：</p><ul><li>数据连接池：基于 <a href="https://github.com/alibaba/druid" target="_blank" rel="noopener noreferrer">Alibaba Druid</a> 实现，额外提供监控的能力。</li><li>多数据源（读写分离）：基于 <a href="https://github.com/baomidou/dynamic-datasource-spring-boot-starter" target="_blank" rel="noopener noreferrer">Dynamic Datasource</a> 实现，支持 Druid 连接池，可集成 <a href="https://www.iocoder.cn/Seata/install/?yudao" target="_blank" rel="noopener noreferrer">Seata</a> 实现分布式事务。</li></ul><h2 id="_1-数据连接池" tabindex="-1"><a class="header-anchor" href="#_1-数据连接池"><span><a href="#_1-%E6%95%B0%E6%8D%AE%E8%BF%9E%E6%8E%A5%E6%B1%A0">#</a> 1. 数据连接池</span></a></h2><p>友情提示：</p><p>如果你未学习过 Druid 数据库连接池，可以后续阅读 <a href="http://www.iocoder.cn/Spring-Boot/datasource-pool/?yudao" target="_blank" rel="noopener noreferrer">《芋道 Spring Boot 数据库连接池入门》</a> 文章。</p><div class="language-" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#abb2bf;--shiki-dark:#abb2bf;--shiki-light-bg:#282c34;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-dark-pro one-dark-pro vp-code"><code><span class="line"><span>&lt;dependency&gt;</span></span>
<span class="line"><span>    &lt;groupId&gt;com.alibaba&lt;/groupId&gt;</span></span>
<span class="line"><span>    &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt;</span></span>
<span class="line"><span>&lt;/dependency&gt;</span></span></code></pre></div><h3 id="_1-1-druid-监控配置" tabindex="-1"><a class="header-anchor" href="#_1-1-druid-监控配置"><span><a href="#_1-1-druid-%E7%9B%91%E6%8E%A7%E9%85%8D%E7%BD%AE">#</a> 1.1 Druid 监控配置</span></a></h3><p>在 <a href="https://github.com/YunaiV/ruoyi-vue-pro/blob/master/yudao-server/src/main/resources/application-local.yaml" target="_blank" rel="noopener noreferrer"><code>application-local.yaml</code></a> 配置文件中，通过 <code>spring.datasource.druid</code> 配置项，仅仅设置了 Druid <strong>监控</strong>相关的配置项目，具体数据库的设置需要使用 Dynamic Datasource 的配置项。如下图所示：</p><figure><img src="https://doc.iocoder.cn/img/多数据源/01.png" alt=" 配置项" tabindex="0" loading="lazy"><figcaption> 配置项</figcaption></figure><h3 id="_1-2-druid-监控界面" tabindex="-1"><a class="header-anchor" href="#_1-2-druid-监控界面"><span><a href="#_1-2-druid-%E7%9B%91%E6%8E%A7%E7%95%8C%E9%9D%A2">#</a> 1.2 Druid 监控界面</span></a></h3><p>① 访问后端的 <code>/druid/index.html</code> 路径，例如说本地的 <code>http://127.0.0.1:48080/druid/index.html</code> 地址，可以查看到 Druid 监控界面。如下图所示：</p><figure><img src="https://doc.iocoder.cn/img/多数据源/02.png" alt="Druid 监控界面" tabindex="0" loading="lazy"><figcaption>Druid 监控界面</figcaption></figure><p>② 访问前端的 [基础设施 -&gt; MySQL 监控] 菜单，也可以查看到 Druid 监控界面。如下图所示：</p><figure><img src="https://doc.iocoder.cn/img/多数据源/03.png" alt="Druid 监控界面" tabindex="0" loading="lazy"><figcaption>Druid 监控界面</figcaption></figure><p>补充说明：</p><p>前端 [基础设施 -&gt; MySQL 监控] 菜单，通过 iframe 内嵌后端的 <code>/druid/index.html</code> 路径。</p><p>如果你想自定义地址，可以前往 [基础设置 -&gt; 配置管理] 菜单，设置 key 为 <code>url.druid</code> 配置项。</p><h3 id="_1-3-如何开启登录" tabindex="-1"><a class="header-anchor" href="#_1-3-如何开启登录"><span><a href="#_1-3-%E5%A6%82%E4%BD%95%E5%BC%80%E5%90%AF%E7%99%BB%E5%BD%95">#</a> 1.3 如何开启登录？</span></a></h3><p>生产环境下，建议 Druid 监控界面开启“安全认证”的功能，避免出现安全事故。</p><p>只需要在 <code>spring.datasource.druid.stat-view-servlet</code> 配置项中，设置 <code>login-username</code> 和 <code>login-password</code> 即可。开启后，登录界面如下图所示：</p><figure><img src="https://doc.iocoder.cn/img/多数据源/druid-security.png" alt="Druid 登录界面" tabindex="0" loading="lazy"><figcaption>Druid 登录界面</figcaption></figure><h2 id="_2-多数据源" tabindex="-1"><a class="header-anchor" href="#_2-多数据源"><span><a href="#_2-%E5%A4%9A%E6%95%B0%E6%8D%AE%E6%BA%90">#</a> 2. 多数据源</span></a></h2><p>友情提示：</p><p>如果你未学习过多数据源，可以后续阅读 <a href="http://www.iocoder.cn/Spring-Boot/dynamic-datasource/?yudao" target="_blank" rel="noopener noreferrer">《芋道 Spring Boot 多数据源（读写分离）入门》</a> 文章。</p><div class="language-" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#abb2bf;--shiki-dark:#abb2bf;--shiki-light-bg:#282c34;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-dark-pro one-dark-pro vp-code"><code><span class="line"><span>&lt;dependency&gt;</span></span>
<span class="line"><span>    &lt;groupId&gt;com.baomidou&lt;/groupId&gt;</span></span>
<span class="line"><span>    &lt;artifactId&gt;dynamic-datasource-spring-boot-starter&lt;/artifactId&gt;</span></span>
<span class="line"><span>&lt;/dependency&gt;</span></span></code></pre></div><h3 id="_2-1-多数据源配置" tabindex="-1"><a class="header-anchor" href="#_2-1-多数据源配置"><span><a href="#_2-1-%E5%A4%9A%E6%95%B0%E6%8D%AE%E6%BA%90%E9%85%8D%E7%BD%AE">#</a> 2.1 多数据源配置</span></a></h3><p>在 <a href="https://github.com/YunaiV/ruoyi-vue-pro/blob/master/yudao-server/src/main/resources/application-local.yaml#L30-L58" target="_blank" rel="noopener noreferrer"><code>application-local.yaml</code></a> 配置文件中，通过 <code>spring.datasource.dynamic</code> 配置项，配置了 Master-Slave 主从两个数据源。如下图所示：</p><figure><img src="https://doc.iocoder.cn/img/多数据源/04.png" alt=" 配置项" tabindex="0" loading="lazy"><figcaption> 配置项</figcaption></figure><h3 id="_2-2-数据源切换" tabindex="-1"><a class="header-anchor" href="#_2-2-数据源切换"><span><a href="#_2-2-%E6%95%B0%E6%8D%AE%E6%BA%90%E5%88%87%E6%8D%A2">#</a> 2.2 数据源切换</span></a></h3><h4 id="_2-2-1-master-注解" tabindex="-1"><a class="header-anchor" href="#_2-2-1-master-注解"><span><a href="#_2-2-1-master-%E6%B3%A8%E8%A7%A3">#</a> 2.2.1 @Master 注解</span></a></h4><p>在方法上添加 <a href="https://github.com/baomidou/dynamic-datasource-spring-boot-starter/blob/master/src/main/java/com/baomidou/dynamic/datasource/annotation/Master.java" target="_blank" rel="noopener noreferrer"><code>@Master</code></a> 注解，使用名字为 <code>master</code> 的数据源，即使用【主】库，一般适合【写】场景。示例如下图：</p><figure><img src="https://doc.iocoder.cn/img/多数据源/05.png" alt="@Master 注解" tabindex="0" loading="lazy"><figcaption>@Master 注解</figcaption></figure><p>由于项目的 <code>spring.datasource.dynamic.primary</code> 为 <code>master</code>，默认使用【主】库，所以无需手动添加 <code>@Master</code> 注解。</p><h4 id="_2-2-2-slave-注解" tabindex="-1"><a class="header-anchor" href="#_2-2-2-slave-注解"><span><a href="#_2-2-2-slave-%E6%B3%A8%E8%A7%A3">#</a> 2.2.2 @Slave 注解</span></a></h4><p>在方法上添加 <a href="https://github.com/baomidou/dynamic-datasource-spring-boot-starter/blob/master/src/main/java/com/baomidou/dynamic/datasource/annotation/Slave.java" target="_blank" rel="noopener noreferrer"><code>@Slave</code></a> 注解，使用名字为 <code>slave</code> 的数据源，即使用【从】库，一般适合【读】场景。示例如下图：</p><figure><img src="https://doc.iocoder.cn/img/多数据源/06.png" alt="@Slave 注解" tabindex="0" loading="lazy"><figcaption>@Slave 注解</figcaption></figure><h4 id="_2-2-3-ds-注解" tabindex="-1"><a class="header-anchor" href="#_2-2-3-ds-注解"><span><a href="#_2-2-3-ds-%E6%B3%A8%E8%A7%A3">#</a> 2.2.3 @DS 注解</span></a></h4><p>在方法上添加 <a href="https://github.com/baomidou/dynamic-datasource-spring-boot-starter/blob/master/src/main/java/com/baomidou/dynamic/datasource/annotation/DS.java" target="_blank" rel="noopener noreferrer"><code>@DS</code></a> 注解，使用指定名字的数据源，适合多数据源的情况。示例如下图：</p><figure><img src="https://doc.iocoder.cn/img/多数据源/07.png" alt="@DS 注解" tabindex="0" loading="lazy"><figcaption>@DS 注解</figcaption></figure><h2 id="_3-事务相关" tabindex="-1"><a class="header-anchor" href="#_3-事务相关"><span><a href="#_3-%E4%BA%8B%E5%8A%A1%E7%9B%B8%E5%85%B3">#</a> 3. 事务相关</span></a></h2><p>事务一共有 3 种解决方案，分别是：</p><ul><li>单机 + 单数据源：<code>@Transactional</code> 注解</li><li>单机 + 多数据源：<code>@DSTransactional</code> 注解</li><li>多机 + 单/多数据源：Seata 分布式事务</li></ul><h3 id="_3-1-transactional-注解" tabindex="-1"><a class="header-anchor" href="#_3-1-transactional-注解"><span><a href="#_3-1-transactional-%E6%B3%A8%E8%A7%A3">#</a> 3.1 @Transactional 注解</span></a></h3><p>大多数情况下，是单机 + 单个数据源的操作，只需要在方法上添加 Spring <code>@Transactional</code> 注解，声明事务即可。</p><p>具体的使用，可以项目里搜 <code>@Transactional</code> 关键字，就可以看到非常多的使用示例。</p><h3 id="_3-2-dstransactional-注解" tabindex="-1"><a class="header-anchor" href="#_3-2-dstransactional-注解"><span><a href="#_3-2-dstransactional-%E6%B3%A8%E8%A7%A3">#</a> 3.2 @DSTransactional 注解</span></a></h3><p>如果单机 + 多个数据源的操作，使用 <code>@Transactional</code> 声明的事务中，无法进行数据源的切换。此时，可以使用 Dynamic Datasource 提供的 <a href="https://github.com/baomidou/dynamic-datasource-spring-boot-starter/blob/master/src/main/java/com/baomidou/dynamic/datasource/annotation/DSTransactional.java" target="_blank" rel="noopener noreferrer"><code>@DSTransactional</code></a> 注解，支持多数据源的切换。</p><p>友情提示：</p><p><code>@DSTransactional</code> 注解，提供相对可靠的多数据源的事务一致性，但是不绝对，可学习 <a href="https://www.yinxiang.com/everhub/note/ac0175c8-35f5-4d66-8cd3-c662d7a16441" target="_blank" rel="noopener noreferrer">《DSTransactional 实现源码分析 》</a> 文章。</p><p>使用的示例，AService 调用 BService、CService，并且分别对应 a、b、c 各自的数据源，代码如下所示：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#abb2bf;--shiki-dark:#abb2bf;--shiki-light-bg:#282c34;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-dark-pro one-dark-pro vp-code"><code><span class="line"><span>public class AService {</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    @Resource</span></span>
<span class="line"><span>    private BService bService;</span></span>
<span class="line"><span>    @Resource</span></span>
<span class="line"><span>    private CService cService;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    @DS(&quot;a&quot;) // 注意：如果 a 是默认数据源时，则不需要 @DS 注解</span></span>
<span class="line"><span>    @DSTransactional</span></span>
<span class="line"><span>    public void create() {</span></span>
<span class="line"><span>        bService.createB();</span></span>
<span class="line"><span>        CService.createC();</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    public class BService {</span></span>
<span class="line"><span></span></span>
<span class="line"><span>        @DS(&quot;b&quot;)</span></span>
<span class="line"><span>        public void createB() {</span></span>
<span class="line"><span>            // 调用 bMapper 逻辑</span></span>
<span class="line"><span>        }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    public class CService {</span></span>
<span class="line"><span></span></span>
<span class="line"><span>        @DS(&quot;c&quot;)</span></span>
<span class="line"><span>        public void createC() {</span></span>
<span class="line"><span>            // 调用 cMapper 逻辑</span></span>
<span class="line"><span>        }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>场景问题：</p><p>问题 ①：c 数据源的操作发生异常，a、b 数据源会回滚么？</p><ul><li>答案：会的，因为最终是最外层的 <code>@DSTransactional</code> 注解对应的方法结束后，才进行事务的提交，所以它实际不需要回滚。</li><li>注意：但是有一点要注意，如果提交时某个数据源的事务提交失败，则可能导致事务的不一致。</li></ul><p>问题 ②：b、c 数据源的方法，也添加 <code>@DSTransactional</code> 注解，会不会影响事务？</p><ul><li>答案：不会，可以放心大胆的加。</li></ul><h3 id="_3-3-分布式事务" tabindex="-1"><a class="header-anchor" href="#_3-3-分布式事务"><span><a href="#_3-3-%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1">#</a> 3.3 分布式事务</span></a></h3><p>在多机分布式场景下，无论是单数据源、多数据源，本质上都是分布式事务，建议引入 Seata 框架，提供完整的分布式事务的解决方案，可学习 <a href="https://www.iocoder.cn/Seata/install/?yudao" target="_blank" rel="noopener noreferrer">《芋道 Seata 极简入门 》</a> 文章。</p><p>不过如果你是单机项目，则可以不用关注着一点哈！</p><h2 id="_4-分库分表" tabindex="-1"><a class="header-anchor" href="#_4-分库分表"><span><a href="#_4-%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8">#</a> 4. 分库分表</span></a></h2><p>建议采用 ShardingSphere 的子项目 Sharding-JDBC 完成分库分表的功能，可阅读 <a href="https://www.iocoder.cn/Spring-Boot/sharding-datasource/?yudao" target="_blank" rel="noopener noreferrer">《芋道 Spring Boot 分库分表入门 》</a> 文章，学习如何整合进项目。</p>`,62)]))}const d=e(r,[["render",l],["__file","dynamic-datasource.html.vue"]]),o=JSON.parse('{"path":"/project/rouyi-vue-pro/dynamic-datasource.html","title":"多数据源（读写分离）、事务","lang":"en-US","frontmatter":{"title":"多数据源（读写分离）、事务","tags":["project","java","spring-boot","spring-cloud"],"categories":["project"],"order":40,"feed":false,"seo":false,"head":[]},"headers":[{"level":2,"title":"# 1. 数据连接池","slug":"_1-数据连接池","link":"#_1-数据连接池","children":[{"level":3,"title":"# 1.1 Druid 监控配置","slug":"_1-1-druid-监控配置","link":"#_1-1-druid-监控配置","children":[]},{"level":3,"title":"# 1.2 Druid 监控界面","slug":"_1-2-druid-监控界面","link":"#_1-2-druid-监控界面","children":[]},{"level":3,"title":"# 1.3 如何开启登录？","slug":"_1-3-如何开启登录","link":"#_1-3-如何开启登录","children":[]}]},{"level":2,"title":"# 2. 多数据源","slug":"_2-多数据源","link":"#_2-多数据源","children":[{"level":3,"title":"# 2.1 多数据源配置","slug":"_2-1-多数据源配置","link":"#_2-1-多数据源配置","children":[]},{"level":3,"title":"# 2.2 数据源切换","slug":"_2-2-数据源切换","link":"#_2-2-数据源切换","children":[]}]},{"level":2,"title":"# 3. 事务相关","slug":"_3-事务相关","link":"#_3-事务相关","children":[{"level":3,"title":"# 3.1 @Transactional 注解","slug":"_3-1-transactional-注解","link":"#_3-1-transactional-注解","children":[]},{"level":3,"title":"# 3.2 @DSTransactional 注解","slug":"_3-2-dstransactional-注解","link":"#_3-2-dstransactional-注解","children":[]},{"level":3,"title":"# 3.3 分布式事务","slug":"_3-3-分布式事务","link":"#_3-3-分布式事务","children":[]}]},{"level":2,"title":"# 4. 分库分表","slug":"_4-分库分表","link":"#_4-分库分表","children":[]}],"git":{"createdTime":1720365235000,"updatedTime":1720365235000,"contributors":[{"name":"Hung Nguyen Van","email":"vanhung4499@gmail.com","commits":1}]},"readingTime":{"minutes":5.25,"words":1575},"filePathRelative":"project/rouyi-vue-pro/dynamic-datasource.md","localizedDate":"July 7, 2024"}');export{d as comp,o as data};
