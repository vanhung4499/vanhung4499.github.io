import{_ as i}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as e,o as l,e as a}from"./app-C-_dXKvP.js";const t={},n=a('<h1 id="algorithm" tabindex="-1"><a class="header-anchor" href="#algorithm"><span>Algorithm</span></a></h1><blockquote><p>[!Info]</p><ul><li>Tổng hợp các thuật toán, chiến lược, suy luận, giải thích và áp dụng giải quyết các ví dụ cụ thể trên LeeCode!</li><li>Các chủ đề được chia rõ, bạn có thể tìm đến chủ đề bạn quan tâm, không cần phải đọc từ trên xuống dưới!</li></ul></blockquote><h2 id="base-algorithms" tabindex="-1"><a class="header-anchor" href="#base-algorithms"><span>Base Algorithms</span></a></h2><blockquote><p>Cơ sở, chiến lược thiết kế và thực thi của các thuật toán, đây là nền tảng để tạo ra các thuật toán khác.</p></blockquote><h3 id="enumeration" tabindex="-1"><a class="header-anchor" href="#enumeration"><span>Enumeration</span></a></h3><ul><li>[[Enumeration]]</li><li>[[Enumeration Problems]]</li></ul><h3 id="recursion" tabindex="-1"><a class="header-anchor" href="#recursion"><span>Recursion</span></a></h3><ul><li>[[Recursion]]</li><li>[[Recursion Problems]]</li></ul><h3 id="divide-and-conquer" tabindex="-1"><a class="header-anchor" href="#divide-and-conquer"><span>Divide and Conquer</span></a></h3><ul><li>[[Divide and Conquer]]</li><li>[[Hanoi Tower Problem]] Todo!</li><li>[[Divide and Conquer Problems]]</li></ul><h3 id="greedy" tabindex="-1"><a class="header-anchor" href="#greedy"><span>Greedy</span></a></h3><ul><li>[[Greedy]]</li><li>[[Greedy Problems]]</li></ul><h3 id="sorting" tabindex="-1"><a class="header-anchor" href="#sorting"><span>Sorting</span></a></h3><ul><li>[[Bubble Sort]]</li><li>[[Selection Sort]]</li><li>[[Insertion Sort]]</li><li>[[Shell Sort]]</li><li>[[Merge Sort]]</li><li>[[Quick Sort]]</li><li>[[Heap Sort]]</li><li>[[Counting Sort]]</li><li>[[Radix Sort]]</li><li>[[Bucket Sort]]</li><li>[[Sorting Problems]]</li></ul><h2 id="search" tabindex="-1"><a class="header-anchor" href="#search"><span>Search</span></a></h2><blockquote><p>Thuật toán tìm kiếm</p></blockquote><h3 id="dfs-bfs" tabindex="-1"><a class="header-anchor" href="#dfs-bfs"><span>DFS - BFS</span></a></h3><ul><li>[[DFS]]</li><li>[[BFS]]</li></ul><h3 id="binary-search" tabindex="-1"><a class="header-anchor" href="#binary-search"><span>Binary Search</span></a></h3><ul><li>[[Binary Search Part 1]]</li><li>[[Binary Search Part 2]]</li><li>[[Binary Search Problems]]</li></ul><h3 id="backtracking" tabindex="-1"><a class="header-anchor" href="#backtracking"><span>Backtracking</span></a></h3><ul><li>[[Backtracking]]</li><li>[[Branch and Bound]] Updating!</li><li>[[Backtracking Problems]]</li></ul><h3 id="other" tabindex="-1"><a class="header-anchor" href="#other"><span>Other</span></a></h3><blockquote><p>Todo!</p></blockquote><ul><li>[[A Star]]</li><li>[[Heuristic]]</li><li>[[Alpha-Beta]]</li></ul><h2 id="string" tabindex="-1"><a class="header-anchor" href="#string"><span>String</span></a></h2><blockquote><p>Thuật toán về xâu / chuỗi, đặc biệt là về khớp chuỗi (Pattern Matching). Ứng dụng trong Regex (Regular Expression) mà chúng ta hay sử dụng!</p></blockquote><h3 id="basic" tabindex="-1"><a class="header-anchor" href="#basic"><span>Basic</span></a></h3><ul><li>[[String Basic]]</li></ul><h3 id="single-pattern-matching" tabindex="-1"><a class="header-anchor" href="#single-pattern-matching"><span>Single Pattern Matching</span></a></h3><ul><li>[[Brute Force Matching]]</li><li>[[Rabin Karp]]</li><li>[[KMP]]</li><li>[[Boyer Moore]]</li><li>[[Horspool]]</li><li>[[Sunday]]</li><li>[[Single Matching Pattern Problems]]</li></ul><h3 id="multi-pattern-matching" tabindex="-1"><a class="header-anchor" href="#multi-pattern-matching"><span>Multi Pattern Matching</span></a></h3><ul><li>[[Trie]]</li><li>[[Trie Problems]]</li><li>[[AC Automation]] Todo!</li><li>[[Suffix Array]] Todo!</li></ul><h2 id="math" tabindex="-1"><a class="header-anchor" href="#math"><span>Math</span></a></h2><blockquote><p>Các vấn đề liên quan tới toán học.</p></blockquote><h3 id="bit-operation" tabindex="-1"><a class="header-anchor" href="#bit-operation"><span>Bit Operation</span></a></h3><ul><li>[[Bit Operation]]</li><li>[[Bit Operation Problems]]</li></ul><h3 id="number" tabindex="-1"><a class="header-anchor" href="#number"><span>Number</span></a></h3><blockquote><p>Todo!</p></blockquote><ul><li>[[Prime Number]]</li><li>[[GCD and LCM]]</li></ul><h3 id="game-theory" tabindex="-1"><a class="header-anchor" href="#game-theory"><span>Game Theory</span></a></h3><blockquote><p>Todo!</p></blockquote><ul><li>[[Game Theory Intro]]</li></ul><h2 id="graph" tabindex="-1"><a class="header-anchor" href="#graph"><span>Graph</span></a></h2><blockquote><p>Các vấn đề liên quan tới đồ thị: lý thuyết đồ thị, biểu diễn, tìm kiếm, đường đi ngắn nhất, cây khung, luồng-cặp ghép, …</p></blockquote><h3 id="basic-1" tabindex="-1"><a class="header-anchor" href="#basic-1"><span>Basic</span></a></h3><ul><li>[[Graph Basic]]</li><li>[[Graph Structure]]</li></ul><h3 id="traversal" tabindex="-1"><a class="header-anchor" href="#traversal"><span>Traversal</span></a></h3><ul><li>[[DFS]]</li><li>[[DFS Problems]]</li><li>[[BFS]]</li><li>[[BFS Problems]]</li><li>[[Topological Sorting]]</li><li>[[Topological Sorting Problems]]</li></ul><h3 id="shortest-path" tabindex="-1"><a class="header-anchor" href="#shortest-path"><span>Shortest Path</span></a></h3><blockquote><p>Updating!</p></blockquote><ul><li>[[Shortest Path]]</li><li>[[Floyd]]</li><li>[[Bellman-Ford]]</li><li>[[Dijkstra]]</li><li>[[Shortest Path Problems]]</li></ul><h3 id="spanning-tree" tabindex="-1"><a class="header-anchor" href="#spanning-tree"><span>Spanning Tree</span></a></h3><blockquote><p>Updating!</p></blockquote><ul><li>[[Minimum Spanning Tree]]</li><li>[[KrusKal]]</li><li>[[Prim]]</li><li>[[MST Problems]]</li></ul><h3 id="flow-bipartite" tabindex="-1"><a class="header-anchor" href="#flow-bipartite"><span>Flow - Bipartite</span></a></h3><blockquote><p>Updating!</p></blockquote><ul><li>[[Flow]]</li><li>[[Bipartite]]</li></ul><h2 id="dynamic-programming" tabindex="-1"><a class="header-anchor" href="#dynamic-programming"><span>Dynamic Programming</span></a></h2><blockquote><p>Dynamic Programming không phải là một thuật toán mà là một chiến lược giải quyết vấn đề. Nó cực kì rộng và sẽ là vấn đề hóc búa trong các cuộc thi lập trình.</p></blockquote><h3 id="basic-2" tabindex="-1"><a class="header-anchor" href="#basic-2"><span>Basic</span></a></h3><ul><li>[[DP Basic]]</li><li>[[DP Memorization]]</li><li>[[DP Basic Problems]]</li></ul><h3 id="linear" tabindex="-1"><a class="header-anchor" href="#linear"><span>Linear</span></a></h3><ul><li>[[Linear DP Part 1]]</li><li>[[Linear DP Part 2]]</li><li>[[Linear DP Problems]]</li></ul><h3 id="knapsack" tabindex="-1"><a class="header-anchor" href="#knapsack"><span>Knapsack</span></a></h3><ul><li>[[Knapsack Part 1]]</li><li>[[Knapsack Part 2]]</li><li>[[Knapsack Part 3]]</li><li>[[Knapsack Part 4]]</li><li>[[Knapsack Part 5]]</li><li>[[Knapsack Problems]]</li></ul><h3 id="interval" tabindex="-1"><a class="header-anchor" href="#interval"><span>Interval</span></a></h3><ul><li>[[Interval DP]]</li><li>[[Interval DP Problems]]</li></ul><h3 id="tree-dp" tabindex="-1"><a class="header-anchor" href="#tree-dp"><span>Tree DP</span></a></h3><ul><li>[[Tree DP]]</li><li>[[Tree DP Problems]]</li></ul><h3 id="state" tabindex="-1"><a class="header-anchor" href="#state"><span>State</span></a></h3><ul><li>[[State DP]]</li><li>[[State DP Problems]]</li></ul><h3 id="counting" tabindex="-1"><a class="header-anchor" href="#counting"><span>Counting</span></a></h3><ul><li>[[Counting DP]]</li><li>[[Counting DP Problems]]</li></ul><h3 id="digit" tabindex="-1"><a class="header-anchor" href="#digit"><span>Digit</span></a></h3><ul><li>[[Digit DP]]</li><li>[[Digit DP Problems]]</li></ul><h3 id="probability" tabindex="-1"><a class="header-anchor" href="#probability"><span>Probability</span></a></h3><blockquote><p>Todo!</p></blockquote><ul><li>[[Probability DP]]</li><li>[[Probability DP Problems]]</li></ul><h3 id="optimization" tabindex="-1"><a class="header-anchor" href="#optimization"><span>Optimization</span></a></h3><blockquote><p>Todo!</p></blockquote><ul><li>[[Monotone Stack Queue Optimization]]</li><li>[[ST BIT Optimization]]</li><li>[[Slope Optimization]]</li></ul>',82),r=[n];function h(o,c){return l(),e("div",null,r)}const u=i(t,[["render",h],["__file","index.html.vue"]]),p=JSON.parse('{"path":"/dsa/algo/","title":"Algorithm","lang":"en-US","frontmatter":{"title":"Algorithm","icon":"book","dir":{"order":2,"link":true},"index":false,"tags":["dsa","algorithm"],"categories":["dsa","algorithm"],"date created":"2023-10-01T00:00:00.000Z","date modified":"2023-10-04T00:00:00.000Z","description":"Algorithm [!Info] Tổng hợp các thuật toán, chiến lược, suy luận, giải thích và áp dụng giải quyết các ví dụ cụ thể trên LeeCode! Các chủ đề được chia rõ, bạn có thể tìm đến chủ ...","head":[["meta",{"property":"og:url","content":"https://vanhung4499.github.io/dsa/algo/"}],["meta",{"property":"og:site_name","content":"vanhung4499"}],["meta",{"property":"og:title","content":"Algorithm"}],["meta",{"property":"og:description","content":"Algorithm [!Info] Tổng hợp các thuật toán, chiến lược, suy luận, giải thích và áp dụng giải quyết các ví dụ cụ thể trên LeeCode! Các chủ đề được chia rõ, bạn có thể tìm đến chủ ..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"en-US"}],["meta",{"property":"og:updated_time","content":"2024-06-20T12:02:51.000Z"}],["meta",{"property":"article:author","content":"Hung Nguyen"}],["meta",{"property":"article:tag","content":"dsa"}],["meta",{"property":"article:tag","content":"algorithm"}],["meta",{"property":"article:modified_time","content":"2024-06-20T12:02:51.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Algorithm\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2024-06-20T12:02:51.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Hung Nguyen\\",\\"url\\":\\"https://vanhung4499.github.io\\",\\"email\\":\\"vanhung4499@gmail.com\\"}]}"]]},"headers":[{"level":2,"title":"Base Algorithms","slug":"base-algorithms","link":"#base-algorithms","children":[{"level":3,"title":"Enumeration","slug":"enumeration","link":"#enumeration","children":[]},{"level":3,"title":"Recursion","slug":"recursion","link":"#recursion","children":[]},{"level":3,"title":"Divide and Conquer","slug":"divide-and-conquer","link":"#divide-and-conquer","children":[]},{"level":3,"title":"Greedy","slug":"greedy","link":"#greedy","children":[]},{"level":3,"title":"Sorting","slug":"sorting","link":"#sorting","children":[]}]},{"level":2,"title":"Search","slug":"search","link":"#search","children":[{"level":3,"title":"DFS - BFS","slug":"dfs-bfs","link":"#dfs-bfs","children":[]},{"level":3,"title":"Binary Search","slug":"binary-search","link":"#binary-search","children":[]},{"level":3,"title":"Backtracking","slug":"backtracking","link":"#backtracking","children":[]},{"level":3,"title":"Other","slug":"other","link":"#other","children":[]}]},{"level":2,"title":"String","slug":"string","link":"#string","children":[{"level":3,"title":"Basic","slug":"basic","link":"#basic","children":[]},{"level":3,"title":"Single Pattern Matching","slug":"single-pattern-matching","link":"#single-pattern-matching","children":[]},{"level":3,"title":"Multi Pattern Matching","slug":"multi-pattern-matching","link":"#multi-pattern-matching","children":[]}]},{"level":2,"title":"Math","slug":"math","link":"#math","children":[{"level":3,"title":"Bit Operation","slug":"bit-operation","link":"#bit-operation","children":[]},{"level":3,"title":"Number","slug":"number","link":"#number","children":[]},{"level":3,"title":"Game Theory","slug":"game-theory","link":"#game-theory","children":[]}]},{"level":2,"title":"Graph","slug":"graph","link":"#graph","children":[{"level":3,"title":"Basic","slug":"basic-1","link":"#basic-1","children":[]},{"level":3,"title":"Traversal","slug":"traversal","link":"#traversal","children":[]},{"level":3,"title":"Shortest Path","slug":"shortest-path","link":"#shortest-path","children":[]},{"level":3,"title":"Spanning Tree","slug":"spanning-tree","link":"#spanning-tree","children":[]},{"level":3,"title":"Flow - Bipartite","slug":"flow-bipartite","link":"#flow-bipartite","children":[]}]},{"level":2,"title":"Dynamic Programming","slug":"dynamic-programming","link":"#dynamic-programming","children":[{"level":3,"title":"Basic","slug":"basic-2","link":"#basic-2","children":[]},{"level":3,"title":"Linear","slug":"linear","link":"#linear","children":[]},{"level":3,"title":"Knapsack","slug":"knapsack","link":"#knapsack","children":[]},{"level":3,"title":"Interval","slug":"interval","link":"#interval","children":[]},{"level":3,"title":"Tree DP","slug":"tree-dp","link":"#tree-dp","children":[]},{"level":3,"title":"State","slug":"state","link":"#state","children":[]},{"level":3,"title":"Counting","slug":"counting","link":"#counting","children":[]},{"level":3,"title":"Digit","slug":"digit","link":"#digit","children":[]},{"level":3,"title":"Probability","slug":"probability","link":"#probability","children":[]},{"level":3,"title":"Optimization","slug":"optimization","link":"#optimization","children":[]}]}],"git":{"createdTime":1718884971000,"updatedTime":1718884971000,"contributors":[{"name":"Hung Nguyen Van","email":"vanhung4499@gmail.com","commits":1}]},"readingTime":{"minutes":1.79,"words":538},"filePathRelative":"dsa/algo/README.md","localizedDate":"June 20, 2024","excerpt":"\\n<blockquote>\\n<p>[!Info]</p>\\n<ul>\\n<li>Tổng hợp các thuật toán, chiến lược, suy luận, giải thích và áp dụng giải quyết các ví dụ cụ thể trên LeeCode!</li>\\n<li>Các chủ đề được chia rõ, bạn có thể tìm đến chủ đề bạn quan tâm, không cần phải đọc từ trên xuống dưới!</li>\\n</ul>\\n</blockquote>\\n<h2>Base Algorithms</h2>","autoDesc":true}');export{u as comp,p as data};
