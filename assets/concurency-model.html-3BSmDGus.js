import{_ as n,o as t,c as h,d as i}from"./app-DBZfZLYz.js";const c={},g=i('<h1 id="mo-hinh-đong-thoi" tabindex="-1"><a class="header-anchor" href="#mo-hinh-đong-thoi"><span>Mô hình đồng thời</span></a></h1><h2 id="giai-thich-thuat-ngu" tabindex="-1"><a class="header-anchor" href="#giai-thich-thuat-ngu"><span>Giải thích thuật ngữ</span></a></h2><p>Trước khi hiểu về cơ chế đơn luồng và không chặn của JavaScript, hãy hiểu một số cặp thuật ngữ dễ nhầm lẫn.</p><p>Khái niệm và mối quan hệ giữa tiến trình và luồng:</p><ul><li><strong>Tiến trình (Process)</strong>: Tiến trình là đơn vị phân phối và lập lịch tài nguyên hệ thống. Một chương trình đang chạy tương ứng với một tiến trình. Một tiến trình bao gồm chương trình đang chạy và bộ nhớ và tài nguyên hệ thống mà chương trình sử dụng.</li><li><strong>Luồng (Thread)</strong>: Luồng là người thực hiện trong một tiến trình, một tiến trình ít nhất có một luồng (luồng chính), cũng có thể có nhiều luồng.</li></ul><p>Khái niệm về song song và đồng thời:</p><ul><li><strong>Song song (Parallelism)</strong>: Đề cập đến trạng thái chạy của chương trình, trong đó có nhiều công việc đang được thực hiện cùng một lúc trong cùng một thời điểm. Vì một luồng chỉ có thể xử lý một công việc trong cùng một thời điểm, nên để có song song, cần có nhiều luồng thực hiện nhiều công việc cùng một lúc.</li><li><strong>Đồng thời (Concurrency)</strong>: Đề cập đến cấu trúc thiết kế của chương trình, trong đó nhiều công việc có thể được xử lý xen kẽ với nhau trong cùng một khoảng thời gian. Điểm chính là chỉ có một công việc được thực hiện tại một thời điểm nhưng nhiều công việc có thể được chuyển đổi và xử lý xen kẽ với nhau.</li></ul><p>Khái niệm về chặn và không chặn:</p><ul><li><strong>Chặn (Blocking)</strong>: Chặn đề cập đến việc một luồng bị treo trong quá trình chờ đợi (tài nguyên CPU được phân bổ cho nơi khác)</li><li><strong>Không chặn (Non-blocking)</strong>: Không chặn chỉ ra rằng trong quá trình chờ đợi, tài nguyên CPU vẫn ở trong luồng này và luồng có thể làm những công việc khác.</li></ul><p>Tiếp theo là phân biệt giữa đơn luồng và đa luồng:</p><ul><li><strong>Đơn luồng (Single-threaded)</strong>: Thực hiện từ đầu đến cuối, thực thi từng dòng lệnh. Nếu một dòng mã gặp lỗi, các dòng mã còn lại sẽ không được thực thi nữa. Đồng thời, có nguy cơ bị chặn mã.</li><li><strong>Đa luồng (Multi-threaded)</strong>: Môi trường chạy mã khác nhau, các luồng độc lập và không ảnh hưởng lẫn nhau, tránh tình trạng bị chặn.</li></ul><p>Cuối cùng là phân biệt giữa đồng bộ và bất đồng bộ:</p><ul><li><strong>Đồng bộ (Synchronous)</strong>: Khi một cuộc gọi được thực hiện, nó sẽ chờ đợi cho đến khi kết quả trả về trước khi tiếp tục thực hiện các công việc khác. Nghĩa là cuộc gọi đồng bộ sẽ chờ đợi kết quả trước khi tiếp tục thực hiện các công việc khác.</li><li><strong>Bất đồng bộ (Asynchronous)</strong>: Khi một cuộc gọi được thực hiện, nó không chờ đợi kết quả trả về và tiếp tục thực hiện các công việc khác. Kết quả của cuộc gọi sẽ được xử lý sau khi nó hoàn thành.</li></ul><h2 id="moi-truong-thuc-thi" tabindex="-1"><a class="header-anchor" href="#moi-truong-thuc-thi"><span>Môi trường thực thi</span></a></h2><p>JavaScript thường chạy trong môi trường trình duyệt, cụ thể là thông qua trình duyệt để phân tích cú pháp và thực thi mã.</p><h3 id="luong-trinh-duyet" tabindex="-1"><a class="header-anchor" href="#luong-trinh-duyet"><span>Luồng trình duyệt</span></a></h3><p>Hiện nay, các trình duyệt phổ biến nhất là Chrome, IE, Safari, Firefox và Opera. Nhân của trình duyệt là đa luồng, thường bao gồm các nhóm luồng sau:</p><ul><li><strong>Luồng hiển thị (Rendering Engine Thread)</strong>: Đảm nhận việc hiển thị trang web.</li><li><strong>Luồng JavaScript Engine (JavaScript Engine Thread)</strong>: Đảm nhận việc phân tích và thực thi mã JavaScript.</li><li><strong>Luồng kích hoạt định thời (Timer Trigger Thread)</strong>: Xử lý các sự kiện định thời như <code>setTimeout</code>, <code>setInterval</code>.</li><li><strong>Luồng kích hoạt sự kiện trình duyệt (Browser Event Trigger Thread)</strong>: Xử lý các sự kiện DOM.</li><li><strong>Luồng yêu cầu HTTP bất đồng bộ (Asynchronous HTTP Request Thread)</strong>: Xử lý các yêu cầu HTTP không đồng bộ.</li></ul><p>⚠️ Lưu ý rằng luồng hiển thị và luồng JavaScript Engine là <strong style="color:red;">loại trừ lẫn nhau</strong>. Khi luồng trình duyệt đang thực thi một tác vụ, luồng JavaScript Engine sẽ bị đình chỉ. Điều này xảy ra vì JavaScript có thể tương tác với DOM và nếu JavaScript thay đổi DOM trong quá trình hiển thị, trình duyệt có thể không biết phản ứng ra sao.</p><h3 id="javascript-engine" tabindex="-1"><a class="header-anchor" href="#javascript-engine"><span>JavaScript Engine</span></a></h3><p>Thường thì khi nói đến trình duyệt, chúng ta nói về hai thành phần cốt lõi của trình duyệt: <strong>Động cơ hiển thị</strong> (Rendering Engine) và <strong>Trình thông dịch JavaScript</strong> (JavaScript Interpreter).</p><table><thead><tr><th style="text-align:left;">Trình duyệt</th><th style="text-align:left;">Động cơ hiển thị</th><th style="text-align:left;">Trình thông dịch JavaScript (Engine)</th></tr></thead><tbody><tr><td style="text-align:left;">Chrome</td><td style="text-align:left;">Webkit =&gt; Blink</td><td style="text-align:left;">V8</td></tr><tr><td style="text-align:left;">Safari</td><td style="text-align:left;">Webkit</td><td style="text-align:left;">Nitro</td></tr><tr><td style="text-align:left;">Firefox</td><td style="text-align:left;">Gecko</td><td style="text-align:left;">SpiderMonky / TraceMonkey / JaegerMonkey</td></tr><tr><td style="text-align:left;">Opera</td><td style="text-align:left;">Presto =&gt; Blink</td><td style="text-align:left;">Linear A / Linear B / Futhark / Carakan</td></tr><tr><td style="text-align:left;">Internet Explorer</td><td style="text-align:left;">Trident =&gt; EdgeHTML</td><td style="text-align:left;">JScript / Chakra (9+)</td></tr><tr><td style="text-align:left;">Edge</td><td style="text-align:left;">EdgeHTML =&gt; Chromium</td><td style="text-align:left;">Chakra</td></tr></tbody></table><blockquote><p>Chú ý: Webkit engine bao gồm trình định dạng WebCore và trình phân tích cú pháp JavaScript Core.</p></blockquote><p>Các động cơ hiển thị khác nhau thực hiện cùng một tác vụ với cách thức khác nhau, điều này dẫn đến vấn đề tương thích về kiểu dáng của trình duyệt.</p><p>Trình thông dịch JavaScript có thể coi là máy ảo JavaScript, chịu trách nhiệm phân tích và thực thi mã JavaScript. Giai đoạn biên dịch được giải thích chi tiết ở [[JS Compilation]].</p><h2 id="đon-luong" tabindex="-1"><a class="header-anchor" href="#đon-luong"><span>Đơn luồng</span></a></h2><p>JavaScript là đơn luồng, điều này liên quan đến mục đích sử dụng của nó. Là một ngôn ngữ kịch bản trong trình duyệt, mục đích chính của JavaScript là tương tác với người dùng và thao tác DOM. Điều này quyết định JavaScript chỉ có thể là đơn luồng, nếu không sẽ gây ra vấn đề đồng bộ phức tạp. Ví dụ, giả sử JavaScript có nhiều luồng cùng một lúc, một luồng đang thêm nội dung vào một nút DOM, một luồng khác xóa nút đó, lúc này trình duyệt sẽ không biết luồng nào là đúng.</p><p>Vì vậy, để tránh sự phức tạp, từ khi ra đời, môi trường thực thi JavaScript đã được thiết kế là đơn luồng, và điều này đã trở thành đặc điểm cốt lõi của ngôn ngữ này và sẽ không thay đổi trong tương lai.</p><p>Để tận dụng khả năng tính toán đa nhân CPU, HTML5 đã đưa ra tiêu chuẩn Web Worker, cho phép mã JavaScript tạo ra nhiều luồng, nhưng các luồng con hoàn toàn bị kiểm soát bởi luồng chính và không được phép thao tác DOM. Vì vậy, tiêu chuẩn mới này không thay đổi bản chất đơn luồng của JavaScript.</p><p>⚠️ <strong>Lưu ý</strong>: Cần lưu ý rằng đơn luồng trong JavaScript chỉ đề cập đến một luồng thực thi JavaScript duy nhất trong một tiến trình chương trình (trong môi trường trình duyệt, tiến trình này là tiến trình trình duyệt), chỉ có một đoạn mã JavaScript được thực thi trong cùng một thời điểm. Cơ chế bất đồng bộ được thực hiện bởi hai hoặc nhiều luồng cố định trong môi trường chạy.</p><h2 id="hang-đoi-cong-viec" tabindex="-1"><a class="header-anchor" href="#hang-đoi-cong-viec"><span>Hàng đợi công việc</span></a></h2><p>Các tác vụ trong JavaScript có thể được chia thành hai loại:</p><ul><li><strong>Tác vụ đồng bộ (Synchronous Task)</strong>: Tác vụ đồng bộ được gọi trên luồng chính và phải chờ đợi cho đến khi kết quả trả về trước khi tiếp tục thực hiện các tác vụ khác.</li><li><strong>Tác vụ bất đồng bộ (Asynchronous Task)</strong>: Tác vụ bất đồng bộ được gọi trên luồng chính và tiếp tục thực hiện các tác vụ khác trong khi chờ kết quả. Khi tác vụ bất đồng bộ đã sẵn sàng, nó sẽ được đẩy vào hàng đợi công việc (Task Queue), và khi luồng chính trống rỗng, trình thông dịch JavaScript sẽ thực hiện một vòng lặp sự kiện (Event Loop) để đẩy tác vụ từ hàng đợi công việc vào luồng chính để thực thi.</li></ul><p>Cụ thể về cơ chế thực thi bất đồng bộ như sau:</p><ol><li>Tất cả các tác vụ đồng bộ và bất đồng bộ được thực thi trên luồng chính theo [[JS Compilation#Nguyên lý biên dịch|nguyên lý biên dịch]] và tạo ra một [[JS Excution Context Stack|ngăn xếp ngữ cảnh thực thi]](Execution Context Stack).</li><li>Khi tất cả các tác vụ đồng bộ hoàn thành và trả về kết quả, chúng sẽ rời khỏi ngăn xếp ngữ cảnh thực thi.</li><li>Các tác vụ bất đồng bộ sẽ thực hiện một phần trên luồng chính, rồi rời khỏi ngăn xếp ngữ cảnh thực thi và tiếp tục thực hiện trên luồng đặc biệt của môi trường thực thi.</li><li>Khi tác vụ bất đồng bộ đã sẵn sàng, nó sẽ được đẩy vào hàng đợi công việc và chờ đợi.</li><li>Khi ngăn xếp ngữ cảnh thực thi trên luồng chính trống rỗng, trình thông dịch JavaScript sẽ thực hiện một vòng lặp sự kiện để lấy tác vụ từ hàng đợi công việc và đưa vào ngăn xếp ngữ cảnh thực thi trên luồng chính để thực thi.</li></ol><figure><img src="https://raw.githubusercontent.com/vanhung4499/images/master/snap/20230803001555.png" alt="image.png" tabindex="0" loading="lazy"><figcaption>image.png</figcaption></figure><p>Để hình dung trực quan hơn, hãy xem video sau: <a href="https://www.youtube.com/watch?v=8aGhZQkoFbQ" target="_blank" rel="noopener noreferrer">What the heck is the event loop anyway?</a></p>',37),r=[g];function e(a,l){return t(),h("div",null,r)}const u=n(c,[["render",e],["__file","concurency-model.html.vue"]]),s=JSON.parse('{"path":"/programming/js/core/excute-and-contexts/concurrency/concurency-model.html","title":"Concurency Model","lang":"en-US","frontmatter":{"title":"Concurency Model","tags":["js","programming"],"categories":["js","programming"],"date created":"2023-08-03T00:00:00.000Z","date modified":"2023-08-03T00:00:00.000Z","order":1,"description":"Mô hình đồng thời Giải thích thuật ngữ Trước khi hiểu về cơ chế đơn luồng và không chặn của JavaScript, hãy hiểu một số cặp thuật ngữ dễ nhầm lẫn. Khái niệm và mối quan hệ giữa ...","head":[["meta",{"property":"og:url","content":"https://vanhung4499.github.io/programming/js/core/excute-and-contexts/concurrency/concurency-model.html"}],["meta",{"property":"og:site_name","content":"VanHung4499"}],["meta",{"property":"og:title","content":"Concurency Model"}],["meta",{"property":"og:description","content":"Mô hình đồng thời Giải thích thuật ngữ Trước khi hiểu về cơ chế đơn luồng và không chặn của JavaScript, hãy hiểu một số cặp thuật ngữ dễ nhầm lẫn. Khái niệm và mối quan hệ giữa ..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://raw.githubusercontent.com/vanhung4499/images/master/snap/20230803001555.png"}],["meta",{"property":"og:locale","content":"en-US"}],["meta",{"property":"og:updated_time","content":"2024-06-28T15:54:38.000Z"}],["meta",{"property":"article:author","content":"Hung Nguyen"}],["meta",{"property":"article:tag","content":"js"}],["meta",{"property":"article:tag","content":"programming"}],["meta",{"property":"article:modified_time","content":"2024-06-28T15:54:38.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Concurency Model\\",\\"image\\":[\\"https://raw.githubusercontent.com/vanhung4499/images/master/snap/20230803001555.png\\"],\\"dateModified\\":\\"2024-06-28T15:54:38.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Hung Nguyen\\",\\"url\\":\\"https://vanhung4499.github.io\\"}]}"]]},"headers":[{"level":2,"title":"Giải thích thuật ngữ","slug":"giai-thich-thuat-ngu","link":"#giai-thich-thuat-ngu","children":[]},{"level":2,"title":"Môi trường thực thi","slug":"moi-truong-thuc-thi","link":"#moi-truong-thuc-thi","children":[{"level":3,"title":"Luồng trình duyệt","slug":"luong-trinh-duyet","link":"#luong-trinh-duyet","children":[]},{"level":3,"title":"JavaScript Engine","slug":"javascript-engine","link":"#javascript-engine","children":[]}]},{"level":2,"title":"Đơn luồng","slug":"đon-luong","link":"#đon-luong","children":[]},{"level":2,"title":"Hàng đợi công việc","slug":"hang-đoi-cong-viec","link":"#hang-đoi-cong-viec","children":[]}],"git":{"createdTime":1719590078000,"updatedTime":1719590078000,"contributors":[{"name":"Hung Nguyen Van","email":"vanhung4499@gmail.com","commits":1}]},"readingTime":{"minutes":7.02,"words":2106},"filePathRelative":"programming/js/core/excute-and-contexts/concurrency/concurency-model.md","localizedDate":"June 28, 2024","excerpt":"\\n<h2>Giải thích thuật ngữ</h2>\\n<p>Trước khi hiểu về cơ chế đơn luồng và không chặn của JavaScript, hãy hiểu một số cặp thuật ngữ dễ nhầm lẫn.</p>\\n<p>Khái niệm và mối quan hệ giữa tiến trình và luồng:</p>\\n<ul>\\n<li><strong>Tiến trình (Process)</strong>: Tiến trình là đơn vị phân phối và lập lịch tài nguyên hệ thống. Một chương trình đang chạy tương ứng với một tiến trình. Một tiến trình bao gồm chương trình đang chạy và bộ nhớ và tài nguyên hệ thống mà chương trình sử dụng.</li>\\n<li><strong>Luồng (Thread)</strong>: Luồng là người thực hiện trong một tiến trình, một tiến trình ít nhất có một luồng (luồng chính), cũng có thể có nhiều luồng.</li>\\n</ul>","autoDesc":true}');export{u as comp,s as data};
