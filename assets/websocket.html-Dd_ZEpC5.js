import{_ as r,g as p,o as c,c as l,a as i,e as s,h as a,f as o,w as t}from"./app-5QVbWi7Z.js";const d={};function b(g,e){const n=p("RouteLink");return c(),l("div",null,[e[18]||(e[18]=i(`<h1 id="websocket-实时通信" tabindex="-1"><a class="header-anchor" href="#websocket-实时通信"><span>WebSocket 实时通信</span></a></h1><h2 id="_1-功能简介" tabindex="-1"><a class="header-anchor" href="#_1-功能简介"><span><a href="#_1-%E5%8A%9F%E8%83%BD%E7%AE%80%E4%BB%8B">#</a> 1. 功能简介</span></a></h2><p>项目的 <a href="https://github.com/YunaiV/ruoyi-vue-pro/tree/master/yudao-framework/yudao-spring-boot-starter-websocket" target="_blank" rel="noopener noreferrer"><code>yudao-spring-boot-starter-websocket</code></a> 组件，基于 <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#websocket" target="_blank" rel="noopener noreferrer">Spring WebSocket</a> 进行二次封装，实现了更加简单的使用方式。例如说，WebSocket 的认证、Session 的管理、WebSocket 集群的消息广播等等。</p><p>疑问：为什么不使用 Netty 实现 WebSocket？</p><p>Netty 的学习和使用门槛较高，对大家可能不够友好，而 Spring WebSocket 足够满足 99.99% 的场景。</p><h3 id="_1-1-token-身份认证" tabindex="-1"><a class="header-anchor" href="#_1-1-token-身份认证"><span><a href="#_1-1-token-%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81">#</a> 1.1 Token 身份认证</span></a></h3><p>① 在 WebSocket 连接建立时，通过 QueryString 的 <code>token</code> 参数，进行认证。例如说：<code>ws://127.0.0.1:48080/ws?token=xxx</code>。</p><p>由于 WebSocket 是基于 HTTP 建立连接，所以它的认证可以复用项目的 <a href="https://github.com/YunaiV/ruoyi-vue-pro/blob/master/yudao-framework/yudao-spring-boot-starter-security/src/main/java/cn/iocoder/yudao/framework/security/core/filter/TokenAuthenticationFilter.java" target="_blank" rel="noopener noreferrer">TokenAuthenticationFilter</a> 实现。</p><p>为什么 token 不使用 Header 传递？</p><p>WebSocket 不支持 Header 传递，所以只能使用 QueryString 传递。</p><p>② 认证完成后，会通过 <a href="https://github.com/YunaiV/ruoyi-vue-pro/blob/master/yudao-framework/yudao-spring-boot-starter-websocket/src/main/java/cn/iocoder/yudao/framework/websocket/core/security/LoginUserHandshakeInterceptor.java" target="_blank" rel="noopener noreferrer">LoginUserHandshakeInterceptor</a> 拦截器，将用户信息存储到 WebSocket Session 的 <code>attributes</code> 中。</p><p>这样，后续可以使用 <a href="https://github.com/YunaiV/ruoyi-vue-pro/blob/master/yudao-framework/yudao-spring-boot-starter-websocket/src/main/java/cn/iocoder/yudao/framework/websocket/core/util/WebSocketFrameworkUtils.java" target="_blank" rel="noopener noreferrer">WebSocketFrameworkUtils</a> 获取用户信息，例如说：</p><div class="language-" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#abb2bf;--shiki-dark:#abb2bf;--shiki-light-bg:#282c34;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-dark-pro one-dark-pro vp-code"><code><span class="line"><span>// WebSocketFrameworkUtils.java</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// ① 获取当前用户</span></span>
<span class="line"><span>public static LoginUser getLoginUser(WebSocketSession session)</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// ② 获得当前用户的类型</span></span>
<span class="line"><span>public static Integer getLoginUserType(WebSocketSession session)</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// ③ 获得当前用户的编号</span></span>
<span class="line"><span>public static Integer getLoginUserType(WebSocketSession session)</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// ④ 获得当前用户的租户编号</span></span>
<span class="line"><span>public static Long getTenantId(WebSocketSession session)</span></span></code></pre></div><h3 id="_1-2-session-会话管理" tabindex="-1"><a class="header-anchor" href="#_1-2-session-会话管理"><span><a href="#_1-2-session-%E4%BC%9A%E8%AF%9D%E7%AE%A1%E7%90%86">#</a> 1.2 Session 会话管理</span></a></h3><p>每个前端和后端建立的 WebSocket 连接，对应后端的一个 WebSocketSession 会话对象。由于后续需要对 WebSocketSession 进行消息的发送，所以需要进行管理。</p><p>① WebSocketSession 的管理，由 <a href="https://github.com/YunaiV/ruoyi-vue-pro/blob/master/yudao-framework/yudao-spring-boot-starter-websocket/src/main/java/cn/iocoder/yudao/framework/websocket/core/session/WebSocketSessionManager.java" target="_blank" rel="noopener noreferrer">WebSocketSessionManager</a> 定义接口，由 <a href="https://github.com/YunaiV/ruoyi-vue-pro/blob/master/yudao-framework/yudao-spring-boot-starter-websocket/src/main/java/cn/iocoder/yudao/framework/websocket/core/session/WebSocketSessionManagerImpl.java" target="_blank" rel="noopener noreferrer">WebSocketSessionManagerImpl</a> 具体实现。</p><div class="language-" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#abb2bf;--shiki-dark:#abb2bf;--shiki-light-bg:#282c34;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-dark-pro one-dark-pro vp-code"><code><span class="line"><span>// 添加和移除 Session</span></span>
<span class="line"><span>void addSession(WebSocketSession session);</span></span>
<span class="line"><span>void removeSession(WebSocketSession session);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 获得 Session，多种维度</span></span>
<span class="line"><span>WebSocketSession getSession(String id); // Session 编号</span></span>
<span class="line"><span>Collection&lt;WebSocketSession&gt; getSessionList(Integer userType); // 用户类型</span></span>
<span class="line"><span>Collection&lt;WebSocketSession&gt; getSessionList(Integer userType, Long userId); // 用户编号</span></span></code></pre></div><p>② WebSocket 建立和关闭连接时，通过 <a href="https://github.com/YunaiV/ruoyi-vue-pro/blob/master/yudao-framework/yudao-spring-boot-starter-websocket/src/main/java/cn/iocoder/yudao/framework/websocket/core/session/WebSocketSessionHandlerDecorator.java" target="_blank" rel="noopener noreferrer">WebSocketSessionHandlerDecorator</a> 处理器，分别调用 WebSocketSessionManager 进行 Session 的添加和移除。</p><h3 id="_1-3-message-消息格式" tabindex="-1"><a class="header-anchor" href="#_1-3-message-消息格式"><span><a href="#_1-3-message-%E6%B6%88%E6%81%AF%E6%A0%BC%E5%BC%8F">#</a> 1.3 Message 消息格式</span></a></h3><p>WebSocket 默认使用“文本”进行通信，而业务需要按照不同类型的消息，进行不同的处理。因此，项目定义了 <a href="https://github.com/YunaiV/ruoyi-vue-pro/blob/master/yudao-framework/yudao-spring-boot-starter-websocket/src/main/java/cn/iocoder/yudao/framework/websocket/core/message/JsonWebSocketMessage.java" target="_blank" rel="noopener noreferrer">JsonWebSocketMessage</a> 消息对象，包含 <code>type</code> 消息类型 + <code>content</code> 消息内容。</p><p>和 Spring MVC 对比，可以理解为：</p><table><thead><tr><th></th><th>标识</th><th>方法</th><th>参数</th></tr></thead><tbody><tr><td>Spring MVC</td><td>URL + Method 等</td><td>Controller 的 Method 方法</td><td>QueryString 或 RequestBody 等</td></tr><tr><td>项目 WebSocket</td><td><code>type</code> 消息类型</td><td><a href="https://github.com/YunaiV/ruoyi-vue-pro/blob/master/yudao-framework/yudao-spring-boot-starter-websocket/src/main/java/cn/iocoder/yudao/framework/websocket/core/listener/WebSocketMessageListener.java" target="_blank" rel="noopener noreferrer">WebSocketMessageListener</a> 实现类</td><td>解析 <code>content</code> 消息内容后的 Message 对象</td></tr></tbody></table><p>具体 JsonWebSocketMessage 和 WebSocketMessageListener 详细说明，参见「1.4 Message 消息接收」小节。</p><h3 id="_1-4-message-消息接收" tabindex="-1"><a class="header-anchor" href="#_1-4-message-消息接收"><span><a href="#_1-4-message-%E6%B6%88%E6%81%AF%E6%8E%A5%E6%94%B6">#</a> 1.4 Message 消息接收</span></a></h3><p>① WebSocket 接收到项目后，会先交给 <a href="https://github.com/YunaiV/ruoyi-vue-pro/blob/master/yudao-framework/yudao-spring-boot-starter-websocket/src/main/java/cn/iocoder/yudao/framework/websocket/core/handler/JsonWebSocketMessageHandler.java" target="_blank" rel="noopener noreferrer">JsonWebSocketMessageHandler</a> 消息处理器，将消息解析成 JsonWebSocketMessage 对象。</p><p>之后，根据 <code>type</code> 消息类型，获得到 WebSocketMessageListener 实现类，并将 <code>content</code> 消息内容进一步解析成 Message 对象，交给它进行处理。</p><p>② 具体案例，可见 <a href="https://github.com/YunaiV/ruoyi-vue-pro/blob/master/yudao-module-infra/yudao-module-infra-biz/src/main/java/cn/iocoder/yudao/module/infra/websocket/DemoWebSocketMessageListener.java" target="_blank" rel="noopener noreferrer">DemoWebSocketMessageListener</a>、<a href="https://github.com/YunaiV/ruoyi-vue-pro/blob/master/yudao-module-infra/yudao-module-infra-biz/src/main/java/cn/iocoder/yudao/module/infra/websocket/message/DemoSendMessage.java" target="_blank" rel="noopener noreferrer">DemoSendMessage</a> 类。</p><h3 id="_1-5-message-消息推送" tabindex="-1"><a class="header-anchor" href="#_1-5-message-消息推送"><span><a href="#_1-5-message-%E6%B6%88%E6%81%AF%E6%8E%A8%E9%80%81">#</a> 1.5 Message 消息推送</span></a></h3><p>① 项目的 <a href="https://github.com/YunaiV/ruoyi-vue-pro/blob/master/yudao-framework/yudao-spring-boot-starter-websocket/src/main/java/cn/iocoder/yudao/framework/websocket/core/sender/WebSocketMessageSender.java" target="_blank" rel="noopener noreferrer">WebSocketMessageSender</a> 接口，定义了给 Session 发送消息的方法。如下所示：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#abb2bf;--shiki-dark:#abb2bf;--shiki-light-bg:#282c34;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-dark-pro one-dark-pro vp-code"><code><span class="line"><span>// WebSocketMessageSender.java</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// ① 发送消息给指定用户</span></span>
<span class="line"><span>void send(Integer userType, Long userId, String messageType, String messageContent);</span></span>
<span class="line"><span>default void sendObject(Integer userType, Long userId, String messageType, Object messageContent) {</span></span>
<span class="line"><span>    send(userType, userId, messageType, JsonUtils.toJsonString(messageContent));</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// ② 发送消息给指定用户类型</span></span>
<span class="line"><span>void send(Integer userType, String messageType, String messageContent);</span></span>
<span class="line"><span>default void sendObject(Integer userType, String messageType, Object messageContent) {</span></span>
<span class="line"><span>    send(userType, messageType, JsonUtils.toJsonString(messageContent));</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// ③ 发送消息给指定 Session</span></span>
<span class="line"><span>void send(String sessionId, String messageType, String messageContent);</span></span>
<span class="line"><span>default void sendObject(String sessionId, String messageType, Object messageContent) {</span></span>
<span class="line"><span>    send(sessionId, messageType, JsonUtils.toJsonString(messageContent));</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>② WebSocketMessageSender 有多种实现类，如下：</p>`,31)),s("table",null,[e[17]||(e[17]=s("thead",null,[s("tr",null,[s("th",null,"实现类"),s("th",null,"是否支持 WebSocket 集群"),s("th",null,"前置要求")])],-1)),s("tbody",null,[e[16]||(e[16]=s("tr",null,[s("td",null,"LocalWebSocketMessageSender"),s("td",null,"❌"),s("td",null,"无")],-1)),s("tr",null,[e[2]||(e[2]=s("td",null,"RedisWebSocketMessageSender",-1)),e[3]||(e[3]=s("td",null,"✅",-1)),s("td",null,[e[1]||(e[1]=a("开启 ")),o(n,{to:"/message-queue/redis/"},{default:t(()=>e[0]||(e[0]=[a("《消息队列（Redis）》")])),_:1})])]),s("tr",null,[e[6]||(e[6]=s("td",null,"RocketMQWebSocketMessageSender",-1)),e[7]||(e[7]=s("td",null,"✅",-1)),s("td",null,[e[5]||(e[5]=a("开启 ")),o(n,{to:"/message-queue/rocketmq/"},{default:t(()=>e[4]||(e[4]=[a("《消息队列（RocketMQ）》")])),_:1})])]),s("tr",null,[e[10]||(e[10]=s("td",null,"KafkaWebSocketMessageSender",-1)),e[11]||(e[11]=s("td",null,"✅",-1)),s("td",null,[e[9]||(e[9]=a("开启 ")),o(n,{to:"/message-queue/kafka/"},{default:t(()=>e[8]||(e[8]=[a("《消息队列（Kafka）》")])),_:1})])]),s("tr",null,[e[14]||(e[14]=s("td",null,"RabbitMQWebSocketMessageSender",-1)),e[15]||(e[15]=s("td",null,"✅",-1)),s("td",null,[e[13]||(e[13]=a("开启 ")),o(n,{to:"/message-queue/rabbitmq/"},{default:t(()=>e[12]||(e[12]=[a("《消息队列（RabbitMQ）》")])),_:1})])])])]),e[19]||(e[19]=i(`<p>疑问：什么是 WebSocket 集群？</p><p>在后端部署多个 Java 进程时，会形成 WebSocket 集群。此时，就会存在跨进程的消息推送问题。例如说，连接 A 进程的 WebSocket 的用户，想要发送消息给连接 B 进程的 WebSocket 用户。</p><p>😁 如何解决呢？消息不直接发送给用户 WebSocketSession，而是先发给 Redis、RocketMQ 等消息队列，再由每个 Java 进程监听该消息，分别判断判断该用户 WebSocket 是否连接的是自己，如果是，则进行消息推送。</p><p>默认配置下，使用 LocalWebSocketMessageSender 本地发送消息，不支持 WebSocket 集群。可通过修改 <code>application.yaml</code> 配置文件的 <code>yudao.websocket.sender-type</code> 来切换，如下：</p><div class="language-" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#abb2bf;--shiki-dark:#abb2bf;--shiki-light-bg:#282c34;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-dark-pro one-dark-pro vp-code"><code><span class="line"><span>yudao:</span></span>
<span class="line"><span>  websocket:</span></span>
<span class="line"><span>    enable: true # websocket的开关</span></span>
<span class="line"><span>    path: /infra/ws # 路径</span></span>
<span class="line"><span>    sender-type: redis # 消息发送的类型，可选值为 local、redis、rocketmq、kafka、rabbitmq</span></span>
<span class="line"><span>    sender-rocketmq:</span></span>
<span class="line"><span>      topic: \${spring.application.name}-websocket # 消息发送的 RocketMQ Topic</span></span>
<span class="line"><span>      consumer-group: \${spring.application.name}-websocket-consumer # 消息发送的 RocketMQ Consumer Group</span></span>
<span class="line"><span>    sender-rabbitmq:</span></span>
<span class="line"><span>      exchange: \${spring.application.name}-websocket-exchange # 消息发送的 RabbitMQ Exchange</span></span>
<span class="line"><span>      queue: \${spring.application.name}-websocket-queue # 消息发送的 RabbitMQ Queue</span></span>
<span class="line"><span>    sender-kafka:</span></span>
<span class="line"><span>      topic: \${spring.application.name}-websocket # 消息发送的 Kafka Topic</span></span>
<span class="line"><span>      consumer-group: \${spring.application.name}-websocket-consumer # 消息发送的 Kafka Consumer Group</span></span></code></pre></div><p>另外，默认的 WebSocket 连接地址是 <code>ws://127.0.0.1:48080/infra/ws</code>，可通过 <code>yudao.websocket.path</code> 配置项进行修改。</p><h2 id="_2-使用方案" tabindex="-1"><a class="header-anchor" href="#_2-使用方案"><span><a href="#_2-%E4%BD%BF%E7%94%A8%E6%96%B9%E6%A1%88">#</a> 2. 使用方案</span></a></h2><p>目前有 2 种使用方案，分别是：</p><table><thead><tr><th>方案名</th><th>上行</th><th>下行</th></tr></thead><tbody><tr><td>方案一：纯 WebSocket</td><td>WebSocket</td><td>WebSocket</td></tr><tr><td>方案二：WebSocket + HTTP</td><td>HTTP</td><td>WebSocket</td></tr></tbody></table><p>疑问：什么是上行？什么是下行？</p><ul><li>上行：指的是“前端”发送消息给“后端”，WebSocket 和 HTTP 都可以。</li><li>下行：指的是“后端”发送消息给“前端”，只能使用 WebSocket。<br> 友情提示：下文中提到的所有配置，项目都已经配置好。你只需要按照下文的步骤，进行调试即可，了解每个配置的作用即可。</li></ul><h3 id="_2-1-方案一-纯-websocket" tabindex="-1"><a class="header-anchor" href="#_2-1-方案一-纯-websocket"><span><a href="#_2-1-%E6%96%B9%E6%A1%88%E4%B8%80-%E7%BA%AF-websocket">#</a> 2.1 方案一：纯 WebSocket</span></a></h3><figure><img src="https://doc.iocoder.cn/img/WebSocket/WebSocket测试界面.png" alt="WebSocket 测试界面" tabindex="0" loading="lazy"><figcaption>WebSocket 测试界面</figcaption></figure><ul><li>前端：见 [基础设施 -&gt; WebSocket 测试] 菜单，对应 <a href="https://github.com/yudaocode/yudao-ui-admin-vue3/blob/master/src/views/infra/webSocket/index.vue" target="_blank" rel="noopener noreferrer">/views/infra/websocket/index.vue</a> 界面</li><li>后端：见 <code>yudao-module-infra-biz</code> 模块，对应 <a href="https://github.com/YunaiV/ruoyi-vue-pro/blob/master/yudao-module-infra/yudao-module-infra-biz/src/main/java/cn/iocoder/yudao/module/infra/websocket/DemoWebSocketMessageListener.java" target="_blank" rel="noopener noreferrer">DemoWebSocketMessageListener</a> 监听器</li></ul><p>基于 WebSocket 实现的单聊和群聊，暂时不支持消息的持久化（刷新后，消息会消息）。建议，多多调试，更好的理解 WebSocket 流程。</p><h4 id="_2-1-1-后端代码" tabindex="-1"><a class="header-anchor" href="#_2-1-1-后端代码"><span><a href="#_2-1-1-%E5%90%8E%E7%AB%AF%E4%BB%A3%E7%A0%81">#</a> 2.1.1 后端代码</span></a></h4><p>① 在 <code>yudao-module-infra-biz</code> 模块的 <code>pom.xml</code> 文件中，引入 <code>yudao-spring-boot-starter-websocket</code> 依赖。如下所示：</p><div class="language-" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#abb2bf;--shiki-dark:#abb2bf;--shiki-light-bg:#282c34;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-dark-pro one-dark-pro vp-code"><code><span class="line"><span>    &lt;dependency&gt;</span></span>
<span class="line"><span>        &lt;groupId&gt;cn.iocoder.boot&lt;/groupId&gt;</span></span>
<span class="line"><span>        &lt;artifactId&gt;yudao-spring-boot-starter-websocket&lt;/artifactId&gt;</span></span>
<span class="line"><span>    &lt;/dependency&gt;</span></span></code></pre></div><p>② 新建 DemoWebSocketMessageListener 类，实现对应消息的处理。如下图所示：</p><figure><img src="https://doc.iocoder.cn/img/WebSocket/DemoWebSocketMessageListener类.png" alt="DemoWebSocketMessageListener 类" tabindex="0" loading="lazy"><figcaption>DemoWebSocketMessageListener 类</figcaption></figure><h4 id="_2-1-2-前端代码" tabindex="-1"><a class="header-anchor" href="#_2-1-2-前端代码"><span><a href="#_2-1-2-%E5%89%8D%E7%AB%AF%E4%BB%A3%E7%A0%81">#</a> 2.1.2 前端代码</span></a></h4><p>① 建立 WebSocket 连接，如下图所示：</p><figure><img src="https://doc.iocoder.cn/img/WebSocket/WebSocket连接.png" alt="WebSocket 连接" tabindex="0" loading="lazy"><figcaption>WebSocket 连接</figcaption></figure><p>② 发送 WebSocket 消息，如下图所示：</p><figure><img src="https://doc.iocoder.cn/img/WebSocket/WebSocket发送消息.png" alt="WebSocket 发送消息" tabindex="0" loading="lazy"><figcaption>WebSocket 发送消息</figcaption></figure><p>③ 接收 WebSocket 消息。如下图所示：</p><figure><img src="https://doc.iocoder.cn/img/WebSocket/WebSocket接收消息.png" alt="WebSocket 接收消息" tabindex="0" loading="lazy"><figcaption>WebSocket 接收消息</figcaption></figure><h3 id="_2-2-方案二-websocket-http" tabindex="-1"><a class="header-anchor" href="#_2-2-方案二-websocket-http"><span><a href="#_2-2-%E6%96%B9%E6%A1%88%E4%BA%8C-websocket-http">#</a> 2.2 方案二：WebSocket + HTTP</span></a></h3><figure><img src="https://doc.iocoder.cn/img/WebSocket/公告通知.png" alt="公告通知" tabindex="0" loading="lazy"><figcaption>公告通知</figcaption></figure><ul><li>前端：见 [系统管理 -&gt; 消息中心 -&gt; 通知公告] 菜单，对应 <a href="https://github.com/yudaocode/yudao-ui-admin-vue3/blob/master/src/views/system/notice/index.vue" target="_blank" rel="noopener noreferrer">/views/system/notice/index.vue</a> 界面的【推送】按钮</li><li>后端：见 <code>yudao-module-system-biz</code> 模块，对应 <a href="https://github.com/YunaiV/ruoyi-vue-pro/blob/master/yudao-module-infra/yudao-module-infra-biz/src/main/java/cn/iocoder/yudao/module/infra/websocket/DemoWebSocketMessageListener.java" target="_blank" rel="noopener noreferrer">DemoWebSocketMessageListener</a> 监听器</li></ul><p>点击某条公告的【推送】按钮，仅仅推送给所有在线用户。由于 WebSocket 目前暂时没全局建立，所以还是使用 [基础设施 -&gt; WebSocket 测试] 菜单演示。如下图所示：</p><figure><img src="https://doc.iocoder.cn/img/WebSocket/公告通知的推送.png" alt="公告通知的推送" tabindex="0" loading="lazy"><figcaption>公告通知的推送</figcaption></figure><h4 id="_2-2-1-后端代码" tabindex="-1"><a class="header-anchor" href="#_2-2-1-后端代码"><span><a href="#_2-2-1-%E5%90%8E%E7%AB%AF%E4%BB%A3%E7%A0%81">#</a> 2.2.1 后端代码</span></a></h4><p>【相同】① 在 <code>yudao-module-infra-biz</code> 模块的 <code>pom.xml</code> 文件中，引入 <code>yudao-spring-boot-starter-websocket</code> 依赖。</p><p>【不同】② 在 <code>yudao-module-system-biz</code> 模块的 <code>pom.xml</code> 文件中，引入 <code>yudao-module-infra-api</code> 依赖。如下所示：</p><div class="language-" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#abb2bf;--shiki-dark:#abb2bf;--shiki-light-bg:#282c34;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-dark-pro one-dark-pro vp-code"><code><span class="line"><span>    &lt;dependency&gt;</span></span>
<span class="line"><span>        &lt;groupId&gt;cn.iocoder.boot&lt;/groupId&gt;</span></span>
<span class="line"><span>        &lt;artifactId&gt;yudao-module-infra-api&lt;/artifactId&gt;</span></span>
<span class="line"><span>        &lt;version&gt;\${revision}&lt;/version&gt;</span></span>
<span class="line"><span>    &lt;/dependency&gt;</span></span></code></pre></div><p>【不同】③ 在 <code>yudao-module-system-biz</code> 模块，在 NoticeController 类中，新建 <code>#push(...)</code> 方法，用于推送公告消息。如下图所示：</p><figure><img src="https://doc.iocoder.cn/img/WebSocket/NoticeController推送.png" alt="NoticeController 推送" tabindex="0" loading="lazy"><figcaption>NoticeController 推送</figcaption></figure><p>本质上，它替代了方案一的 DemoWebSocketMessageListener 类，走 HTTP 上行消息，替代 WebSocket 上行消息。</p><p>疑问：WebSocketSenderApi 是什么？</p><p>它是由 <code>yudao-module-infra-biz</code> 对 WebSocketMessageSender 的封装，因为只有它（<code>yudao-module-infra-biz</code>）可以访问到 WebSocketMessageSender 的实现类，所以需要通过 API 的方式，暴露给其它模块使用。</p><p>这也是为什么 <code>yudao-module-system-biz</code> 模块，需要引入 <code>yudao-module-infra-api</code> 依赖的原因。</p><h4 id="_2-2-2-前端代码" tabindex="-1"><a class="header-anchor" href="#_2-2-2-前端代码"><span><a href="#_2-2-2-%E5%89%8D%E7%AB%AF%E4%BB%A3%E7%A0%81">#</a> 2.2.2 前端代码</span></a></h4><p>【相同】① 建立 WebSocket 连接，和方案一相同，不重复截图。</p><p>【不同】② 发送 HTTP 消息，如下图所示：</p><figure><img src="https://doc.iocoder.cn/img/WebSocket/公告通知的前端调用.png" alt="HTTP 发送消息" tabindex="0" loading="lazy"><figcaption>HTTP 发送消息</figcaption></figure><p>本质上，它替代了方案一的 WebSocket 上行消息，走 HTTP 上行消息。</p><p>【相同】③ 接收 WebSocket 消息，和方案一相同，不重复截图。</p><h3 id="_2-3-如何选择" tabindex="-1"><a class="header-anchor" href="#_2-3-如何选择"><span><a href="#_2-3-%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9">#</a> 2.3 如何选择？</span></a></h3><p>我个人是倾向于方案二的，使用 HTTP 上行消息，使用 WebSocket 下行消息。原因如下：</p><p>① <code>yudao-module-infra-biz</code> 扮演一个 WebSocket 服务的角色，可以通过它来主动发送（下行）消息给前端。这样，未来如果使用 MQTT 中间件（例如说，EMQX、阿里云 MQTT、腾讯云 MQTT 等）替换现有 WebSocket 也比较方便。</p><p>② HTTP 上行消息，相比 WebSocket 上行消息来说，更加方便，也比较符合我们的编码习惯。</p><p>③ 在微服务架构下，多个服务是拆分开的，无法提供相同的 WebSocket 连接。例如说，<code>yudao-module-infra-biz</code> 和 <code>yudao-module-system-biz</code> 两个服务都需要有 WebSocket 推送能力时，需要前端分别连接它们两个服务。</p><p>考虑到 <code>ruoyi-vue-pro</code> 和 <code>yudao-cloud</code> 架构的统一性，还是只让 <code>yudao-module-infra-biz</code> 提供 WebSocket 服务：</p><ul><li>前端连接 <code>yudao-module-infra-biz</code> 的 WebSocket 服务，其它服务通过 <code>yudao-module-infra-biz</code> 下行消息。</li><li>前端 HTTP 上行消息时，还是通过 HTTP 调用各个服务。</li></ul><p>ps：如果你只用 <code>ruoyi-vue-pro</code> 单体架构，不会存在 ③ 的困扰，方案一也没问题。</p><hr><p>one more thing~ 后续我们会使用 WebSocket 实现 IM 即时通信功能，敬请期待。</p>`,58))])}const k=r(d,[["render",b],["__file","websocket.html.vue"]]),m=JSON.parse('{"path":"/project/rouyi-vue-pro/websocket.html","title":"WebSocket 实时通信","lang":"en-US","frontmatter":{"title":"WebSocket 实时通信","tags":["project","java","spring-boot","spring-cloud"],"categories":["project"],"order":30,"feed":false,"seo":false,"head":[]},"headers":[{"level":2,"title":"# 1. 功能简介","slug":"_1-功能简介","link":"#_1-功能简介","children":[{"level":3,"title":"# 1.1 Token 身份认证","slug":"_1-1-token-身份认证","link":"#_1-1-token-身份认证","children":[]},{"level":3,"title":"# 1.2 Session 会话管理","slug":"_1-2-session-会话管理","link":"#_1-2-session-会话管理","children":[]},{"level":3,"title":"# 1.3 Message 消息格式","slug":"_1-3-message-消息格式","link":"#_1-3-message-消息格式","children":[]},{"level":3,"title":"# 1.4 Message 消息接收","slug":"_1-4-message-消息接收","link":"#_1-4-message-消息接收","children":[]},{"level":3,"title":"# 1.5 Message 消息推送","slug":"_1-5-message-消息推送","link":"#_1-5-message-消息推送","children":[]}]},{"level":2,"title":"# 2. 使用方案","slug":"_2-使用方案","link":"#_2-使用方案","children":[{"level":3,"title":"# 2.1 方案一：纯 WebSocket","slug":"_2-1-方案一-纯-websocket","link":"#_2-1-方案一-纯-websocket","children":[]},{"level":3,"title":"# 2.2 方案二：WebSocket + HTTP","slug":"_2-2-方案二-websocket-http","link":"#_2-2-方案二-websocket-http","children":[]},{"level":3,"title":"# 2.3 如何选择？","slug":"_2-3-如何选择","link":"#_2-3-如何选择","children":[]}]}],"git":{"createdTime":1720365235000,"updatedTime":1720365235000,"contributors":[{"name":"Hung Nguyen Van","email":"vanhung4499@gmail.com","commits":1}]},"readingTime":{"minutes":8.73,"words":2618},"filePathRelative":"project/rouyi-vue-pro/websocket.md","localizedDate":"July 7, 2024"}');export{k as comp,m as data};
