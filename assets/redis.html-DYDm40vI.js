import{_ as a,o as e,c as n,a as i}from"./app-5QVbWi7Z.js";const l={};function p(r,s){return e(),n("div",null,s[0]||(s[0]=[i(`<h1 id="消息队列-redis" tabindex="-1"><a class="header-anchor" href="#消息队列-redis"><span>消息队列（Redis）</span></a></h1><p><a href="https://github.com/YunaiV/ruoyi-vue-pro/blob/master/yudao-framework/yudao-spring-boot-starter-mq/" target="_blank" rel="noopener noreferrer"><code>yudao-spring-boot-starter-mq</code></a> 技术组件，基于 Redis 实现分布式消息队列：</p><ul><li>使用 <a href="http://www.redis.cn/topics/streams-intro.html" target="_blank" rel="noopener noreferrer">Stream</a> 特性，提供【集群】消费的能力。</li><li>使用 <a href="http://www.redis.cn/topics/pubsub.html" target="_blank" rel="noopener noreferrer">Pub/Sub</a> 特性，提供【广播】消费的能力。</li></ul><p>疑问：什么是【广播】消费？什么是【集群】消费？</p><p>参见<a href="https://help.aliyun.com/zh/apsaramq-for-rocketmq/cloud-message-queue-rocketmq-4-x-series/developer-reference/clustering-consumption-and-broadcasting-consumption" target="_blank" rel="noopener noreferrer">《阿里云 —— 集群消费和广播消费 》</a>文档</p><h2 id="_1-集群消费" tabindex="-1"><a class="header-anchor" href="#_1-集群消费"><span><a href="#_1-%E9%9B%86%E7%BE%A4%E6%B6%88%E8%B4%B9">#</a> 1. 集群消费</span></a></h2><p>集群消费，是指消息发送到 Redis 时，有且只会被一个消费者（应用 JVM 实例）收到，然后消费成功。如下图所示：</p><figure><img src="https://doc.iocoder.cn/img/消息队列/Redis/集群消费.png" alt="集群消费" tabindex="0" loading="lazy"><figcaption>集群消费</figcaption></figure><p>友情提示：</p><p>如果你需要使用到【集群】消费，必须使用 Redis 5.0.0 以上版本，因为 Stream 特性是在该版本之后才引入噢！</p><h3 id="_1-1-使用场景" tabindex="-1"><a class="header-anchor" href="#_1-1-使用场景"><span><a href="#_1-1-%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF">#</a> 1.1 使用场景</span></a></h3><p>集群消费在项目中的使用场景，主要是提供可靠的、可堆积的异步任务的能力。例如说：</p><ul><li>短信模块，使用它<a href="https://github.com/YunaiV/ruoyi-vue-pro/blob/master/yudao-module-system/yudao-module-system-biz/src/main/java/cn/iocoder/yudao/module/system/mq/consumer/sms/SmsSendConsumer.java" target="_blank" rel="noopener noreferrer">异步</a>发送短信。</li><li>邮件模块，使用它<a href="https://github.com/YunaiV/ruoyi-vue-pro/blob/master/yudao-module-system/yudao-module-system-biz/src/main/java/cn/iocoder/yudao/module/system/mq/consumer/mail/MailSendConsumer.java" target="_blank" rel="noopener noreferrer">异步</a>发送邮件。</li></ul><p>相比 <a href="/async-task">《开发指南 —— 异步任务》</a> 来说，Spring Async 在 JVM 实例重启时，会导致未执行完的任务丢失。而集群消费，因为消息是存储在 Redis 中，所以不会存在该问题。</p><h3 id="_1-2-实现源码" tabindex="-1"><a class="header-anchor" href="#_1-2-实现源码"><span><a href="#_1-2-%E5%AE%9E%E7%8E%B0%E6%BA%90%E7%A0%81">#</a> 1.2 实现源码</span></a></h3><p>集群消费基于 Redis Stream 实现：</p><ul><li>实现 AbstractRedisStreamMessage 抽象类，定义【集群】消息。</li><li>使用 RedisMQTemplate 的 <code>#send(message)</code> 方法，发送消息。</li><li>实现 AbstractRedisStreamMessageListener 接口，消费消息。</li></ul><p>最终使用 YudaoRedisMQAutoConfiguration 配置类，扫描所有的 AbstractRedisStreamMessageListener 监听器，初始化对应的消费者。如下图所示：</p><figure><img src="https://doc.iocoder.cn/img/消息队列/Redis/YudaoRedisMQAutoConfiguration.png" alt="YudaoRedisMQAutoConfiguration" tabindex="0" loading="lazy"><figcaption>YudaoRedisMQAutoConfiguration</figcaption></figure><h3 id="_1-3-实战案例" tabindex="-1"><a class="header-anchor" href="#_1-3-实战案例"><span><a href="#_1-3-%E5%AE%9E%E6%88%98%E6%A1%88%E4%BE%8B">#</a> 1.3 实战案例</span></a></h3><p>以【短信发送】举例子，改造使用 Redis 作为消息队列，同时也是讲解集群消费的使用。如下图所示：</p><figure><img src="https://doc.iocoder.cn/img/消息队列/Redis/集群消费-案例.png" alt="实战案例" tabindex="0" loading="lazy"><figcaption>实战案例</figcaption></figure><h4 id="_1-3-0-引入依赖" tabindex="-1"><a class="header-anchor" href="#_1-3-0-引入依赖"><span><a href="#_1-3-0-%E5%BC%95%E5%85%A5%E4%BE%9D%E8%B5%96">#</a> 1.3.0 引入依赖</span></a></h4><p>在 <code>yudao-module-system-biz</code> 模块中，引入 <code>yudao-spring-boot-starter-mq</code> 技术组件。如下所示：</p><div class="language-" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#abb2bf;--shiki-dark:#abb2bf;--shiki-light-bg:#282c34;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-dark-pro one-dark-pro vp-code"><code><span class="line"><span>&lt;dependency&gt;</span></span>
<span class="line"><span>    &lt;groupId&gt;cn.iocoder.boot&lt;/groupId&gt;</span></span>
<span class="line"><span>    &lt;artifactId&gt;yudao-spring-boot-starter-mq&lt;/artifactId&gt;</span></span>
<span class="line"><span>&lt;/dependency&gt;</span></span></code></pre></div><h4 id="_1-3-1-message-消息" tabindex="-1"><a class="header-anchor" href="#_1-3-1-message-消息"><span><a href="#_1-3-1-message-%E6%B6%88%E6%81%AF">#</a> 1.3.1 Message 消息</span></a></h4><p>在 <code>message</code> 包下，修改 SmsSendMessage 类，短信发送消息。代码如下：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#abb2bf;--shiki-dark:#abb2bf;--shiki-light-bg:#282c34;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-dark-pro one-dark-pro vp-code"><code><span class="line"><span>@Data</span></span>
<span class="line"><span>public class SmsSendMessage extends AbstractRedisStreamMessage { // 重点：需要继承 AbstractRedisStreamMessage 类</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    /**</span></span>
<span class="line"><span>     * 短信日志编号</span></span>
<span class="line"><span>     */</span></span>
<span class="line"><span>    @NotNull(message = &quot;短信日志编号不能为空&quot;)</span></span>
<span class="line"><span>    private Long logId;</span></span>
<span class="line"><span>    /**</span></span>
<span class="line"><span>     * 手机号</span></span>
<span class="line"><span>     */</span></span>
<span class="line"><span>    @NotNull(message = &quot;手机号不能为空&quot;)</span></span>
<span class="line"><span>    private String mobile;</span></span>
<span class="line"><span>    /**</span></span>
<span class="line"><span>     * 短信渠道编号</span></span>
<span class="line"><span>     */</span></span>
<span class="line"><span>    @NotNull(message = &quot;短信渠道编号不能为空&quot;)</span></span>
<span class="line"><span>    private Long channelId;</span></span>
<span class="line"><span>    /**</span></span>
<span class="line"><span>     * 短信 API 的模板编号</span></span>
<span class="line"><span>     */</span></span>
<span class="line"><span>    @NotNull(message = &quot;短信 API 的模板编号不能为空&quot;)</span></span>
<span class="line"><span>    private String apiTemplateId;</span></span>
<span class="line"><span>    /**</span></span>
<span class="line"><span>     * 短信模板参数</span></span>
<span class="line"><span>     */</span></span>
<span class="line"><span>    private List&lt;KeyValue&lt;String, Object&gt;&gt; templateParams;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_1-3-2-smsproducer-生产者" tabindex="-1"><a class="header-anchor" href="#_1-3-2-smsproducer-生产者"><span><a href="#_1-3-2-smsproducer-%E7%94%9F%E4%BA%A7%E8%80%85">#</a> 1.3.2 SmsProducer 生产者</span></a></h4><p>在 <code>producer</code> 包下，修改 SmsProducer 类，Sms 短信相关消息的生产者。代码如下：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#abb2bf;--shiki-dark:#abb2bf;--shiki-light-bg:#282c34;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-dark-pro one-dark-pro vp-code"><code><span class="line"><span>@Slf4j</span></span>
<span class="line"><span>@Component</span></span>
<span class="line"><span>public class SmsProducer {</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    @Resource</span></span>
<span class="line"><span>    private RedisMQTemplate redisMQTemplate; // 重点：注入 RedisMQTemplate 对象</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    /**</span></span>
<span class="line"><span>     * 发送 {@link SmsSendMessage} 消息</span></span>
<span class="line"><span>     *</span></span>
<span class="line"><span>     * @param logId 短信日志编号</span></span>
<span class="line"><span>     * @param mobile 手机号</span></span>
<span class="line"><span>     * @param channelId 渠道编号</span></span>
<span class="line"><span>     * @param apiTemplateId 短信模板编号</span></span>
<span class="line"><span>     * @param templateParams 短信模板参数</span></span>
<span class="line"><span>     */</span></span>
<span class="line"><span>    public void sendSmsSendMessage(Long logId, String mobile,</span></span>
<span class="line"><span>                                   Long channelId, String apiTemplateId, List&lt;KeyValue&lt;String, Object&gt;&gt; templateParams) {</span></span>
<span class="line"><span>        SmsSendMessage message = new SmsSendMessage().setLogId(logId).setMobile(mobile);</span></span>
<span class="line"><span>        message.setChannelId(channelId).setApiTemplateId(apiTemplateId).setTemplateParams(templateParams);</span></span>
<span class="line"><span>        redisMQTemplate.send(message); // 重点：使用 RedisMQTemplate 发送消息</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_1-3-3-smssendconsumer-消费者" tabindex="-1"><a class="header-anchor" href="#_1-3-3-smssendconsumer-消费者"><span><a href="#_1-3-3-smssendconsumer-%E6%B6%88%E8%B4%B9%E8%80%85">#</a> 1.3.3 SmsSendConsumer 消费者</span></a></h4><p>在 <code>consumer</code> 包下，修改 SmsSendConsumer 类，SmsSendMessage 的消费者。代码如下：</p><div class="language-" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#abb2bf;--shiki-dark:#abb2bf;--shiki-light-bg:#282c34;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-dark-pro one-dark-pro vp-code"><code><span class="line"><span>@Component</span></span>
<span class="line"><span>@Slf4j</span></span>
<span class="line"><span>public class SmsSendConsumer extends AbstractRedisStreamMessageListener&lt;SmsSendMessage&gt; { // 重点：继承 AbstractRedisStreamMessageListener 类，并填写对应的 Message 类</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    @Resource</span></span>
<span class="line"><span>    private SmsSendService smsSendService;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    @Override // 重点：实现 onMessage 方法</span></span>
<span class="line"><span>    public void onMessage(SmsSendMessage message) {</span></span>
<span class="line"><span>        log.info(&quot;[onMessage][消息内容({})]&quot;, message);</span></span>
<span class="line"><span>        smsSendService.doSendSms(message);</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>}</span></span></code></pre></div><h4 id="_1-3-4-简单测试" tabindex="-1"><a class="header-anchor" href="#_1-3-4-简单测试"><span><a href="#_1-3-4-%E7%AE%80%E5%8D%95%E6%B5%8B%E8%AF%95">#</a> 1.3.4 简单测试</span></a></h4><p>① Debug 启动后端项目，可以在 SmsProducer 和 SmsSendConsumer 上面打上断点，稍微调试下。</p><p>② 打开 <code>SmsTemplateController.http</code> 文件，使用 IDEA httpclient 发起请求，发送短信。如下图所示：</p><figure><img src="https://doc.iocoder.cn/img/消息队列/内存/简单测试.png" alt="简单测试" tabindex="0" loading="lazy"><figcaption>简单测试</figcaption></figure><p>如果 IDEA 控制台看到 <code>[onMessage][消息内容</code> 日志内容，说明消息的发送和消费成功。</p><h2 id="_2-广播消费" tabindex="-1"><a class="header-anchor" href="#_2-广播消费"><span><a href="#_2-%E5%B9%BF%E6%92%AD%E6%B6%88%E8%B4%B9">#</a> 2. 广播消费</span></a></h2><p>广播消费，是指消息发送到 Redis 时，所有消费者（应用 JVM 实例）收到，然后消费成功。如下图所示：</p><figure><img src="https://doc.iocoder.cn/img/消息队列/Redis/广播消费.png" alt="集群消费" tabindex="0" loading="lazy"><figcaption>集群消费</figcaption></figure><h3 id="_2-1-使用场景" tabindex="-1"><a class="header-anchor" href="#_2-1-使用场景"><span><a href="#_2-1-%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF">#</a> 2.1 使用场景</span></a></h3><p>例如说，在应用中，缓存了数据字典等配置表在内存中，可以通过 Redis 广播消费，实现每个应用节点都消费消息，刷新本地内存的缓存。</p><p>又例如说，我们基于 WebSocket 实现了 IM 聊天，在我们给用户主动发送消息时，因为我们不知道用户连接的是哪个提供 WebSocket 的应用，所以可以通过 Redis 广播消费。每个应用判断当前用户是否是和自己提供的 WebSocket 服务连接，如果是，则推送消息给用户。</p><h3 id="_2-2-实现源码" tabindex="-1"><a class="header-anchor" href="#_2-2-实现源码"><span><a href="#_2-2-%E5%AE%9E%E7%8E%B0%E6%BA%90%E7%A0%81">#</a> 2.2 实现源码</span></a></h3><p>广播消费基于 Redis Pub/Sub 实现：</p><ul><li>实现 AbstractChannelMessage 抽象类，定义【广播】消息。</li><li>使用 RedisMQTemplate 的 <code>#send(message)</code> 方法，发送消息。</li><li>实现 AbstractRedisChannelMessageListener 接口，消费消息。</li></ul><p>最终使用 YudaoRedisMQAutoConfiguration 配置类，扫描所有的 AbstractRedisChannelMessageListener 监听器，初始化对应的消费者。如下图所示：</p><figure><img src="https://doc.iocoder.cn/img/消息队列/Redis/YudaoRedisMQAutoConfiguration-02.png" alt="YudaoRedisMQAutoConfiguration" tabindex="0" loading="lazy"><figcaption>YudaoRedisMQAutoConfiguration</figcaption></figure><h3 id="_2-3-实战案例" tabindex="-1"><a class="header-anchor" href="#_2-3-实战案例"><span><a href="#_2-3-%E5%AE%9E%E6%88%98%E6%A1%88%E4%BE%8B">#</a> 2.3 实战案例</span></a></h3><p>参见 <a href="/local-cache">《开发指南 —— 本地缓存》</a></p>`,52)]))}const t=a(l,[["render",p],["__file","redis.html.vue"]]),c=JSON.parse('{"path":"/project/rouyi-vue-pro/message-queue/redis.html","title":"消息队列（Redis）","lang":"en-US","frontmatter":{"title":"消息队列（Redis）","tags":["project","java","spring-boot","spring-cloud"],"categories":["project"],"order":55,"feed":false,"seo":false,"head":[]},"headers":[{"level":2,"title":"# 1. 集群消费","slug":"_1-集群消费","link":"#_1-集群消费","children":[{"level":3,"title":"# 1.1 使用场景","slug":"_1-1-使用场景","link":"#_1-1-使用场景","children":[]},{"level":3,"title":"# 1.2 实现源码","slug":"_1-2-实现源码","link":"#_1-2-实现源码","children":[]},{"level":3,"title":"# 1.3 实战案例","slug":"_1-3-实战案例","link":"#_1-3-实战案例","children":[]}]},{"level":2,"title":"# 2. 广播消费","slug":"_2-广播消费","link":"#_2-广播消费","children":[{"level":3,"title":"# 2.1 使用场景","slug":"_2-1-使用场景","link":"#_2-1-使用场景","children":[]},{"level":3,"title":"# 2.2 实现源码","slug":"_2-2-实现源码","link":"#_2-2-实现源码","children":[]},{"level":3,"title":"# 2.3 实战案例","slug":"_2-3-实战案例","link":"#_2-3-实战案例","children":[]}]}],"git":{"createdTime":1720365235000,"updatedTime":1720365235000,"contributors":[{"name":"Hung Nguyen Van","email":"vanhung4499@gmail.com","commits":1}]},"readingTime":{"minutes":4.93,"words":1480},"filePathRelative":"project/rouyi-vue-pro/message-queue/redis.md","localizedDate":"July 7, 2024"}');export{t as comp,c as data};
