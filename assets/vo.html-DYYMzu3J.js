import{_ as n,g as c,o as i,c as d,a as t,e as a,h as o,f as s,w as l}from"./app-5QVbWi7Z.js";const p={};function u(g,e){const r=c("RouteLink");return i(),d("div",null,[e[4]||(e[4]=t('<h1 id="vo-对象转换、数据翻译" tabindex="-1"><a class="header-anchor" href="#vo-对象转换、数据翻译"><span>VO 对象转换、数据翻译</span></a></h1><p>本小节，我们来讲解 VO 的对象转换、数据翻译的功能。注意，这里的 VO 是泛指 Java POJO 对象，也可以是 DTO、BO 等等。</p><h2 id="_1-对象转换" tabindex="-1"><a class="header-anchor" href="#_1-对象转换"><span><a href="#_1-%E5%AF%B9%E8%B1%A1%E8%BD%AC%E6%8D%A2">#</a> 1. 对象转换</span></a></h2><p>对象转换，指的是 A 类型对象，转换成 B 类型对象。例如说，我们有一个 UserDO 类型对象，需要转换成 UserVO 或者 UserDTO 类型对象。</p><p>市面上有很多的对象转换工具，例如说 MapStruct、Dozer、各种 BeanUtils、BeanCopier 等等。目前我们提供了 MapStruct、BeanUtils 两种解决方案。</p><p>相比来说，MapStruct 性能会略好于 BeanUtils，但是相比数据库操作带来的耗时来说，基本可以忽略不计。因此，一般情况下，建议使用 BeanUtils 即可。</p><h3 id="_1-1-mapstruct" tabindex="-1"><a class="header-anchor" href="#_1-1-mapstruct"><span><a href="#_1-1-mapstruct">#</a> 1.1 MapStruct</span></a></h3><p>项目使用 <a href="https://www.iocoder.cn/Spring-Boot/MapStruct/?yudao" target="_blank" rel="noopener noreferrer">MapStruct</a> 实现 VO、DO、DTO 等对象之间的转换。</p><p>如果你没有学习过 MapStruct，需要阅读下 <a href="https://www.iocoder.cn/Spring-Boot/MapStruct/?yudao" target="_blank" rel="noopener noreferrer">《芋道 Spring Boot 对象转换 MapStruct 入门》</a> 文章。</p><p>在每个 <code>yudao-module-xxx-biz</code> 模块的 <code>convert</code> 包下，可以看到各个业务的 Convert 接口，如下图所示：</p><figure><img src="https://cloud.iocoder.cn/img/后端手册/VO/MapStruct.png" alt="MapStruct 示例" tabindex="0" loading="lazy"><figcaption>MapStruct 示例</figcaption></figure><h3 id="_1-2-beanutils" tabindex="-1"><a class="header-anchor" href="#_1-2-beanutils"><span><a href="#_1-2-beanutils">#</a> 1.2 BeanUtils</span></a></h3><p>项目提供了 <a href="https://github.com/YunaiV/yudao-cloud/blob/master/yudao-framework/yudao-common/src/main/java/cn/iocoder/yudao/framework/common/util/object/BeanUtils.java" target="_blank" rel="noopener noreferrer">BeanUtils</a> 类，它是基于 Hutool 的 BeanUtil 封装一层。如下图所示：</p><figure><img src="https://cloud.iocoder.cn/img/后端手册/VO/BeanUtils.png" alt="BeanUtils" tabindex="0" loading="lazy"><figcaption>BeanUtils</figcaption></figure><p>疑问：为什么不直接使用 Hutool BeanUtil，而是额外封装一层呢？</p><p>① 方便替换实现。例如说，你想把 Hutool BeanUtil 换成 Spring BeanUtil、BeanCopier 等时，只需要修改它。</p><p>② 特性增强。额外支持 List、Page 对象的转换，也支持 Consumer 进一步转化。</p><p>1、在简单场景，直接使用 BeanUtils 的 <code>#toBean(...)</code> 方法，如下图所示：</p><figure><img src="https://cloud.iocoder.cn/img/后端手册/VO/BeanUtils-01.png" alt="简单场景" tabindex="0" loading="lazy"><figcaption>简单场景</figcaption></figure><p>2、在复杂场景，可以通过 Consumer 进一步拼接，如下图所示：</p><figure><img src="https://cloud.iocoder.cn/img/后端手册/VO/BeanUtils-02.png" alt="复杂场景" tabindex="0" loading="lazy"><figcaption>复杂场景</figcaption></figure><p>当然，如果 Consumer 的逻辑比较复杂，又希望 Controller 代码精简一点，可以放到对应的 Convert 类里，如下图所示：</p><figure><img src="https://cloud.iocoder.cn/img/后端手册/VO/BeanUtils-03.png" alt="更复杂场景" tabindex="0" loading="lazy"><figcaption>更复杂场景</figcaption></figure><h2 id="_2-数据翻译" tabindex="-1"><a class="header-anchor" href="#_2-数据翻译"><span><a href="#_2-%E6%95%B0%E6%8D%AE%E7%BF%BB%E8%AF%91">#</a> 2. 数据翻译</span></a></h2><p>数据翻译，指的是将 A 类型对象的某个字段，“翻译”成 B 类型对象的某个字段。例如说，我们有一个 UserVO 的 <code>deptId</code> 字段，读取对应 DeptDO 的 <code>name</code> 字段，最终设置到 UserVO 的 <code>deptName</code> 字段。</p><p>一般来说，目前有两种方案：</p>',26)),a("ul",null,[a("li",null,[e[1]||(e[1]=o("方案一：数据库 SQL 联表查询，可见 ")),s(r,{to:"/mybatis-pro/"},{default:l(()=>e[0]||(e[0]=[o("《MyBatis 联表&分页查询》")])),_:1}),e[2]||(e[2]=o(" 文档"))]),e[3]||(e[3]=a("li",null,"方案二：数据库多次单表查询，然后在 Java 代码中进行数据拼接（翻译）。其实就是「1.2 BeanUtils」的“复杂场景”。如下图所示：",-1))]),e[5]||(e[5]=t('<figure><img src="https://cloud.iocoder.cn/img/后端手册/VO/BeanUtils-02.png" alt="复杂场景" tabindex="0" loading="lazy"><figcaption>复杂场景</figcaption></figure><p>项目里，大多数采用“方案二”，因为这样可以减少数据库的压力，避免 SQL 过于复杂，也方便后续维护。</p><p>不过如果你觉得“方案二”比较麻烦，我们也集成了 <a href="https://gitee.com/dromara/easy_trans" target="_blank" rel="noopener noreferrer"><code>easy-trans</code></a> 框架，一个注解，搞定数据翻译。</p><p>下面，我们来分场景，看看具体如何使用！</p><h3 id="_2-1-场景一-模块内翻译" tabindex="-1"><a class="header-anchor" href="#_2-1-场景一-模块内翻译"><span><a href="#_2-1-%E5%9C%BA%E6%99%AF%E4%B8%80-%E6%A8%A1%E5%9D%97%E5%86%85%E7%BF%BB%E8%AF%91">#</a> 2.1 场景一：模块内翻译</span></a></h3><p>模块内翻译，指的是在同一个模块内，进行数据翻译。例如说，OperateLogRespVO 属于 <code>yudao-module-system</code> 模块，需要读取模块内的 AdminUserDO 数据。</p><p>① 第一步，给 OperateLogRespVO 实现 <code>com.fhs.core.trans.vo.VO</code> 接口。</p><p>② 第二步，给 OperateLogRespVO 的 <code>deptId</code> 字段，添加 <code>@Trans</code> 注解，如下图所示：</p><figure><img src="https://cloud.iocoder.cn/img/后端手册/VO/模块内翻译.png" alt="模块内翻译" tabindex="0" loading="lazy"><figcaption>模块内翻译</figcaption></figure><ul><li><code>type</code> 属性：使用 <code>TransType.SIMPLE</code> 简单翻译，使用 MyBatis Plus</li><li><code>target</code> 属性：目标 DO 实体的类，例如说 <code>AdminUserDO.class</code></li><li><code>fields</code> 属性：读取 DO 实体的字段，例如说 <code>nickname</code>。如果是多个字段，它也是个数组</li><li><code>ref</code> 属性：设置 VO 类的字段，例如说 <code>userNickname</code>。如果是多个字段，可以使用 <code>refs</code></li></ul><p>更多关于 <code>@Trans</code> 注解的讲解，可见 <a href="http://easy-trans.fhs-opensource.top/components/trans.html" target="_blank" rel="noopener noreferrer">《Trans 注解详解(必读)》</a> 文档。</p><h3 id="_2-2-场景二-跨服务翻译" tabindex="-1"><a class="header-anchor" href="#_2-2-场景二-跨服务翻译"><span><a href="#_2-2-%E5%9C%BA%E6%99%AF%E4%BA%8C-%E8%B7%A8%E6%9C%8D%E5%8A%A1%E7%BF%BB%E8%AF%91">#</a> 2.2 场景二：跨服务翻译</span></a></h3><p>跨服务翻译，指的是在不同服务，通过 RPC 进行数据翻译。例如说，CrmProductRespVO 属于 <code>yudao-module-crm</code> 服务，需要读取 <code>yudao-module-system</code> 服务的 AdminUserRespDTO 数据。</p><p>使用上，会分成两块：</p><ul><li>【自定义翻译器】在 <code>yudao-module-system</code> 服务中，自定义一个 AutoTransable 数据翻译器的实现，提供 AdminUserRespDTO 的查询方法</li><li>【使用翻译器】在 <code>yudao-module-crm</code> 服务中，使用刚定义的 AutoTransable 数据翻译器，实现数据翻译</li></ul><h4 id="_2-2-1-自定义翻译器" tabindex="-1"><a class="header-anchor" href="#_2-2-1-自定义翻译器"><span><a href="#_2-2-1-%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BF%BB%E8%AF%91%E5%99%A8">#</a> 2.2.1 自定义翻译器</span></a></h4><p>整体参考 <a href="http://easy-trans.fhs-opensource.top/components/auto.html" target="_blank" rel="noopener noreferrer">《AUTO_TRANS 使用》</a> 文档。</p><p>① 第一步，给 AdminUserRespDTO 实现 <code>com.fhs.core.trans.vo.VO</code> 接口。</p><p>② 第二步，给 AdminUserApi 实现 <code>com.fhs.trans.service.AutoTransable</code> 接口，并实现对应的 <code>#selectByIds(...)</code> 和 <code>#selectById(...)</code> 方法，还要添加 <code>@AutoTrans</code> 注解，如下图所示：</p><figure><img src="https://cloud.iocoder.cn/img/后端手册/VO/自定义翻译器.png" alt="自定义翻译器" tabindex="0" loading="lazy"><figcaption>自定义翻译器</figcaption></figure><p>其中 <code>@AutoTrans</code> 注解，主要是两个属性：</p><ul><li><code>namespace</code> 属性：指定数据翻译器的命名空间，需要全局唯一，这里可以直接使用 AdminUserApi 的 <code>PREFIX</code></li><li><code>fields</code> 属性：哪些属性可以被翻译，例如说 <code>nickname</code> 昵称可以被翻译</li></ul><p>友情提示：</p><p>如果你使用的是 jdk8 版本，没有 <code>@FeignIgnore</code> 注解，可以分别添加 <code>@GetMapping(&quot;select&quot;)</code> 和 <code>@GetMapping(&quot;select-list&quot;)</code> 注解，不然 Feign 会启动检测，导致项目启动失败。</p><h4 id="_2-2-2-使用翻译器" tabindex="-1"><a class="header-anchor" href="#_2-2-2-使用翻译器"><span><a href="#_2-2-2-%E4%BD%BF%E7%94%A8%E7%BF%BB%E8%AF%91%E5%99%A8">#</a> 2.2.2 使用翻译器</span></a></h4><p>① 第一步，给 CrmProductRespVO 实现 <code>com.fhs.core.trans.vo.VO</code> 接口。</p><p>② 第二步，给 CrmProductRespVO 的 <code>ownerUserId</code> 字段，添加 <code>@Trans</code> 注解，如下图所示：</p><figure><img src="https://cloud.iocoder.cn/img/后端手册/VO/跨模块翻译.png" alt="跨模块翻译" tabindex="0" loading="lazy"><figcaption>跨模块翻译</figcaption></figure><ul><li><code>type</code> 属性：使用 <code>TransType.AUTO_TRANS</code> 自定义翻译器</li><li><code>key</code> 属性：使用自定义翻译器的 <code>namespace</code> 属性，这里就是 AdminUserApi 的 <code>PREFIX</code></li><li><code>fields</code> 和 <code>ref</code> 属性：同上，不重复解释</li></ul><h3 id="_2-3-场景三-excel-导出翻译" tabindex="-1"><a class="header-anchor" href="#_2-3-场景三-excel-导出翻译"><span><a href="#_2-3-%E5%9C%BA%E6%99%AF%E4%B8%89-excel-%E5%AF%BC%E5%87%BA%E7%BF%BB%E8%AF%91">#</a> 2.3 场景三：Excel 导出翻译</span></a></h3><p>在 Excel 导出时，如果也有数据翻译的需求，需要调用 <a href="https://github.com/YunaiV/yudao-cloud/blob/master/yudao-framework/yudao-spring-boot-starter-mybatis/src/main/java/cn/iocoder/yudao/framework/translate/core/TranslateUtils.java" target="_blank" rel="noopener noreferrer">TranslateUtils</a> 的 <code>#translate(...)</code> 方法，如下图所示：</p><figure><img src="https://cloud.iocoder.cn/img/后端手册/VO/导出翻译.png" alt="Excel 导出翻译" tabindex="0" loading="lazy"><figcaption>Excel 导出翻译</figcaption></figure><p>本质上，它就是 <code>easy-trans</code> 的手动翻译，可见 <a href="http://easy-trans.fhs-opensource.top/components/basic.html#_3%E3%80%81%E8%87%AA%E5%8A%A8%E7%BF%BB%E8%AF%91%E5%92%8C%E6%89%8B%E5%8A%A8%E7%BF%BB%E8%AF%91" target="_blank" rel="noopener noreferrer">《Trans 基础使用(必读)》的“3、自动翻译和手动翻译”</a></p><h3 id="_2-4-自动翻译的说明" tabindex="-1"><a class="header-anchor" href="#_2-4-自动翻译的说明"><span><a href="#_2-4-%E8%87%AA%E5%8A%A8%E7%BF%BB%E8%AF%91%E7%9A%84%E8%AF%B4%E6%98%8E">#</a> 2.4 自动翻译的说明</span></a></h3><p>① 默认情况下，所有 Spring MVC 接口的 RespVO 实现了 <code>com.fhs.core.trans.vo.VO</code> 接口，因为项目配置了 <code>easy-trans.is-enable-global</code> 为 <code>true</code> 启动全局翻译。</p><p>如果你希望某个接口不自动翻译，可以在方法上添加 <code>@TransIgnore</code> 注解。</p><p>友情提示：</p><p>如果一个 Spring MVC 接口的返回数据比较多，或者 RespVO 是个树形结构，建议添加 <code>@TransIgnore</code> 注解。<br> 原因是，<code>easy-trans</code> 全局有递归推断，在数据规模较大的情况下，可能会导致性能问题。</p><p>② 如果希望一个普通方法，也自动翻译，可以在方法上添加 <code>@TransMethodResult</code> 注解，框架会自动翻译方法 <code>return</code> 的值基于 Spring AOP 实现。例如说：</p><figure><img src="https://cloud.iocoder.cn/img/后端手册/VO/TransMethodResult.png" alt="@TransMethodResult" tabindex="0" loading="lazy"><figcaption>@TransMethodResult</figcaption></figure><p>友情提示：</p><p>对于 Spring Cloud 项目，因为 API 实现也是 Spring MVC 接口，所以上面这个示例，不添加 <code>@TransMethodResult</code> 注解，也会自动翻译。</p><p>如果你想尝试下，可以找个 Service 类，添加 <code>@TransMethodResult</code> 注解，看看效果。</p>',43))])}const f=n(p,[["render",u],["__file","vo.html.vue"]]),m=JSON.parse('{"path":"/project/yudao-cloud/vo.html","title":"VO 对象转换、数据翻译","lang":"en-US","frontmatter":{"title":"VO 对象转换、数据翻译","tags":["project","java","spring-boot","spring-cloud"],"categories":["project"],"order":33,"feed":false,"seo":false,"head":[]},"headers":[{"level":2,"title":"# 1. 对象转换","slug":"_1-对象转换","link":"#_1-对象转换","children":[{"level":3,"title":"# 1.1 MapStruct","slug":"_1-1-mapstruct","link":"#_1-1-mapstruct","children":[]},{"level":3,"title":"# 1.2 BeanUtils","slug":"_1-2-beanutils","link":"#_1-2-beanutils","children":[]}]},{"level":2,"title":"# 2. 数据翻译","slug":"_2-数据翻译","link":"#_2-数据翻译","children":[{"level":3,"title":"# 2.1 场景一：模块内翻译","slug":"_2-1-场景一-模块内翻译","link":"#_2-1-场景一-模块内翻译","children":[]},{"level":3,"title":"# 2.2 场景二：跨服务翻译","slug":"_2-2-场景二-跨服务翻译","link":"#_2-2-场景二-跨服务翻译","children":[]},{"level":3,"title":"# 2.3 场景三：Excel 导出翻译","slug":"_2-3-场景三-excel-导出翻译","link":"#_2-3-场景三-excel-导出翻译","children":[]},{"level":3,"title":"# 2.4 自动翻译的说明","slug":"_2-4-自动翻译的说明","link":"#_2-4-自动翻译的说明","children":[]}]}],"git":{"createdTime":1720365235000,"updatedTime":1720365235000,"contributors":[{"name":"Hung Nguyen Van","email":"vanhung4499@gmail.com","commits":1}]},"readingTime":{"minutes":6.64,"words":1992},"filePathRelative":"project/yudao-cloud/vo.md","localizedDate":"July 7, 2024"}');export{f as comp,m as data};
