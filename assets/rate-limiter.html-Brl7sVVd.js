import{_ as r,g as i,o as s,c as n,e as o,h as e,f as p,w as l,a}from"./app-BRTHG7K9.js";const c={},d=a(`<h1 id="请求限流-ratelimiter" tabindex="-1"><a class="header-anchor" href="#请求限流-ratelimiter"><span>请求限流（RateLimiter）</span></a></h1><p><a href="https://github.com/YunaiV/yudao-cloud/blob/master/yudao-framework/yudao-spring-boot-starter-protection/" target="_blank" rel="noopener noreferrer"><code>yudao-spring-boot-starter-protection</code></a> 技术组件，由它的 <a href="https://github.com/YunaiV/yudao-cloud/blob/master/yudao-framework/yudao-spring-boot-starter-protection/src/main/java/cn/iocoder/yudao/framework/ratelimiter/" target="_blank" rel="noopener noreferrer"><code>ratelimiter</code></a> 包，提供声明式的限流特性，可防止请求过多。例如说，用户疯狂的点击了某个按钮，导致发送了大量的请求。</p><div class="language-" data-ext="" data-title=""><pre class="shiki shiki-themes one-dark-pro one-dark-pro vp-code" style="background-color:#282c34;--shiki-dark-bg:#282c34;color:#abb2bf;--shiki-dark:#abb2bf;" tabindex="0"><code><span class="line"><span></span></span>
<span class="line"><span>@RateLimiter(count = 10, timeUnit = TimeUnit.MINUTES)</span></span>
<span class="line"><span>@PostMapping(&quot;/user/create&quot;)</span></span>
<span class="line"><span>public String createUser(User user){</span></span>
<span class="line"><span>    userService.createUser(user);</span></span>
<span class="line"><span>    return &quot;添加成功&quot;;</span></span>
<span class="line"><span>}</span></span></code></pre></div><ul><li>每分钟，所有用户，只能操作 10 次</li></ul><p>疑问：如果想按照每个用户，或者每个 IP，限制请求呢？</p><p>可设置该注解的 <code>keyResolver</code> 属性，可选择的有：</p><ul><li>DefaultRateLimiterKeyResolver：全局级别</li><li>UserRateLimiterKeyResolver：用户 ID 级别</li><li>ClientIpRateLimiterKeyResolver：用户 IP 级别</li><li>ServerNodeRateLimiterKeyResolver：服务器 Node 级别</li><li>ExpressionIdempotentKeyResolver：自定义级别，通过 <code>keyArg</code> 属性指定 Spring EL 表达式</li></ul><h2 id="_1-实现原理" tabindex="-1"><a class="header-anchor" href="#_1-实现原理"><span><a href="#_1-%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86">#</a> 1. 实现原理</span></a></h2><p>友情提示：</p>`,9),u=a(`<p>它的实现原理非常简单，针对相同参数的方法，一段时间内，只能执行一定次数。执行流程如下：</p><p>在方法执行前，判断参数对应的 Key 是否超过限制：</p><ul><li>如果<strong>超过</strong>，则进行报错。</li><li>如果<strong>未超过</strong>，则使用 Redis 计数 +1</li></ul><p>默认参数的 Redis Key 的计算规则由 <a href="https://github.com/YunaiV/yudao-cloud/blob/master/yudao-framework/yudao-spring-boot-starter-protection/src/main/java/cn/iocoder/yudao/framework/ratelimiter/core/keyresolver/impl/DefaultRateLimiterKeyResolver.java" target="_blank" rel="noopener noreferrer">DefaultRateLimiterKeyResolver</a> 实现，使用 MD5(方法名 + 方法参数)，避免 Redis Key 过长。</p><h2 id="_2-ratelimiter-注解" tabindex="-1"><a class="header-anchor" href="#_2-ratelimiter-注解"><span><a href="#_2-ratelimiter-%E6%B3%A8%E8%A7%A3">#</a> 2. <code>@RateLimiter</code> 注解</span></a></h2><p><a href="https://github.com/YunaiV/yudao-cloud/blob/master/yudao-framework/yudao-spring-boot-starter-protection/src/main/java/cn/iocoder/yudao/framework/ratelimiter/core/annotation/RateLimiter.java" target="_blank" rel="noopener noreferrer"><code>@RateLimiter</code></a> 注解，声明在方法上，表示该方法需要开启限流。代码如下：</p><figure><img src="https://cloud.iocoder.cn/img/后端手册/请求限流/注解.png" alt=" 注解" tabindex="0" loading="lazy"><figcaption> 注解</figcaption></figure><p>① 对应的 AOP 切面是 <a href="https://github.com/YunaiV/yudao-cloud/blob/master/yudao-framework/yudao-spring-boot-starter-protection/src/main/java/cn/iocoder/yudao/framework/ratelimiter/core/aop/RateLimiterAspect.java" target="_blank" rel="noopener noreferrer">RateLimiterAspect</a> 类，核心就 10 行左右的代码，如下图所示：</p><figure><img src="https://cloud.iocoder.cn/img/后端手册/请求限流/RateLimiterAspect.png" alt="RateLimiterAspect" tabindex="0" loading="lazy"><figcaption>RateLimiterAspect</figcaption></figure><p>② 对应的 Redis Key 的前缀是 <code>rate_limiter:%</code> ，可见 <a href="https://github.com/YunaiV/yudao-cloud/blob/master/yudao-framework/yudao-spring-boot-starter-protection/src/main/java/cn/iocoder/yudao/framework/ratelimiter/core/redis/RateLimiterRedisDAO.java" target="_blank" rel="noopener noreferrer">IdempotentRedisDAO</a> 类，如下图所示：</p><figure><img src="https://cloud.iocoder.cn/img/后端手册/请求限流/IdempotentRedisDAO.png" alt="IdempotentRedisDAO 存储" tabindex="0" loading="lazy"><figcaption>IdempotentRedisDAO 存储</figcaption></figure><h2 id="_3-使用示例" tabindex="-1"><a class="header-anchor" href="#_3-使用示例"><span><a href="#_3-%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B">#</a> 3. 使用示例</span></a></h2><p>本小节，我们实现 <code>/admin-api/system/user/page</code> RESTful API 接口的限流。</p><p>① 在 <code>pom.xml</code> 文件中，引入 <code>yudao-spring-boot-starter-protection</code> 依赖。</p><div class="language-" data-ext="" data-title=""><pre class="shiki shiki-themes one-dark-pro one-dark-pro vp-code" style="background-color:#282c34;--shiki-dark-bg:#282c34;color:#abb2bf;--shiki-dark:#abb2bf;" tabindex="0"><code><span class="line"><span>&lt;dependency&gt;</span></span>
<span class="line"><span>    &lt;groupId&gt;cn.iocoder.boot&lt;/groupId&gt;</span></span>
<span class="line"><span>    &lt;artifactId&gt;yudao-spring-boot-starter-protection&lt;/artifactId&gt;</span></span>
<span class="line"><span>&lt;/dependency&gt;</span></span></code></pre></div><p>② 在 <code>/admin-api/system/user/page</code> RESTful API 接口的对应方法上，添加 <code>@RateLimiter</code> 注解。代码如下：</p><div class="language-" data-ext="" data-title=""><pre class="shiki shiki-themes one-dark-pro one-dark-pro vp-code" style="background-color:#282c34;--shiki-dark-bg:#282c34;color:#abb2bf;--shiki-dark:#abb2bf;" tabindex="0"><code><span class="line"><span>// UserController.java</span></span>
<span class="line"><span></span></span>
<span class="line"><span>@GetMapping(&quot;/page&quot;)</span></span>
<span class="line"><span>@RateLimiter(count = 1, time = 60)</span></span>
<span class="line"><span>public CommonResult&lt;PageResult&lt;UserRespVO&gt;&gt; getUserPage(@Valid UserPageReqVO pageReqVO) {</span></span>
<span class="line"><span>    // ... 省略代码</span></span>
<span class="line"><span>}</span></span></code></pre></div><p>③ 调用该 API 接口，执行成功。</p><figure><img src="https://cloud.iocoder.cn/img/后端手册/请求限流/案例.png" alt="调用成功" tabindex="0" loading="lazy"><figcaption>调用成功</figcaption></figure><p>④ 再次调用该 API 接口，被限流拦截，执行失败。</p><div class="language-" data-ext="" data-title=""><pre class="shiki shiki-themes one-dark-pro one-dark-pro vp-code" style="background-color:#282c34;--shiki-dark-bg:#282c34;color:#abb2bf;--shiki-dark:#abb2bf;" tabindex="0"><code><span class="line"><span>{</span></span>
<span class="line"><span>  &quot;code&quot;: 429,</span></span>
<span class="line"><span>  &quot;data&quot;: null,</span></span>
<span class="line"><span>  &quot;msg&quot;: &quot;请求过于频繁，请稍后重试&quot;</span></span>
<span class="line"><span>}</span></span></code></pre></div>`,21);function m(g,b){const t=i("RouteLink");return s(),n("div",null,[d,o("p",null,[e("它的实现原理，和 "),p(t,{to:"/idempotent/"},{default:l(()=>[e("《幂等性（防重复提交）》")]),_:1}),e(" 比较接近哈。")]),u])}const f=r(c,[["render",m],["__file","rate-limiter.html.vue"]]),k=JSON.parse('{"path":"/project/yudao-cloud/rate-limiter.html","title":"请求限流（RateLimiter）","lang":"en-US","frontmatter":{"title":"请求限流（RateLimiter）","tags":["project","java","spring-boot","spring-cloud"],"categories":["project"],"order":45,"feed":false,"seo":false,"head":[]},"headers":[{"level":2,"title":"# 1. 实现原理","slug":"_1-实现原理","link":"#_1-实现原理","children":[]},{"level":2,"title":"# 2. @RateLimiter 注解","slug":"_2-ratelimiter-注解","link":"#_2-ratelimiter-注解","children":[]},{"level":2,"title":"# 3. 使用示例","slug":"_3-使用示例","link":"#_3-使用示例","children":[]}],"git":{"createdTime":1720365235000,"updatedTime":1720365235000,"contributors":[{"name":"Hung Nguyen Van","email":"vanhung4499@gmail.com","commits":1}]},"readingTime":{"minutes":2.41,"words":723},"filePathRelative":"project/yudao-cloud/rate-limiter.md","localizedDate":"July 7, 2024"}');export{f as comp,k as data};
