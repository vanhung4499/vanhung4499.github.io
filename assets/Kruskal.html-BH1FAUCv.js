import{_ as t,o as i,c as l,d as a,a as n,e as s}from"./app-5bcKoFfw.js";const e={},c=a('<h2 id="_1-gioi-thieu-thuat-toan-kruskal" tabindex="-1"><a class="header-anchor" href="#_1-gioi-thieu-thuat-toan-kruskal"><span>1. Giới thiệu thuật toán Kruskal</span></a></h2><blockquote><p><strong>Thuật toán Kruskal</strong> ra đời năm 1956, bởi Joseph Kruskal, là một thuật toán để tìm <strong>cây khung nhỏ nhất</strong> của một <strong>đồ thị liên thông vô hướng có trọng số</strong>. Thuật toán này tìm một tập hợp các cạnh tạo thành một cây khung chứa tất cả các đỉnh của đồ thị và có tổng trọng số các cạnh là nhỏ nhất. Thuật toán Kruskal sử dụng ý tưởng tham lam.</p></blockquote><p>Nhắc lại khái niệm &quot;cây khung nhỏ nhất&quot; trong đồ thị là tập hợp các cạnh (gọi tắt là <strong>MST</strong>, viết tắt của &quot;Minimum Spanning Tree&quot;) trong đó chúng ta đảm bảo các cạnh sau:</p>',3),h=n("ol",null,[n("li",null,[s("Bao gồm tất cả các đỉnh trong đồ thị (gồm "),n("span",{class:"katex"},[n("span",{class:"katex-mathml"},[n("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[n("semantics",null,[n("mrow",null,[n("mi",null,"n")]),n("annotation",{encoding:"application/x-tex"},"n")])])]),n("span",{class:"katex-html","aria-hidden":"true"},[n("span",{class:"base"},[n("span",{class:"strut",style:{height:"0.4306em"}}),n("span",{class:"mord mathnormal"},"n")])])]),s(" đỉnh).")]),n("li",null,[s("Tạo thành một cấu trúc cây (tức không có chu trình) (gồm "),n("span",{class:"katex"},[n("span",{class:"katex-mathml"},[n("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[n("semantics",null,[n("mrow",null,[n("mi",null,"n"),n("mo",null,"−"),n("mn",null,"1")]),n("annotation",{encoding:"application/x-tex"},"n - 1")])])]),n("span",{class:"katex-html","aria-hidden":"true"},[n("span",{class:"base"},[n("span",{class:"strut",style:{height:"0.6667em","vertical-align":"-0.0833em"}}),n("span",{class:"mord mathnormal"},"n"),n("span",{class:"mspace",style:{"margin-right":"0.2222em"}}),n("span",{class:"mbin"},"−"),n("span",{class:"mspace",style:{"margin-right":"0.2222em"}})]),n("span",{class:"base"},[n("span",{class:"strut",style:{height:"0.6444em"}}),n("span",{class:"mord"},"1")])])]),s(" cạnh).")]),n("li",null,"Có tổng trọng số nhỏ nhất.")],-1),r=a('<p>Đối với hai điều kiện đầu, chúng ta có thể giải quyết dễ dàng bằng cấu trúc <strong>[[Disjoint Set Union|Union-Find]]</strong> . Nếu bạn chưa biết về Union-Find hay Disjoint Set hay DSU vui lòng đọc bài viết về cấu trúc [[Disjoint Set Union]] trước.</p><p>Vấn đề quan trọng nằm ở điểm thứ ba, làm thế nào để đảm bảo rằng chúng ta nhận được một cây khung nhỏ nhất.</p><p>Ở đây, chúng ta sử dụng cách tiếp cận tham lam:</p><p>Sắp xếp tất cả các cạnh theo trọng số từ nhỏ đến lớn, bắt đầu từ cạnh có trọng số nhỏ nhất, nếu cạnh này không tạo thành chu trình với các cạnh khác trong <strong>MST</strong>, thì nó là một phần của cây khung nhỏ nhất và được thêm vào tập hợp <strong>MST</strong>. Nếu không, cạnh này không phải là một phần của cây khung nhỏ nhất và không được thêm vào tập hợp <strong>MST</strong>.</p><p>Như vậy, tập hợp các cạnh trong MST cuối cùng sẽ tạo thành cây khung nhỏ nhất. Bây giờ chúng ta hãy xem triển khai thuật toán Kruskal.</p><h2 id="_2-trien-khai-thuat-toan-kruskal" tabindex="-1"><a class="header-anchor" href="#_2-trien-khai-thuat-toan-kruskal"><span>2. Triển khai thuật toán Kruskal</span></a></h2><h3 id="_2-1-cac-buoc-trien-khai" tabindex="-1"><a class="header-anchor" href="#_2-1-cac-buoc-trien-khai"><span>2.1 Các bước triển khai</span></a></h3>',7),o=n("p",null,[s("Tiếp theo ta sẽ xem các bước triển khai thuật toán Kruskal trên một đồ thị liên thông vô hướng có trọng số với "),n("span",{class:"katex"},[n("span",{class:"katex-mathml"},[n("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[n("semantics",null,[n("mrow",null,[n("mi",null,"n")]),n("annotation",{encoding:"application/x-tex"},"n")])])]),n("span",{class:"katex-html","aria-hidden":"true"},[n("span",{class:"base"},[n("span",{class:"strut",style:{height:"0.4306em"}}),n("span",{class:"mord mathnormal"},"n")])])]),s(" đỉnh và "),n("span",{class:"katex"},[n("span",{class:"katex-mathml"},[n("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[n("semantics",null,[n("mrow",null,[n("mi",null,"m")]),n("annotation",{encoding:"application/x-tex"},"m")])])]),n("span",{class:"katex-html","aria-hidden":"true"},[n("span",{class:"base"},[n("span",{class:"strut",style:{height:"0.4306em"}}),n("span",{class:"mord mathnormal"},"m")])])]),s(" cạnh.")],-1),p=n("ol",null,[n("li",null,[s("Sắp xếp các cạnh theo trọng số từ nhỏ tới lớn. "),n("ul",null,[n("li",null,"Có thể dùng bất cứ thuật toán sắp xếp nào nhưng để tối ưu thì phải dùng các thuật toán sắp xếp tối ưu thời gian như Quick Sort, Merge Sort. Nhưng đa số thì chúng ta sẽ dùng luôn thư viện trong các ngôn ngữ để sắp xếp cho đỡ mất thời gian code.")])]),n("li",null,[s("Khởi tạo cấu trúc Union-Find để xác định tập hợp của "),n("span",{class:"katex"},[n("span",{class:"katex-mathml"},[n("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[n("semantics",null,[n("mrow",null,[n("mi",null,"n")]),n("annotation",{encoding:"application/x-tex"},"n")])])]),n("span",{class:"katex-html","aria-hidden":"true"},[n("span",{class:"base"},[n("span",{class:"strut",style:{height:"0.4306em"}}),n("span",{class:"mord mathnormal"},"n")])])]),s(" đỉnh và khởi tạo thêm một mảng kết quả "),n("code",null,"mst"),s(" chứa các cạnh")]),n("li",null,[s("Duyệt tập cạnh đã sắp xếp và để xây dựng cây khung: "),n("ul",null,[n("li",null,[s("Với mỗi cạnh "),n("span",{class:"katex"},[n("span",{class:"katex-mathml"},[n("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[n("semantics",null,[n("mrow",null,[n("mo",{stretchy:"false"},"("),n("mi",null,"u"),n("mo",{separator:"true"},","),n("mi",null,"v"),n("mo",{stretchy:"false"},")")]),n("annotation",{encoding:"application/x-tex"},"(u, v)")])])]),n("span",{class:"katex-html","aria-hidden":"true"},[n("span",{class:"base"},[n("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),n("span",{class:"mopen"},"("),n("span",{class:"mord mathnormal"},"u"),n("span",{class:"mpunct"},","),n("span",{class:"mspace",style:{"margin-right":"0.1667em"}}),n("span",{class:"mord mathnormal",style:{"margin-right":"0.03588em"}},"v"),n("span",{class:"mclose"},")")])])]),s(", kiểm tra xem hai đỉnh "),n("span",{class:"katex"},[n("span",{class:"katex-mathml"},[n("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[n("semantics",null,[n("mrow",null,[n("mi",null,"u")]),n("annotation",{encoding:"application/x-tex"},"u")])])]),n("span",{class:"katex-html","aria-hidden":"true"},[n("span",{class:"base"},[n("span",{class:"strut",style:{height:"0.4306em"}}),n("span",{class:"mord mathnormal"},"u")])])]),s(" và "),n("span",{class:"katex"},[n("span",{class:"katex-mathml"},[n("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[n("semantics",null,[n("mrow",null,[n("mi",null,"v")]),n("annotation",{encoding:"application/x-tex"},"v")])])]),n("span",{class:"katex-html","aria-hidden":"true"},[n("span",{class:"base"},[n("span",{class:"strut",style:{height:"0.4306em"}}),n("span",{class:"mord mathnormal",style:{"margin-right":"0.03588em"}},"v")])])]),s(" có cùng thuộc một tập hợp chưa? "),n("ul",null,[n("li",null,[s("Nếu không trùng, thêm cạnh vào cây khung tức là "),n("code",null,"mst"),s(" và hợp nhất 2 tập hợp của 2 đỉnh.")]),n("li",null,"Nếu trùng, chúng đã nằm trong cây khung, bỏ qua và tiếp tục duyệt")])])])]),n("li",null,[s("Quá trình kết thúc khi đã tìm đủ "),n("span",{class:"katex"},[n("span",{class:"katex-mathml"},[n("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[n("semantics",null,[n("mrow",null,[n("mi",null,"n"),n("mo",null,"−"),n("mn",null,"1")]),n("annotation",{encoding:"application/x-tex"},"n - 1")])])]),n("span",{class:"katex-html","aria-hidden":"true"},[n("span",{class:"base"},[n("span",{class:"strut",style:{height:"0.6667em","vertical-align":"-0.0833em"}}),n("span",{class:"mord mathnormal"},"n"),n("span",{class:"mspace",style:{"margin-right":"0.2222em"}}),n("span",{class:"mbin"},"−"),n("span",{class:"mspace",style:{"margin-right":"0.2222em"}})]),n("span",{class:"base"},[n("span",{class:"strut",style:{height:"0.6444em"}}),n("span",{class:"mord"},"1")])])]),s(" cạnh tức là "),n("code",null,"len(mst) == n - 1"),s(" thì dừng lại.")])],-1),k=a(`<h3 id="_2-2-code-trien-khai" tabindex="-1"><a class="header-anchor" href="#_2-2-code-trien-khai"><span>2.2 Code triển khai</span></a></h3><div class="language-python line-numbers-mode" data-ext="python" data-title="python"><pre class="shiki shiki-themes one-dark-pro one-dark-pro vp-code" style="background-color:#282c34;--shiki-dark-bg:#282c34;color:#abb2bf;--shiki-dark:#abb2bf;" tabindex="0"><code><span class="line"><span style="color:#7F848E;--shiki-dark:#7F848E;font-style:italic;--shiki-dark-font-style:italic;"># Hàm triển khai thuật toán kruskal</span></span>
<span class="line"><span style="color:#7F848E;--shiki-dark:#7F848E;font-style:italic;--shiki-dark-font-style:italic;"># Đồ thị bao gốm số đỉnh là n và tập cạnh là edges có trọng số</span></span>
<span class="line"><span style="color:#C678DD;--shiki-dark:#C678DD;">def</span><span style="color:#61AFEF;--shiki-dark:#61AFEF;"> kruskal</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">(</span><span style="color:#D19A66;--shiki-dark:#D19A66;font-style:italic;--shiki-dark-font-style:italic;">n</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">: </span><span style="color:#56B6C2;--shiki-dark:#56B6C2;">int</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">, </span><span style="color:#D19A66;--shiki-dark:#D19A66;font-style:italic;--shiki-dark-font-style:italic;">edges</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">: List[Tuple[</span><span style="color:#56B6C2;--shiki-dark:#56B6C2;">int</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">, </span><span style="color:#56B6C2;--shiki-dark:#56B6C2;">int</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">, </span><span style="color:#56B6C2;--shiki-dark:#56B6C2;">int</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">]]) -&gt; </span><span style="color:#56B6C2;--shiki-dark:#56B6C2;">int</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">:</span></span>
<span class="line"><span style="color:#7F848E;--shiki-dark:#7F848E;font-style:italic;--shiki-dark-font-style:italic;">    # Sắp xếp tập cạnh theo trọng số</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">    edges </span><span style="color:#56B6C2;--shiki-dark:#56B6C2;">=</span><span style="color:#56B6C2;--shiki-dark:#56B6C2;"> sorted</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">(edges, </span><span style="color:#E06C75;--shiki-dark:#E06C75;font-style:italic;--shiki-dark-font-style:italic;">key</span><span style="color:#56B6C2;--shiki-dark:#56B6C2;">=</span><span style="color:#C678DD;--shiki-dark:#C678DD;">lambda</span><span style="color:#D19A66;--shiki-dark:#D19A66;font-style:italic;--shiki-dark-font-style:italic;"> edge</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">: edge[</span><span style="color:#D19A66;--shiki-dark:#D19A66;">2</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">])</span></span>
<span class="line"><span style="color:#7F848E;--shiki-dark:#7F848E;font-style:italic;--shiki-dark-font-style:italic;">    # Triển khai Union-Find</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">    parent </span><span style="color:#56B6C2;--shiki-dark:#56B6C2;">=</span><span style="color:#56B6C2;--shiki-dark:#56B6C2;"> list</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">(</span><span style="color:#56B6C2;--shiki-dark:#56B6C2;">range</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">(n))</span></span>
<span class="line"></span>
<span class="line"><span style="color:#7F848E;--shiki-dark:#7F848E;font-style:italic;--shiki-dark-font-style:italic;">    # Union-Find: hàm nén đường dẫn</span></span>
<span class="line"><span style="color:#C678DD;--shiki-dark:#C678DD;">    def</span><span style="color:#61AFEF;--shiki-dark:#61AFEF;"> find_parent</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">(</span><span style="color:#D19A66;--shiki-dark:#D19A66;font-style:italic;--shiki-dark-font-style:italic;">i</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">):</span></span>
<span class="line"><span style="color:#C678DD;--shiki-dark:#C678DD;">        if</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;"> i </span><span style="color:#56B6C2;--shiki-dark:#56B6C2;">!=</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;"> parent[i]:</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">            parent[i] </span><span style="color:#56B6C2;--shiki-dark:#56B6C2;">=</span><span style="color:#61AFEF;--shiki-dark:#61AFEF;"> find_parent</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">(parent[i])</span></span>
<span class="line"><span style="color:#C678DD;--shiki-dark:#C678DD;">        return</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;"> parent[i]</span></span>
<span class="line"><span style="color:#7F848E;--shiki-dark:#7F848E;font-style:italic;--shiki-dark-font-style:italic;">    # Lưu trữ tập cạnh và giá trị cây khung nhỏ nhất</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">    mst_cost </span><span style="color:#56B6C2;--shiki-dark:#56B6C2;">=</span><span style="color:#D19A66;--shiki-dark:#D19A66;"> 0</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">    mst </span><span style="color:#56B6C2;--shiki-dark:#56B6C2;">=</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;"> []</span></span>
<span class="line"><span style="color:#7F848E;--shiki-dark:#7F848E;font-style:italic;--shiki-dark-font-style:italic;">    # Duyệt tập cạnh</span></span>
<span class="line"><span style="color:#C678DD;--shiki-dark:#C678DD;">    for</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;"> edge </span><span style="color:#C678DD;--shiki-dark:#C678DD;">in</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;"> edges:</span></span>
<span class="line"><span style="color:#7F848E;--shiki-dark:#7F848E;font-style:italic;--shiki-dark-font-style:italic;">        # Tìm tập cha của hai nút</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">        parent_u </span><span style="color:#56B6C2;--shiki-dark:#56B6C2;">=</span><span style="color:#61AFEF;--shiki-dark:#61AFEF;"> find_parent</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">(edge[</span><span style="color:#D19A66;--shiki-dark:#D19A66;">0</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">])</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">        parent_v </span><span style="color:#56B6C2;--shiki-dark:#56B6C2;">=</span><span style="color:#61AFEF;--shiki-dark:#61AFEF;"> find_parent</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">(edge[</span><span style="color:#D19A66;--shiki-dark:#D19A66;">1</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">])</span></span>
<span class="line"><span style="color:#7F848E;--shiki-dark:#7F848E;font-style:italic;--shiki-dark-font-style:italic;">        # Nếu không cùng chung tập hợp</span></span>
<span class="line"><span style="color:#C678DD;--shiki-dark:#C678DD;">        if</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;"> parent_u </span><span style="color:#56B6C2;--shiki-dark:#56B6C2;">!=</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;"> parent_v:</span></span>
<span class="line"><span style="color:#7F848E;--shiki-dark:#7F848E;font-style:italic;--shiki-dark-font-style:italic;">            # Thêm cạnh và giá trị vào cây </span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">            mst_cost </span><span style="color:#56B6C2;--shiki-dark:#56B6C2;">+=</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;"> edge[</span><span style="color:#D19A66;--shiki-dark:#D19A66;">2</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">]</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">            mst.</span><span style="color:#61AFEF;--shiki-dark:#61AFEF;">append</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">(edge)</span></span>
<span class="line"><span style="color:#7F848E;--shiki-dark:#7F848E;font-style:italic;--shiki-dark-font-style:italic;">            # Hợp nhất hai tập</span></span>
<span class="line"><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;">            parent[parent_u] </span><span style="color:#56B6C2;--shiki-dark:#56B6C2;">=</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;"> parent_v</span></span>
<span class="line"><span style="color:#7F848E;--shiki-dark:#7F848E;font-style:italic;--shiki-dark-font-style:italic;">    # Trả về kết quả </span></span>
<span class="line"><span style="color:#C678DD;--shiki-dark:#C678DD;">    return</span><span style="color:#ABB2BF;--shiki-dark:#ABB2BF;"> mst</span></span></code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_2-3-phan-tich-thuat-toan-kruskal" tabindex="-1"><a class="header-anchor" href="#_2-3-phan-tich-thuat-toan-kruskal"><span>2.3 Phân tích thuật toán Kruskal</span></a></h3><p>Giả sử rằng số nút trong đồ thị là <code>V</code>, và số cạnh là <code>E</code>. Đầu tiên, không gian cần thiết để giữ tất cả các cạnh là <code>O(E)</code>, và cấu trúc Union-Find cũng yêu cầu <code>O(V)</code>. Vì vậy tổng độ phức tạp không gian của thuật toán Kruskal là <code>O(V + E)</code>.</p><p>Độ phức tạp về thời gian chủ yếu dành cho việc sắp xếp <code>O(ElogE)</code>. Thời gian cần thiết cho tất cả các hoạt động của thuật toán Union-Find chỉ là <code>O(1)</code> và vòng lặp for chỉ là <code>O(E)</code>, do đó tổng độ phức tạp về thời gian là <code>O(ElogE)</code>.</p><h2 id="_3-ung-dung-thuat-toan-kruskal" tabindex="-1"><a class="header-anchor" href="#_3-ung-dung-thuat-toan-kruskal"><span>3. Ứng dụng thuật toán Kruskal</span></a></h2><p>Sau đây ta sẽ áp dụng thuật toán kruskal vào giải một số bài trên leetcode.</p>`,7),d=[c,h,r,o,p,k];function u(m,B){return i(),l("div",null,d)}const y=t(e,[["render",u],["__file","Kruskal.html.vue"]]),F=JSON.parse('{"path":"/dsa/algo/graph/mst/Kruskal.html","title":"Kruskal","lang":"en-US","frontmatter":{"title":"Kruskal","order":2,"tags":["algorithm"],"categories":["algorithm"],"description":"1. Giới thiệu thuật toán Kruskal Thuật toán Kruskal ra đời năm 1956, bởi Joseph Kruskal, là một thuật toán để tìm cây khung nhỏ nhất của một đồ thị liên thông vô hướng có trọng ...","head":[["meta",{"property":"og:url","content":"https://vanhung4499.github.io/dsa/algo/graph/mst/Kruskal.html"}],["meta",{"property":"og:site_name","content":"VanHung4499"}],["meta",{"property":"og:title","content":"Kruskal"}],["meta",{"property":"og:description","content":"1. Giới thiệu thuật toán Kruskal Thuật toán Kruskal ra đời năm 1956, bởi Joseph Kruskal, là một thuật toán để tìm cây khung nhỏ nhất của một đồ thị liên thông vô hướng có trọng ..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"en-US"}],["meta",{"property":"og:updated_time","content":"2024-06-28T15:54:38.000Z"}],["meta",{"property":"article:author","content":"Hung Nguyen"}],["meta",{"property":"article:tag","content":"algorithm"}],["meta",{"property":"article:modified_time","content":"2024-06-28T15:54:38.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Kruskal\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2024-06-28T15:54:38.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Hung Nguyen\\",\\"url\\":\\"https://vanhung4499.github.io\\"}]}"]]},"headers":[{"level":2,"title":"1. Giới thiệu thuật toán Kruskal","slug":"_1-gioi-thieu-thuat-toan-kruskal","link":"#_1-gioi-thieu-thuat-toan-kruskal","children":[]},{"level":2,"title":"2. Triển khai thuật toán Kruskal","slug":"_2-trien-khai-thuat-toan-kruskal","link":"#_2-trien-khai-thuat-toan-kruskal","children":[{"level":3,"title":"2.1 Các bước triển khai","slug":"_2-1-cac-buoc-trien-khai","link":"#_2-1-cac-buoc-trien-khai","children":[]},{"level":3,"title":"2.2 Code triển khai","slug":"_2-2-code-trien-khai","link":"#_2-2-code-trien-khai","children":[]},{"level":3,"title":"2.3 Phân tích thuật toán Kruskal","slug":"_2-3-phan-tich-thuat-toan-kruskal","link":"#_2-3-phan-tich-thuat-toan-kruskal","children":[]}]},{"level":2,"title":"3. Ứng dụng thuật toán Kruskal","slug":"_3-ung-dung-thuat-toan-kruskal","link":"#_3-ung-dung-thuat-toan-kruskal","children":[]}],"git":{"createdTime":1719590078000,"updatedTime":1719590078000,"contributors":[{"name":"Hung Nguyen Van","email":"vanhung4499@gmail.com","commits":1}]},"readingTime":{"minutes":3.85,"words":1154},"filePathRelative":"dsa/algo/graph/mst/Kruskal.md","localizedDate":"June 28, 2024","excerpt":"<h2>1. Giới thiệu thuật toán Kruskal</h2>\\n<blockquote>\\n<p><strong>Thuật toán Kruskal</strong>&nbsp;ra đời năm 1956, bởi&nbsp;Joseph Kruskal, là một&nbsp;thuật toán để tìm&nbsp;<strong>cây khung nhỏ nhất</strong>&nbsp;của một&nbsp;<strong>đồ thị liên thông&nbsp;vô hướng có trọng số</strong>. Thuật toán này tìm một tập hợp các&nbsp;cạnh&nbsp;tạo thành một cây khung chứa tất cả các&nbsp;đỉnh&nbsp;của đồ thị và có tổng trọng số các cạnh là nhỏ nhất. Thuật toán Kruskal sử dụng ý tưởng tham lam.</p>\\n</blockquote>","autoDesc":true}');export{y as comp,F as data};
