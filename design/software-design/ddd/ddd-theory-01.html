<!doctype html>
<html lang="en-US" data-theme="light">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <meta name="generator" content="VuePress 2.0.0-rc.15" />
    <meta name="theme" content="VuePress Theme Hope 2.0.0-rc.52" />
    <style>
      html {
        background: var(--bg-color, #fff);
      }

      html[data-theme="dark"] {
        background: var(--bg-color, #1d1e1f);
      }

      body {
        background: var(--bg-color);
      }
    </style>
    <script>
      const userMode = localStorage.getItem("vuepress-theme-hope-scheme");
      const systemDarkMode =
        window.matchMedia &&
        window.matchMedia("(prefers-color-scheme: dark)").matches;

      if (userMode === "dark" || (userMode !== "light" && systemDarkMode)) {
        document.documentElement.setAttribute("data-theme", "dark");
      }
    </script>
    <meta property="og:url" content="https://vanhung4499.github.io/design/software-design/ddd/ddd-theory-01.html"><meta property="og:site_name" content="VanHung4499"><meta property="og:title" content="DDD Theory 01"><meta property="og:description" content="Lý thuyết về DDD 01 - Tổng quan 0. Tổng quan DDD là gì? Đây là câu hỏi đầu tiên mà mọi nhà phát triển muốn sử dụng DDD cho dự án của mình gặp phải. Chỉ khi hiểu rõ DDD là gì thì..."><meta property="og:type" content="article"><meta property="og:image" content="https://article-images.zsxq.com/FsvPPZ3Fw8G0As-Y0Q5pLNn5Dtvs"><meta property="og:locale" content="en-US"><meta property="og:updated_time" content="2024-10-02T17:20:50.000Z"><meta property="article:author" content="Hung Nguyen"><meta property="article:tag" content="design"><meta property="article:tag" content="ddd"><meta property="article:modified_time" content="2024-10-02T17:20:50.000Z"><script type="application/ld+json">{"@context":"https://schema.org","@type":"Article","headline":"DDD Theory 01","image":["https://article-images.zsxq.com/FsvPPZ3Fw8G0As-Y0Q5pLNn5Dtvs","https://article-images.zsxq.com/Fq_zNTXR5LyQnDVs7XwpvzY12O47","https://article-images.zsxq.com/Fj5_7DDMhzbwodONmAab8kkmbp6f","https://article-images.zsxq.com/FvLgpxTQ7zUfH-3FT4PA77wOfalR"],"dateModified":"2024-10-02T17:20:50.000Z","author":[{"@type":"Person","name":"Hung Nguyen","url":"https://vanhung4499.github.io"}]}</script><meta name="referrer" content="no-referrer-when-downgrade"><link rel="alternate" type="application/rss+xml" href="https://vanhung4499.github.io/rss.xml" title="VanHung4499 RSS Feed"><title>DDD Theory 01 | VanHung4499</title><meta name="description" content="Lý thuyết về DDD 01 - Tổng quan 0. Tổng quan DDD là gì? Đây là câu hỏi đầu tiên mà mọi nhà phát triển muốn sử dụng DDD cho dự án của mình gặp phải. Chỉ khi hiểu rõ DDD là gì thì...">
    <link rel="preload" href="/assets/style-DFXXOFfS.css" as="style"><link rel="stylesheet" href="/assets/style-DFXXOFfS.css">
    <link rel="modulepreload" href="/assets/app-5QVbWi7Z.js"><link rel="modulepreload" href="/assets/ddd-theory-01.html-0nQJke2p.js">
    
  </head>
  <body>
    <div id="app"><!--[--><!--[--><!--[--><span tabindex="-1"></span><a href="#main-content" class="vp-skip-link sr-only">Skip to main content</a><!--]--><div class="theme-container no-sidebar external-link-icon has-toc"><!--[--><header id="navbar" class="vp-navbar"><div class="vp-navbar-start"><button type="button" class="vp-toggle-sidebar-button" title="Toggle Sidebar"><span class="icon"></span></button><!----><!--[--><a class="route-link vp-brand" href="/"><img class="vp-nav-logo" src="/logo.svg" alt><!----><span class="vp-site-name hide-in-pad">VanHung4499</span></a><!--]--><!----></div><div class="vp-navbar-center"><!----><!--[--><nav class="vp-nav-links"><div class="vp-nav-item hide-in-mobile"><a class="route-link auto-link" href="/" aria-label="Home"><!--[--><iconify-icon class="font-icon icon" style="" mode="style" inline icon="mdi:home" width="1em" height="1em"></iconify-icon><!--]-->Home<!----></a></div><div class="vp-nav-item hide-in-mobile"><a class="route-link auto-link" href="/wiki.html" aria-label="Wiki"><!--[--><iconify-icon class="font-icon icon" style="" mode="style" inline icon="carbon:wikis" width="1em" height="1em"></iconify-icon><!--]-->Wiki<!----></a></div><div class="vp-nav-item hide-in-mobile"><a class="route-link auto-link" href="/dsa/" aria-label="Algorithms"><!--[--><iconify-icon class="font-icon icon" style="" mode="style" inline icon="hugeicons:algorithm" width="1em" height="1em"></iconify-icon><!--]-->Algorithms<!----></a></div><div class="vp-nav-item hide-in-mobile"><div class="vp-dropdown-wrapper"><button type="button" class="vp-dropdown-title" aria-label="Programming"><!--[--><iconify-icon class="font-icon icon" style="" mode="style" inline icon="mdi:code" width="1em" height="1em"></iconify-icon>Programming<!--]--><span class="arrow"></span><ul class="vp-dropdown"><li class="vp-dropdown-item"><a class="route-link auto-link" href="/programming/java/" aria-label="Java"><!--[--><iconify-icon class="font-icon icon" style="" mode="style" inline icon="devicon:java" width="1em" height="1em"></iconify-icon><!--]-->Java<!----></a></li><li class="vp-dropdown-item"><a class="route-link auto-link" href="/programming/golang/" aria-label="Golang"><!--[--><iconify-icon class="font-icon icon" style="" mode="style" inline icon="devicon:go" width="1em" height="1em"></iconify-icon><!--]-->Golang<!----></a></li><li class="vp-dropdown-item"><a class="route-link auto-link" href="/programming/js/" aria-label="JavaScript"><!--[--><iconify-icon class="font-icon icon" style="" mode="style" inline icon="devicon:javascript" width="1em" height="1em"></iconify-icon><!--]-->JavaScript<!----></a></li><li class="vp-dropdown-item"><a class="route-link auto-link" href="/programming/ts/" aria-label="TypeScript"><!--[--><iconify-icon class="font-icon icon" style="" mode="style" inline icon="devicon:typescript" width="1em" height="1em"></iconify-icon><!--]-->TypeScript<!----></a></li><li class="vp-dropdown-item"><a class="route-link auto-link" href="/programming/python/" aria-label="Python"><!--[--><iconify-icon class="font-icon icon" style="" mode="style" inline icon="devicon:python" width="1em" height="1em"></iconify-icon><!--]-->Python<!----></a></li></ul></button></div></div><div class="vp-nav-item hide-in-mobile"><div class="vp-dropdown-wrapper"><button type="button" class="vp-dropdown-title" aria-label="Database"><!--[--><iconify-icon class="font-icon icon" style="" mode="style" inline icon="mdi:database" width="1em" height="1em"></iconify-icon>Database<!--]--><span class="arrow"></span><ul class="vp-dropdown"><li class="vp-dropdown-item"><a class="route-link auto-link" href="/database/sql/" aria-label="SQL"><!--[--><iconify-icon class="font-icon icon" style="" mode="style" inline icon="mdi:sql-query" width="1em" height="1em"></iconify-icon><!--]-->SQL<!----></a></li><li class="vp-dropdown-item"><a class="route-link auto-link" href="/database/mysql/" aria-label="MySQL"><!--[--><iconify-icon class="font-icon icon" style="" mode="style" inline icon="devicon:mysql" width="1em" height="1em"></iconify-icon><!--]-->MySQL<!----></a></li><li class="vp-dropdown-item"><a class="route-link auto-link" href="/database/mongodb/" aria-label="MongoDB"><!--[--><iconify-icon class="font-icon icon" style="" mode="style" inline icon="devicon:mongodb" width="1em" height="1em"></iconify-icon><!--]-->MongoDB<!----></a></li><li class="vp-dropdown-item"><a class="route-link auto-link" href="/database/redis/" aria-label="Redis"><!--[--><iconify-icon class="font-icon icon" style="" mode="style" inline icon="devicon:redis" width="1em" height="1em"></iconify-icon><!--]-->Redis<!----></a></li><li class="vp-dropdown-item"><a class="route-link auto-link" href="/database/elasticsearch/" aria-label="Elasticsearch"><!--[--><iconify-icon class="font-icon icon" style="" mode="style" inline icon="devicon:elasticsearch" width="1em" height="1em"></iconify-icon><!--]-->Elasticsearch<!----></a></li><li class="vp-dropdown-item"><a class="route-link auto-link" href="/database/elastic/" aria-label="Elastic Stack"><!--[--><iconify-icon class="font-icon icon" style="" mode="style" inline icon="cib:elastic-stack" width="1em" height="1em"></iconify-icon><!--]-->Elastic Stack<!----></a></li></ul></button></div></div><div class="vp-nav-item hide-in-mobile"><div class="vp-dropdown-wrapper"><button type="button" class="vp-dropdown-title" aria-label="Framework"><!--[--><iconify-icon class="font-icon icon" style="" mode="style" inline icon="simple-icons:framework" width="1em" height="1em"></iconify-icon>Framework<!--]--><span class="arrow"></span><ul class="vp-dropdown"><li class="vp-dropdown-item"><a class="route-link auto-link" href="/framework/spring/" aria-label="Spring"><!--[--><iconify-icon class="font-icon icon" style="" mode="style" inline icon="devicon:spring" width="1em" height="1em"></iconify-icon><!--]-->Spring<!----></a></li><li class="vp-dropdown-item"><a class="route-link auto-link" href="/framework/spring-boot/" aria-label="Spring Boot"><!--[--><iconify-icon class="font-icon icon" style="" mode="style" inline icon="devicon:spring" width="1em" height="1em"></iconify-icon><!--]-->Spring Boot<!----></a></li><li class="vp-dropdown-item"><a class="route-link auto-link" href="/framework/nestjs/" aria-label="NestJS"><!--[--><iconify-icon class="font-icon icon" style="" mode="style" inline icon="devicon:nestjs" width="1em" height="1em"></iconify-icon><!--]-->NestJS<!----></a></li><li class="vp-dropdown-item"><a class="route-link auto-link" href="/framework/gin/" aria-label="Gin"><!--[--><iconify-icon class="font-icon icon" style="" mode="style" inline icon="logos:gin" width="1em" height="1em"></iconify-icon><!--]-->Gin<!----></a></li></ul></button></div></div><div class="vp-nav-item hide-in-mobile"><div class="vp-dropdown-wrapper"><button type="button" class="vp-dropdown-title" aria-label="DevOps"><!--[--><iconify-icon class="font-icon icon" style="" mode="style" inline icon="devicon-plain:azuredevops" width="1em" height="1em"></iconify-icon>DevOps<!--]--><span class="arrow"></span><ul class="vp-dropdown"><li class="vp-dropdown-item"><a class="route-link auto-link" href="/devops/docker/" aria-label="Docker"><!--[--><iconify-icon class="font-icon icon" style="" mode="style" inline icon="devicon:docker" width="1em" height="1em"></iconify-icon><!--]-->Docker<!----></a></li><li class="vp-dropdown-item"><a class="route-link auto-link" href="/devops/kubernetes/" aria-label="Kubernetes"><!--[--><iconify-icon class="font-icon icon" style="" mode="style" inline icon="devicon:kubernetes" width="1em" height="1em"></iconify-icon><!--]-->Kubernetes<!----></a></li><li class="vp-dropdown-item"><a class="route-link auto-link" href="/devops/jenkins/" aria-label="Jenkins"><!--[--><iconify-icon class="font-icon icon" style="" mode="style" inline icon="devicon:jenkins" width="1em" height="1em"></iconify-icon><!--]-->Jenkins<!----></a></li><li class="vp-dropdown-item"><a class="route-link auto-link" href="/devops/git/" aria-label="Git"><!--[--><iconify-icon class="font-icon icon" style="" mode="style" inline icon="devicon:git" width="1em" height="1em"></iconify-icon><!--]-->Git<!----></a></li><li class="vp-dropdown-item"><a class="route-link auto-link" href="/devops/linux/" aria-label="Linux"><!--[--><iconify-icon class="font-icon icon" style="" mode="style" inline icon="devicon:linux" width="1em" height="1em"></iconify-icon><!--]-->Linux<!----></a></li></ul></button></div></div><div class="vp-nav-item hide-in-mobile"><div class="vp-dropdown-wrapper"><button type="button" class="vp-dropdown-title" aria-label="Design"><!--[--><iconify-icon class="font-icon icon" style="" mode="style" inline icon="tdesign:system-sum" width="1em" height="1em"></iconify-icon>Design<!--]--><span class="arrow"></span><ul class="vp-dropdown"><li class="vp-dropdown-item"><a class="route-link auto-link" href="/design/design-pattern/" aria-label="Design Pattern"><!--[--><iconify-icon class="font-icon icon" style="" mode="style" inline icon="tabler:grid-pattern" width="1em" height="1em"></iconify-icon><!--]-->Design Pattern<!----></a></li><li class="vp-dropdown-item"><a class="route-link auto-link" href="/design/system-design/" aria-label="System Design"><!--[--><iconify-icon class="font-icon icon" style="" mode="style" inline icon="icon-park-outline:system" width="1em" height="1em"></iconify-icon><!--]-->System Design<!----></a></li></ul></button></div></div><div class="vp-nav-item hide-in-mobile"><div class="vp-dropdown-wrapper"><button type="button" class="vp-dropdown-title" aria-label="Project"><!--[--><iconify-icon class="font-icon icon" style="" mode="style" inline icon="ant-design:project-outlined" width="1em" height="1em"></iconify-icon>Project<!--]--><span class="arrow"></span><ul class="vp-dropdown"><li class="vp-dropdown-item"><a class="route-link auto-link" href="/project/rouyi-vue-pro/" aria-label="Rouyi Vue Pro"><!--[--><iconify-icon class="font-icon icon" style="" mode="style" inline icon="devicon:spring" width="1em" height="1em"></iconify-icon><!--]-->Rouyi Vue Pro<!----></a></li><li class="vp-dropdown-item"><a class="route-link auto-link" href="/project/yudao-cloud/" aria-label="Yudao Cloud"><!--[--><iconify-icon class="font-icon icon" style="" mode="style" inline icon="devicon:spring" width="1em" height="1em"></iconify-icon><!--]-->Yudao Cloud<!----></a></li></ul></button></div></div><div class="vp-nav-item hide-in-mobile"><a class="route-link auto-link" href="/interview/" aria-label="Interview"><!--[--><iconify-icon class="font-icon icon" style="" mode="style" inline icon="mdi:account-tie" width="1em" height="1em"></iconify-icon><!--]-->Interview<!----></a></div><div class="vp-nav-item hide-in-mobile"><div class="vp-dropdown-wrapper"><button type="button" class="vp-dropdown-title" aria-label="About"><!--[--><iconify-icon class="font-icon icon" style="" mode="style" inline icon="mdi:about" width="1em" height="1em"></iconify-icon>About<!--]--><span class="arrow"></span><ul class="vp-dropdown"><li class="vp-dropdown-item"><a class="route-link auto-link" href="/about-me.html" aria-label="About me"><!--[--><iconify-icon class="font-icon icon" style="" mode="style" inline icon="cib:about-me" width="1em" height="1em"></iconify-icon><!--]-->About me<!----></a></li><li class="vp-dropdown-item"><a class="route-link auto-link" href="/about.html" aria-label="About"><!--[--><iconify-icon class="font-icon icon" style="" mode="style" inline icon="mdi:about" width="1em" height="1em"></iconify-icon><!--]-->About<!----></a></li></ul></button></div></div></nav><!--]--><!----></div><div class="vp-navbar-end"><!----><!--[--><!----><div class="vp-nav-item vp-action"><a class="vp-action-link" href="https://github.com/vanhung4499/my-wiki" target="_blank" rel="noopener noreferrer" aria-label="GitHub"><svg xmlns="http://www.w3.org/2000/svg" class="icon github-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="github icon" name="github" style="width:1.25rem;height:1.25rem;vertical-align:middle;"><path d="M511.957 21.333C241.024 21.333 21.333 240.981 21.333 512c0 216.832 140.544 400.725 335.574 465.664 24.49 4.395 32.256-10.07 32.256-23.083 0-11.69.256-44.245 0-85.205-136.448 29.61-164.736-64.64-164.736-64.64-22.315-56.704-54.4-71.765-54.4-71.765-44.587-30.464 3.285-29.824 3.285-29.824 49.195 3.413 75.179 50.517 75.179 50.517 43.776 75.008 114.816 53.333 142.762 40.79 4.523-31.66 17.152-53.377 31.19-65.537-108.971-12.458-223.488-54.485-223.488-242.602 0-53.547 19.114-97.323 50.517-131.67-5.035-12.33-21.93-62.293 4.779-129.834 0 0 41.258-13.184 134.912 50.346a469.803 469.803 0 0 1 122.88-16.554c41.642.213 83.626 5.632 122.88 16.554 93.653-63.488 134.784-50.346 134.784-50.346 26.752 67.541 9.898 117.504 4.864 129.834 31.402 34.347 50.474 78.123 50.474 131.67 0 188.586-114.73 230.016-224.042 242.09 17.578 15.232 33.578 44.672 33.578 90.454v135.85c0 13.142 7.936 27.606 32.854 22.87C862.25 912.597 1002.667 728.747 1002.667 512c0-271.019-219.648-490.667-490.71-490.667z"></path></svg></a></div><div class="vp-nav-item hide-in-mobile"><button type="button" class="vp-outlook-button" tabindex="-1" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" class="icon outlook-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="outlook icon" name="outlook"><path d="M224 800c0 9.6 3.2 44.8 6.4 54.4 6.4 48-48 76.8-48 76.8s80 41.6 147.2 0 134.4-134.4 38.4-195.2c-22.4-12.8-41.6-19.2-57.6-19.2C259.2 716.8 227.2 761.6 224 800zM560 675.2l-32 51.2c-51.2 51.2-83.2 32-83.2 32 25.6 67.2 0 112-12.8 128 25.6 6.4 51.2 9.6 80 9.6 54.4 0 102.4-9.6 150.4-32l0 0c3.2 0 3.2-3.2 3.2-3.2 22.4-16 12.8-35.2 6.4-44.8-9.6-12.8-12.8-25.6-12.8-41.6 0-54.4 60.8-99.2 137.6-99.2 6.4 0 12.8 0 22.4 0 12.8 0 38.4 9.6 48-25.6 0-3.2 0-3.2 3.2-6.4 0-3.2 3.2-6.4 3.2-6.4 6.4-16 6.4-16 6.4-19.2 9.6-35.2 16-73.6 16-115.2 0-105.6-41.6-198.4-108.8-268.8C704 396.8 560 675.2 560 675.2zM224 419.2c0-28.8 22.4-51.2 51.2-51.2 28.8 0 51.2 22.4 51.2 51.2 0 28.8-22.4 51.2-51.2 51.2C246.4 470.4 224 448 224 419.2zM320 284.8c0-22.4 19.2-41.6 41.6-41.6 22.4 0 41.6 19.2 41.6 41.6 0 22.4-19.2 41.6-41.6 41.6C339.2 326.4 320 307.2 320 284.8zM457.6 208c0-12.8 12.8-25.6 25.6-25.6 12.8 0 25.6 12.8 25.6 25.6 0 12.8-12.8 25.6-25.6 25.6C470.4 233.6 457.6 220.8 457.6 208zM128 505.6C128 592 153.6 672 201.6 736c28.8-60.8 112-60.8 124.8-60.8-16-51.2 16-99.2 16-99.2l316.8-422.4c-48-19.2-99.2-32-150.4-32C297.6 118.4 128 291.2 128 505.6zM764.8 86.4c-22.4 19.2-390.4 518.4-390.4 518.4-22.4 28.8-12.8 76.8 22.4 99.2l9.6 6.4c35.2 22.4 80 12.8 99.2-25.6 0 0 6.4-12.8 9.6-19.2 54.4-105.6 275.2-524.8 288-553.6 6.4-19.2-3.2-32-19.2-32C777.6 76.8 771.2 80 764.8 86.4z"></path></svg><div class="vp-outlook-dropdown"><!----></div></button></div><!--[--><button type="button" class="search-pro-button" aria-label="Search"><svg xmlns="http://www.w3.org/2000/svg" class="icon search-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="search icon" name="search"><path d="M192 480a256 256 0 1 1 512 0 256 256 0 0 1-512 0m631.776 362.496-143.2-143.168A318.464 318.464 0 0 0 768 480c0-176.736-143.264-320-320-320S128 303.264 128 480s143.264 320 320 320a318.016 318.016 0 0 0 184.16-58.592l146.336 146.368c12.512 12.48 32.768 12.48 45.28 0 12.48-12.512 12.48-32.768 0-45.28"></path></svg><div class="search-pro-placeholder">Search</div><div class="search-pro-key-hints"><kbd class="search-pro-key">Ctrl</kbd><kbd class="search-pro-key">K</kbd></div></button><!--]--><!--]--><!----><button type="button" class="vp-toggle-navbar-button" aria-label="Toggle Navbar" aria-expanded="false" aria-controls="nav-screen"><span><span class="vp-top"></span><span class="vp-middle"></span><span class="vp-bottom"></span></span></button></div></header><!----><!--]--><!----><div class="toggle-sidebar-wrapper"><span class="arrow start"></span></div><aside id="sidebar" class="vp-sidebar"><!----><ul class="vp-sidebar-links"></ul><!----></aside><!--[--><main id="main-content" class="vp-page"><!--[--><!----><!----><nav class="vp-breadcrumb disable"></nav><div class="vp-page-title"><h1><!---->DDD Theory 01</h1><div class="page-info"><span class="page-author-info" aria-label="Author🖊" data-balloon-pos="up"><svg xmlns="http://www.w3.org/2000/svg" class="icon author-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="author icon" name="author"><path d="M649.6 633.6c86.4-48 147.2-144 147.2-249.6 0-160-128-288-288-288s-288 128-288 288c0 108.8 57.6 201.6 147.2 249.6-121.6 48-214.4 153.6-240 288-3.2 9.6 0 19.2 6.4 25.6 3.2 9.6 12.8 12.8 22.4 12.8h704c9.6 0 19.2-3.2 25.6-12.8 6.4-6.4 9.6-16 6.4-25.6-25.6-134.4-121.6-240-243.2-288z"></path></svg><span><a class="page-author-item" href="https://vanhung4499.github.io" target="_blank" rel="noopener noreferrer">Hung Nguyen</a></span><span property="author" content="Hung Nguyen"></span></span><!----><span class="page-date-info" aria-label="Writing Date📅" data-balloon-pos="up"><svg xmlns="http://www.w3.org/2000/svg" class="icon calendar-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="calendar icon" name="calendar"><path d="M716.4 110.137c0-18.753-14.72-33.473-33.472-33.473-18.753 0-33.473 14.72-33.473 33.473v33.473h66.993v-33.473zm-334.87 0c0-18.753-14.72-33.473-33.473-33.473s-33.52 14.72-33.52 33.473v33.473h66.993v-33.473zm468.81 33.52H716.4v100.465c0 18.753-14.72 33.473-33.472 33.473a33.145 33.145 0 01-33.473-33.473V143.657H381.53v100.465c0 18.753-14.72 33.473-33.473 33.473a33.145 33.145 0 01-33.473-33.473V143.657H180.6A134.314 134.314 0 0046.66 277.595v535.756A134.314 134.314 0 00180.6 947.289h669.74a134.36 134.36 0 00133.94-133.938V277.595a134.314 134.314 0 00-133.94-133.938zm33.473 267.877H147.126a33.145 33.145 0 01-33.473-33.473c0-18.752 14.72-33.473 33.473-33.473h736.687c18.752 0 33.472 14.72 33.472 33.473a33.145 33.145 0 01-33.472 33.473z"></path></svg><span><!----></span><meta property="datePublished" content="2024-10-02T17:20:50.000Z"></span><!----><span class="page-reading-time-info" aria-label="Reading Time⌛" data-balloon-pos="up"><svg xmlns="http://www.w3.org/2000/svg" class="icon timer-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="timer icon" name="timer"><path d="M799.387 122.15c4.402-2.978 7.38-7.897 7.38-13.463v-1.165c0-8.933-7.38-16.312-16.312-16.312H256.33c-8.933 0-16.311 7.38-16.311 16.312v1.165c0 5.825 2.977 10.874 7.637 13.592 4.143 194.44 97.22 354.963 220.201 392.763-122.204 37.542-214.893 196.511-220.2 389.397-4.661 5.049-7.638 11.651-7.638 19.03v5.825h566.49v-5.825c0-7.379-2.849-13.981-7.509-18.9-5.049-193.016-97.867-351.985-220.2-389.527 123.24-37.67 216.446-198.453 220.588-392.892zM531.16 450.445v352.632c117.674 1.553 211.787 40.778 211.787 88.676H304.097c0-48.286 95.149-87.382 213.728-88.676V450.445c-93.077-3.107-167.901-81.297-167.901-177.093 0-8.803 6.99-15.793 15.793-15.793 8.803 0 15.794 6.99 15.794 15.793 0 80.261 63.69 145.635 142.01 145.635s142.011-65.374 142.011-145.635c0-8.803 6.99-15.793 15.794-15.793s15.793 6.99 15.793 15.793c0 95.019-73.789 172.82-165.96 177.093z"></path></svg><span>About 28 min</span><meta property="timeRequired" content="PT28M"></span><span class="page-category-info" aria-label="Category🌈" data-balloon-pos="up"><svg xmlns="http://www.w3.org/2000/svg" class="icon category-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="category icon" name="category"><path d="M148.41 106.992h282.176c22.263 0 40.31 18.048 40.31 40.31V429.48c0 22.263-18.047 40.31-40.31 40.31H148.41c-22.263 0-40.311-18.047-40.311-40.31V147.302c0-22.263 18.048-40.31 40.311-40.31zM147.556 553.478H429.73c22.263 0 40.311 18.048 40.311 40.31v282.176c0 22.263-18.048 40.312-40.31 40.312H147.555c-22.263 0-40.311-18.049-40.311-40.312V593.79c0-22.263 18.048-40.311 40.31-40.311zM593.927 106.992h282.176c22.263 0 40.31 18.048 40.31 40.31V429.48c0 22.263-18.047 40.31-40.31 40.31H593.927c-22.263 0-40.311-18.047-40.311-40.31V147.302c0-22.263 18.048-40.31 40.31-40.31zM730.22 920.502H623.926c-40.925 0-74.22-33.388-74.22-74.425V623.992c0-41.038 33.387-74.424 74.425-74.424h222.085c41.038 0 74.424 33.226 74.424 74.067v114.233c0 10.244-8.304 18.548-18.547 18.548s-18.548-8.304-18.548-18.548V623.635c0-20.388-16.746-36.974-37.33-36.974H624.13c-20.585 0-37.331 16.747-37.331 37.33v222.086c0 20.585 16.654 37.331 37.126 37.331H730.22c10.243 0 18.547 8.304 18.547 18.547 0 10.244-8.304 18.547-18.547 18.547z"></path></svg><!--[--><span class="page-category-item color4 clickable" role="navigation">design</span><!--]--><meta property="articleSection" content="design"></span><span class="page-tag-info" aria-label="Tag🏷" data-balloon-pos="up"><svg xmlns="http://www.w3.org/2000/svg" class="icon tag-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="tag icon" name="tag"><path d="M939.902 458.563L910.17 144.567c-1.507-16.272-14.465-29.13-30.737-30.737L565.438 84.098h-.402c-3.215 0-5.726 1.005-7.634 2.913l-470.39 470.39a10.004 10.004 0 000 14.164l365.423 365.424c1.909 1.908 4.42 2.913 7.132 2.913s5.223-1.005 7.132-2.913l470.39-470.39c2.01-2.11 3.014-5.023 2.813-8.036zm-240.067-72.121c-35.458 0-64.286-28.828-64.286-64.286s28.828-64.285 64.286-64.285 64.286 28.828 64.286 64.285-28.829 64.286-64.286 64.286z"></path></svg><!--[--><span class="page-tag-item color4 clickable" role="navigation">design</span><span class="page-tag-item color2 clickable" role="navigation">ddd</span><!--]--><meta property="keywords" content="design,ddd"></span></div><hr></div><div class="vp-toc-placeholder"><aside id="toc"><!----><div class="vp-toc-header">On This Page<button type="button" class="print-button" title="Print"><svg xmlns="http://www.w3.org/2000/svg" class="icon print-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="print icon" name="print"><path d="M819.2 364.8h-44.8V128c0-17.067-14.933-32-32-32H281.6c-17.067 0-32 14.933-32 32v236.8h-44.8C145.067 364.8 96 413.867 96 473.6v192c0 59.733 49.067 108.8 108.8 108.8h44.8V896c0 17.067 14.933 32 32 32h460.8c17.067 0 32-14.933 32-32V774.4h44.8c59.733 0 108.8-49.067 108.8-108.8v-192c0-59.733-49.067-108.8-108.8-108.8zM313.6 160h396.8v204.8H313.6V160zm396.8 704H313.6V620.8h396.8V864zM864 665.6c0 25.6-19.2 44.8-44.8 44.8h-44.8V588.8c0-17.067-14.933-32-32-32H281.6c-17.067 0-32 14.933-32 32v121.6h-44.8c-25.6 0-44.8-19.2-44.8-44.8v-192c0-25.6 19.2-44.8 44.8-44.8h614.4c25.6 0 44.8 19.2 44.8 44.8v192z"></path></svg></button><div class="arrow end"></div></div><div class="vp-toc-wrapper"><ul class="vp-toc-list"><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level2" href="#_0-tong-quan">0. Tổng quan</a></li><li><ul class="vp-toc-list"><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#paradigms">Paradigms</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#models">Models</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#frameworks">Frameworks</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#methodologies">Methodologies</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#main-activities">Main Activities</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#maintenance">Maintenance</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level2" href="#_1-ddd-la-gi">1.  DDD là gì?</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level2" href="#_2-khai-niem-ve-ddd">2. Khái niệm về DDD</a></li><li><ul class="vp-toc-list"><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#_2-1-rich-model">2.1. Rich Model</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#_2-2-domain-model">2.2. Domain Model</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#_2-3-entity-aggregate-value-object">2.3. Entity, Aggregate, Value Object</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#_2-4-repository-va-adapter">2.4. Repository và Adapter</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#_2-5-đieu-phoi-domain">2.5. Điều phối Domain</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#_2-6-tang-kich-hoat">2.6. Tầng kích hoạt</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level2" href="#tom-tat">Tóm tắt</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level2" href="#tham-khao">Tham khảo</a></li><!----><!--]--></ul><div class="vp-toc-marker" style="top:-1.7rem;"></div></div><!----></aside></div><!----><div class="theme-hope-content"><h1 id="ly-thuyet-ve-ddd-01-tong-quan" tabindex="-1"><a class="header-anchor" href="#ly-thuyet-ve-ddd-01-tong-quan"><span>Lý thuyết về DDD 01 - Tổng quan</span></a></h1><h2 id="_0-tong-quan" tabindex="-1"><a class="header-anchor" href="#_0-tong-quan"><span>0. Tổng quan</span></a></h2><p>DDD là gì? Đây là câu hỏi đầu tiên mà mọi nhà phát triển muốn sử dụng DDD cho dự án của mình gặp phải. Chỉ khi hiểu rõ DDD là gì thì mới có thể bắt tay vào sử dụng được. DDD không phải là một cấu trúc công trình như MVC, cũng không thể đồng nhất trực tiếp với kiến trúc microservices, càng không phải là một mẫu thiết kế.</p><p>DDD là viết tắt của Domain-Driven Design (thiết kế hướng miền), một phương pháp phát triển phần mềm chủ yếu được Eric Evans đề xuất lần đầu tiên trong cuốn sách của ông “Domain-Driven Design: Tackling Complexity in the Heart of Software”.</p><p><strong>DDD chủ yếu tập trung vào việc tạo ra các mô hình phần mềm liên quan chặt chẽ đến miền nghiệp vụ, nhằm đảm bảo phần mềm có thể giải quyết chính xác các vấn đề thực tế.</strong></p><p><strong>Các khái niệm cốt lõi của DDD bao gồm:</strong></p><ol><li><p><strong>Mô hình miền (Domain Model)</strong>:<br> Mô hình miền là sự biểu thị chính xác kiến thức về một miền nghiệp vụ cụ thể, bao gồm các khái niệm như thực thể (Entities), Value Object (Value Objects), dịch vụ (Services), tập hợp (Aggregates), và gốc tập hợp (Aggregate Roots). Mô hình miền là cốt lõi của DDD, phản ánh ngôn ngữ và quyết định của chuyên gia nghiệp vụ.</p></li><li><p><strong>Ngôn ngữ thống nhất (Ubiquitous Language)</strong>:<br> Ngôn ngữ thống nhất là ngôn ngữ được sử dụng chung bởi nhóm phát triển và chuyên gia nghiệp vụ, và duy trì nhất quán trong toàn bộ dự án. Ngôn ngữ thống nhất đảm bảo rằng tất cả mọi người đều hiểu các khái niệm nghiệp vụ giống nhau, giảm chi phí giao tiếp và hiểu lầm.</p></li><li><p><strong>Giới hạn ngữ cảnh (Bounded Context)</strong>:<br> Giới hạn ngữ cảnh là ranh giới hệ thống được xác định rõ ràng, trong đó có một tập hợp mô hình và ngôn ngữ thống nhất. Các giới hạn ngữ cảnh khác nhau có thể có các mô hình khác nhau, và chúng tương tác và tích hợp với nhau thông qua ánh xạ ngữ cảnh (Context Mapping).</p></li><li><p><strong>Tập hợp (Aggregate)</strong>:<br> Tập hợp là một tập hợp các đối tượng liên quan, được coi là một đơn vị để sửa đổi dữ liệu. Mỗi tập hợp có một gốc tập hợp, là cổng vào duy nhất cho các đối tượng bên ngoài tương tác với các đối tượng bên trong tập hợp.</p></li><li><p><strong>Dịch vụ miền (Domain Services)</strong>:<br> Khi một số hành vi không tự nhiên thuộc về bất kỳ thực thể hoặc Value Object nào, các hành vi này có thể được định nghĩa là dịch vụ miền. Dịch vụ miền thường biểu thị các hoạt động hoặc business logic trong miền.</p></li><li><p><strong>Dịch vụ ứng dụng (Application Services)</strong>:<br> Dịch vụ ứng dụng là một phần của phần mềm, phối hợp các đối tượng miền để thực hiện nhiệm vụ. Chúng chịu trách nhiệm về quy trình làm việc của ứng dụng, nhưng không chứa các quy tắc hoặc kiến thức nghiệp vụ.</p></li><li><p><strong>Hạ tầng (Infrastructure)</strong>:<br> Hạ tầng bao gồm các thành phần kỹ thuật cung cấp cơ chế lưu trữ cho mô hình miền (như cơ sở dữ liệu), truyền thông tin, cấu hình ứng dụng, v.v.</p></li><li><p><strong>Sự kiện miền (Domain Events)</strong>:<br> Sự kiện miền là các sự kiện nghiệp vụ có ý nghĩa xảy ra trong miền, có thể kích hoạt các phản ứng hoặc quy trình từ các hệ thống con khác.</p></li></ol><p><strong>Mục tiêu của DDD</strong> là tập trung vào miền cốt lõi của phần mềm, và quản lý sự phức tạp thông qua mô hình miền phong phú, từ đó nâng cao chất lượng và khả năng bảo trì phần mềm. DDD nhấn mạnh sự hợp tác chặt chẽ với chuyên gia nghiệp vụ để đảm bảo rằng giải pháp phần mềm phản ánh chính xác các yêu cầu nghiệp vụ. Thông qua phương pháp này, nhóm phát triển phần mềm có thể tạo ra các hệ thống linh hoạt hơn, mở rộng hơn và liên kết chặt chẽ với nghiệp vụ.</p><p><strong>Các phương pháp thiết kế phần mềm trong DDD:</strong></p><p>Phương pháp thiết kế phần mềm bao gồm các nguyên tắc, khái niệm và thực hành hướng dẫn quy trình phát triển phần mềm. Những phương pháp này thường bao gồm các khái niệm như:</p><ul><li><strong>Paradigms</strong></li><li><strong>Models</strong></li><li><strong>Frameworks</strong></li><li><strong>Methodologies</strong></li></ul><p><strong>Các hoạt động chính của thiết kế phần mềm bao gồm:</strong></p><ul><li><strong>Modeling</strong></li><li><strong>Testing</strong></li><li><strong>Engineering)</strong></li><li><strong>Development</strong></li><li><strong>Deployment</strong></li><li><strong>Maintenance</strong></li></ul><h3 id="paradigms" tabindex="-1"><a class="header-anchor" href="#paradigms"><span><strong>Paradigms</strong></span></a></h3><p>Paradigms là phong cách hoặc triết lý cơ bản trong thiết kế và phát triển phần mềm. Nó thường định nghĩa các nguyên tắc và mô hình cơ bản của lập trình. Các phạm trù thiết kế phần mềm phổ biến bao gồm:</p><ol><li><strong>Lập trình cấu trúc (Structural Programming)</strong>: Nhấn mạnh tầm quan trọng của cấu trúc chương trình, sử dụng các cấu trúc điều khiển như tuần tự, lựa chọn và vòng lặp.</li><li><strong>Lập trình hướng đối tượng (OOP - Object Oriented Programming)</strong>: Dựa trên khái niệm đối tượng, kết hợp dữ liệu và các phương pháp xử lý dữ liệu.</li><li><strong>Lập trình hàm (Functional Programming)</strong>: Xem việc tính toán như là đánh giá các hàm toán học, tránh thay đổi trạng thái và dữ liệu có thể thay đổi.</li><li><strong>Lập trình hướng sự kiện (Event-Driven Programming)</strong>: Tập trung vào các sự kiện, phản hồi các thao tác của người dùng, tin nhắn hoặc các sự kiện khác trong hệ thống.</li></ol><h3 id="models" tabindex="-1"><a class="header-anchor" href="#models"><span><strong>Models</strong></span></a></h3><p>Mô hình là sự biểu diễn trừu tượng của hệ thống phần mềm, giúp hiểu, thiết kế và kiểm thử hệ thống. Các mô hình thiết kế phần mềm phổ biến bao gồm:</p><ol><li><strong>UML (Unified Modeling Language)</strong>: Một tập hợp các ngôn ngữ mô hình hóa đồ họa dùng để mô tả, thiết kế và tài liệu hóa các dự án phần mềm.</li><li><strong>Mô hình ER (Entity-Relation)</strong>: Dùng cho thiết kế cơ sở dữ liệu, mô tả các thực thể dữ liệu và mối quan hệ giữa chúng.</li><li><strong>Mô hình máy trạng thái</strong>: Mô tả các trạng thái có thể có của hệ thống, các sự kiện và các chuyển đổi khi các sự kiện đó xảy ra.</li></ol><h3 id="frameworks" tabindex="-1"><a class="header-anchor" href="#frameworks"><span><strong>Frameworks</strong></span></a></h3><p>Framework là một tập hợp các thư viện mã và thành phần được thiết kế trước, cung cấp bộ khung cho việc phát triển phần mềm. Framework thường định nghĩa cấu trúc của ứng dụng, cung cấp một tập hợp các chức năng và mô hình chung để các nhà phát triển có thể tập trung vào việc thực hiện business logic cụ thể. Ví dụ:</p><ol><li><strong>Spring Framework</strong>: Một khung lập trình và cấu hình toàn diện cho các ứng dụng Java.</li><li><strong>Ruby on Rails</strong>: Một Framework Ruby để phát triển nhanh các ứng dụng web.</li><li><strong>Django</strong>: Một Framework web cao cấp cho Python, khuyến khích phát triển nhanh và thiết kế sạch, thực dụng.</li></ol><h3 id="methodologies" tabindex="-1"><a class="header-anchor" href="#methodologies"><span><strong>Methodologies</strong></span></a></h3><p>Phương pháp luận là một tập hợp các quy tắc và thực hành hướng dẫn quá trình phát triển phần mềm. Nó bao gồm quản lý dự án, quy trình phát triển, sự cộng tác của nhóm, v.v. Các phương pháp phát triển phần mềm phổ biến bao gồm:</p><ol><li><strong>Agile</strong>: Một phương pháp phát triển lặp lại và tăng cường, nhấn mạnh sự linh hoạt và hợp tác với khách hàng.</li><li><strong>Scrum</strong>: Một Framework Agile để quản lý các dự án phần mềm và sản phẩm phức tạp.</li><li><strong>Waterfall</strong>: Một phương pháp phát triển tuyến tính tuần tự, chia dự án thành các giai đoạn khác nhau, mỗi giai đoạn hoàn thành trước khi chuyển sang giai đoạn tiếp theo.</li></ol><h3 id="main-activities" tabindex="-1"><a class="header-anchor" href="#main-activities"><span><strong>Main Activities</strong></span></a></h3><p>Các hoạt động chính của thiết kế phần mềm bao gồm:</p><ol><li><strong>Modeling</strong>: Tạo các mô hình để biểu diễn các khía cạnh khác nhau của hệ thống, như sử dụng sơ đồ UML để mô tả kiến trúc hệ thống.</li><li><strong>Testing</strong>: Đảm bảo chất lượng phần mềm, bao gồm kiểm thử đơn vị, kiểm thử tích hợp, kiểm thử hệ thống và kiểm thử chấp nhận.</li><li><strong>Engineering</strong>: Áp dụng các nguyên tắc và thực hành kỹ thuật để xây dựng phần mềm, bao gồm phân tích yêu cầu, thiết kế, hiện thực và kiểm thử.</li><li><strong>Development</strong>: Viết mã và hiện thực các chức năng, chuyển đổi thiết kế thành sản phẩm phần mềm thực tế.</li><li><strong>Deployment</strong>: Phát hành phần mềm vào môi trường sản xuất, làm cho nó sẵn sàng để người dùng sử dụng.</li><li><strong>Maintenance</strong>: Cập nhật và cải tiến phần mềm sau khi phát hành, sửa chữa lỗi, nâng cao hiệu suất và khả năng thích ứng.</li></ol><p>Mỗi hoạt động là một phần quan trọng của vòng đời phát triển phần mềm, chúng phụ thuộc lẫn nhau và cùng đảm bảo sự thành công của dự án phần mềm.</p><h3 id="maintenance" tabindex="-1"><a class="header-anchor" href="#maintenance"><span><strong>Maintenance</strong></span></a></h3><p>Bảo trì phần mềm là các hoạt động diễn ra sau khi phần mềm được phát hành, bao gồm các khía cạnh sau:</p><ol><li><strong>Sửa lỗi</strong>: Sửa chữa các lỗi hoặc sai sót được phát hiện trong phần mềm.</li><li><strong>Bảo trì thích nghi</strong>: Thay đổi phần mềm để thích ứng với sự thay đổi của môi trường, như nâng cấp hệ điều hành, thay thế phần cứng, v.v.</li><li><strong>Bảo trì hoàn thiện</strong>: Thêm các tính năng mới hoặc nâng cao hiệu suất để đáp ứng các yêu cầu mới hoặc thay đổi của người dùng.</li><li><strong>Bảo trì phòng ngừa</strong>: Cải thiện cấu trúc nội bộ của phần mềm để ngăn ngừa các vấn đề tiềm ẩn, nâng cao khả năng bảo trì và mở rộng của phần mềm.</li></ol><p>Bảo trì phần mềm là một quá trình liên tục, đảm bảo phần mềm có thể phục vụ người dùng một cách hiệu quả trong thời gian dài.</p><h2 id="_1-ddd-la-gi" tabindex="-1"><a class="header-anchor" href="#_1-ddd-la-gi"><span><strong>1. DDD là gì?</strong></span></a></h2><p>DDD là gì? Theo một đoạn định nghĩa từ Wikipedia: <strong><a href="https://en.wikipedia.org/wiki/Domain-driven_design" target="_blank" rel="noopener noreferrer">&quot;Domain-driven design (DDD) is a major software design approach.&quot;</a></strong>, DDD là một phương pháp thiết kế phần mềm. Điều này có nghĩa là DDD là một phương tiện hướng dẫn chúng ta thực hiện thiết kế kỹ thuật phần mềm. Nó cung cấp các kỹ thuật để cắt nhỏ mô hình kỹ thuật, chẳng hạn như: domain, bounded context, entity, value object, aggregate, factory, repository, v.v. Thông qua tư tưởng hướng dẫn của DDD, chúng ta có thể đầu tư nhiều thời gian hơn vào giai đoạn đầu và lập kế hoạch hợp lý cho thiết kế kỹ thuật có thể duy trì và lặp lại được.</p><p>Trong DDD, có một bộ công cụ thiết kế kỹ thuật được chia thành hai giai đoạn: thiết kế chiến lược và thiết kế chiến thuật.</p><ol><li><p><strong>Thiết kế chiến lược (Strategic Design)</strong>: chủ yếu để đối phó với các yêu cầu nghiệp vụ phức tạp, thông qua quá trình trừu tượng và phân chia, hợp lý chia nhỏ thành nhiều microservice độc lập để quản lý và kiểm soát. Đánh giá sự hợp lý của việc phân chia dựa trên việc triển khai các yêu cầu khi phát triển, xem liệu mỗi lần triển khai có cần thao tác nhiều microservice hay không. Thiết kế chiến lược như vậy là một thiết kế microservices thất bại. Vì vậy, một số ít các ứng dụng đơn thể quy mô trung bình, bao quanh bởi một hệ sinh thái dịch vụ (ecosystem), có ý nghĩa hơn. <strong><a href="https://www.simplethread.com/youre-not-actually-building-microservices/" target="_blank" rel="noopener noreferrer">Bạn thực sự không xây dựng microservices @Justin Etheredge</a></strong></p></li><li><p><strong>Thiết kế chiến thuật (Tactical Design)</strong>: trong phần này, chủ yếu là thảo luận về cách biểu đạt các khái niệm nghiệp vụ dựa trên tư duy hướng đối tượng và sử dụng mô hình miền. Thông thường, trong kiến trúc không thiết kế mô hình miền, mà thường ánh xạ đến kiến trúc ba lớp MVC, mô hình phát triển Service + dữ liệu sẽ làm cho Service trở nên phẳng, số lượng lớn và phát sinh nhiều mã business logic phức tạp. Thêm vào đó, việc tách rời hành vi đối tượng và logic chức năng, phát triển anemic model, dẫn đến việc sử dụng chéo liên tục của các đối tượng hành vi, làm tăng độ phức tạp của hệ thống và khó bảo trì. Vì vậy, trong giai đoạn này, cần thiết kế mỗi mô hình có thể biểu đạt các khái niệm domain và sử dụng entity, aggregate, domain service để triển khai.</p></li></ol><h2 id="_2-khai-niem-ve-ddd" tabindex="-1"><a class="header-anchor" href="#_2-khai-niem-ve-ddd"><span><strong>2. Khái niệm về DDD</strong></span></a></h2><p>Các khái niệm như Rich Model, những gì được đề cập trong domain này, entity, aggregate và value object có sự khác biệt gì? Những câu hỏi &quot;tại sao&quot; này rất quan trọng trong quá trình thiết kế chiến thuật. Hiểu rõ chúng sẽ giúp bạn thiết kế DDD một cách hiệu quả.</p><h3 id="_2-1-rich-model" tabindex="-1"><a class="header-anchor" href="#_2-1-rich-model"><span><strong>2.1. Rich Model</strong></span></a></h3><p><strong>Rich Model</strong> đề cập đến việc tích hợp thông tin thuộc tính và logic hành vi của đối tượng vào một lớp. Các phương thức thường được sử dụng như cung cấp xác thực thông tin của đối tượng, tạo khóa bộ nhớ cache và xử lý logic mà không cần gọi interface dịch vụ bên ngoài, tất cả đều nằm trong đối tượng.</p><figure><img src="https://article-images.zsxq.com/FsvPPZ3Fw8G0As-Y0Q5pLNn5Dtvs" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><ol><li>Cách này cho phép khi sử dụng một đối tượng, bạn có thể truy cập một loạt các phương thức do đối tượng cung cấp mà không cần tự xử lý logic tương tự.</li><li>Tuy nhiên, Rich Model không chỉ giới hạn ở thiết kế một lớp và các phương thức trong một lớp. Nó có thể là cấu trúc của một gói, trong đó bao gồm các thành phần cần thiết để thực hiện dịch vụ trong gói này (model, repository, factory), cũng có thể được coi là Rich Model.</li><li>Đồng thời, trong một lớp tương tự, bạn có thể cung cấp các lớp bên trong tương ứng, chẳng hạn như xác thực người dùng, bao gồm lớp truyền thông, thẻ xác thực, thẻ ngân hàng, bốn yếu tố, v.v. Tất cả đều được viết dưới dạng các lớp con bên trong lớp người dùng. Điều này giúp mã dễ hiểu hơn và dễ dàng bảo trì, phát triển.</li></ol><h3 id="_2-2-domain-model" tabindex="-1"><a class="header-anchor" href="#_2-2-domain-model"><span><strong>2.2. Domain Model</strong></span></a></h3><p><strong>Domain Model</strong> là sự trừu tượng và đóng gói các quy tắc, chiến lược và quy trình nghiệp vụ trong một business domain cụ thể. Phương pháp thiết kế chia nhỏ các domain module thông qua mô hình bão, tạo ra các ngữ cảnh ranh giới. Điểm khác biệt lớn nhất là tách các dịch vụ và mô hình dữ liệu ban đầu thành các domain module độc lập có ranh giới. Trong mỗi domain, bạn tạo các đối tượng thuộc về domain đó (entity, aggregate, value object), data access object (DAO), factory, adapter port (cách gọi các interface bên ngoài), v.v.</p><p>Bây giờ, có một số khái niệm: domain service, domain object, repository, event message và adapter port. Hãy xem chúng đã phát triển từ anemic model như thế nào và chi tiết từng khái niệm.</p><figure><img src="https://article-images.zsxq.com/Fq_zNTXR5LyQnDVs7XwpvzY12O47" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><ol><li>Trong phát triển dựa trên service + anemic model, dịch vụ gọi tuần tự từng module chức năng. Các infrastructure này (object, method, interface) gọi lẫn nhau. Điều này do anemic model không thiết kế theo hướng đối tượng và mọi yêu cầu phát triển chỉ là thiết kế chi tiết.</li><li>Trong Rich Model, chúng ta chia các service thành các domain service, VO, Req, Res thành các domain object, DAO, Redis thành repository, v.v. Ví dụ: trong một dịch vụ tài khoản, các quy trình xác thực tín dụng, mở tài khoản, tăng giảm hạn mức, v.v. mỗi cái là một domain độc lập, trong mỗi domain này, tạo các thông tin cần thiết cho domain đó.</li><li>Một đặc điểm của domain model là nó chỉ tập trung vào việc thực hiện chức năng nghiệp vụ, không kết nối trực tiếp với bất kỳ interface và dịch vụ bên ngoài nào. Ví dụ: không gọi trực tiếp DAO, không gọi trực tiếp Redis, không kết nối trực tiếp RPC với các microservice khác. Thay vào đó, thông qua repository và adapter port, nó xác định interface với các đối tượng đầu vào và đầu ra, để lớp infrastructure thực hiện các cuộc gọi cụ thể. Bằng cách này, domain chỉ tập trung vào thực hiện nghiệp vụ và đồng thời làm tốt việc bảo mật.</li></ol><h3 id="_2-3-entity-aggregate-value-object" tabindex="-1"><a class="header-anchor" href="#_2-3-entity-aggregate-value-object"><span><strong>2.3. Entity, Aggregate, Value Object</strong></span></a></h3><p>Trong phát triển theo anemic model, các đối tượng đầu vào và đầu ra của phương thức thường không được chú trọng, và nhiều dịch vụ thường dùng chung một đối tượng VO miễn là mang các thuộc tính cần thiết.</p><p>Nhưng trong thiết kế domain model (DDD), thiết kế domain object là rất hướng đối tượng. Trong toàn bộ quá trình mô hình hóa bão màu sắc, nó cũng được thúc đẩy bởi các domain object.</p><p>Entity, Aggregate, Value Object nằm trong các domain object trong mỗi domain và phục vụ cho các domain service. Ba đối tượng này được định nghĩa cụ thể như sau:</p><figure><img src="https://article-images.zsxq.com/Fj5_7DDMhzbwodONmAab8kkmbp6f" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h4 id="entity" tabindex="-1"><a class="header-anchor" href="#entity"><span><strong>Entity</strong></span></a></h4><p>Entity là các đối tượng có định danh duy nhất và có vòng đời kéo dài theo domain service. Các đối tượng PO (Persistent Objects) là các đối tượng nguyên tử không có ngữ nghĩa nghiệp vụ, trong khi entity là các đối tượng có ngữ nghĩa nghiệp vụ và có định danh duy nhất. Ví dụ: đối tượng PO của người dùng sẽ bao gồm các account entity, credit entity, level entity, và cả cart entity khi đặt hàng. Đối tượng này thường là đối tượng đầu vào của các phương thức domain service.</p><ol><li><p>Khái niệm:</p><ul><li>Entity = Định danh duy nhất + Thuộc tính trạng thái + Hành vi (chức năng), là một khối xây dựng cơ bản trong DDD, đại diện cho các domain object có định danh duy nhất. Entity không chỉ chứa dữ liệu mà còn chứa các hành vi liên quan và định danh của nó không thay đổi trong suốt vòng đời.</li></ul></li><li><p>Đặc điểm:<br> - <strong>Định danh duy nhất</strong>: Entity có một định danh có thể phân biệt với các entity khác. Định danh này có thể là một ID, một khóa hợp phần hoặc một khóa tự nhiên, điều quan trọng là nó có thể định danh duy nhất cho entity.<br> - <strong>Định danh domain</strong>: Định danh của entity thường xuất phát từ business domain, chẳng hạn như User ID, Order ID, v.v.<br> - <strong>Định danh ủy quyền</strong>: Trong một số trường hợp, định danh của entity có thể được tạo tự động bởi ORM, chẳng hạn như khóa chính tự động tăng trong cơ sở dữ liệu.</p></li><li><p>Mục đích:</p><ul><li><strong>Biểu diễn khái niệm nghiệp vụ</strong>: Entity được sử dụng để biểu diễn các khái niệm nghiệp vụ cụ thể trong phần mềm, như user, order, transaction, v.v.</li><li><strong>Đóng gói business logic</strong>: Entity không chỉ chứa dữ liệu mà còn đóng gói các quy tắc và business logic, bao gồm việc kiểm tra tính hợp lệ của dữ liệu, thực hiện các quy tắc nghiệp vụ, tính toán giá trị thuộc tính, v.v.</li><li><strong>Duy trì tính nhất quán của dữ liệu</strong>: Thực thể chịu trách nhiệm duy trì trạng thái và tính nhất quán của dữ liệu của chính nó.</li></ul></li><li><p>Phương pháp triển khai:</p><ul><li><strong>Định nghĩa lớp entity</strong>: Định nghĩa một lớp chứa các thuộc tính, hàm tạo, phương thức, v.v.</li><li><strong>Thực hiện định danh duy nhất</strong>: Cung cấp một thuộc tính định danh duy nhất cho lớp entity, chẳng hạn như ID, và đảm bảo rằng định danh này không thay đổi trong vòng đời của thực thể.</li><li><strong>Đóng gói hành vi</strong>: Triển khai các phương thức business logic trong lớp entity, các phương thức này có thể thao tác trạng thái của entity và thực hiện các quy tắc nghiệp vụ liên quan.</li><li><strong>Sử dụng ORM</strong>: Sử dụng ORM để ánh xạ entity vào bảng cơ sở dữ liệu.</li><li><strong>Triển khai domain service</strong>: Đối với các hoạt động liên quan đến nhiều entity hoặc aggregate, có thể triển khai domain service để xử lý các hoạt động này thay vì triển khai trực tiếp trong entity.</li><li><strong>Sử dụng domain event</strong>: Khi trạng thái của entity thay đổi, có thể phát hành các domain event để thông báo cho các phần khác của hệ thống thực thi các xử lý tương ứng.</li></ul></li></ol><h4 id="value-object" tabindex="-1"><a class="header-anchor" href="#value-object"><span><strong>Value Object</strong></span></a></h4><p>Value Object trong vòng đời của phương thức domain service là đối tượng không thể thay đổi và không có định danh duy nhất. Nó thường được sử dụng cùng với các entity object. Ví dụ, nó có thể cung cấp mô tả giá trị thuộc tính cho các entity object, chẳng hạn như một value object cấp bậc của nhân viên công ty hoặc một đối tượng thông tin địa chỉ giao hàng cấp bốn của một sản phẩm đã đặt hàng. Do đó, khi phát triển Value Object, thường không cung cấp phương thức setter, mà sử dụng hàm tạo hoặc phương thức Builder để khởi tạo đối tượng. Đối tượng này thường không được sử dụng làm đối tượng tham số của phương thức một cách độc lập, nhưng có thể được sử dụng làm đối tượng trả về một cách độc lập.</p><ol><li><p><strong>Khái niệm</strong>: Value Object được tạo thành từ một tập hợp các thuộc tính, chúng mô tả một khái niệm domain. Khác với Entity, Value Object không cần có định danh duy nhất để phân biệt chúng. Value Object thường không thể thay đổi, nghĩa là sau khi được tạo ra, trạng thái của chúng không nên thay đổi.</p></li><li><p><strong>Đặc điểm</strong>:</p><ol><li><strong>Tính bất biến (Immutability)</strong>: Value Object sau khi được tạo ra, trạng thái của nó không nên thay đổi. Điều này giúp đảm bảo tính nhất quán của domain model và an toàn luồng.</li><li><strong>Tính đồng nhất (Equality)</strong>: Sự đồng nhất của Value Object không dựa trên định danh hay tham chiếu, mà dựa trên các giá trị thuộc tính của đối tượng. Nếu tất cả các giá trị thuộc tính của hai Value Object bằng nhau, thì hai đối tượng đó được coi là đồng nhất.</li><li><strong>Tính thay thế (Replaceability)</strong>: Vì Value Object là không thể thay đổi, bất kỳ thao tác nào cần thay đổi Value Object sẽ dẫn đến việc tạo ra một phiên bản Value Object mới, thay vì sửa đổi phiên bản hiện tại.</li><li><strong>Chú trọng vào mô tả trạng thái của sự vật</strong>: Value Object thường được sử dụng để mô tả trạng thái của sự vật, chứ không phải là định danh duy nhất của sự vật.</li><li><strong>Tính tái sử dụng (Reusability)</strong>: Value Object có thể được tái sử dụng trong các domain entity khác nhau hoặc các Value Object khác.</li></ol></li><li><p><strong>Ứng dụng</strong>:</p><ol><li>Số tiền và tiền tệ (như giá cả, lương, chi phí, v.v.)</li><li>Đo lường và dữ liệu (như trọng lượng, chiều dài, thể tích, v.v.)</li><li>Phạm vi hoặc khoảng (như khoảng thời gian, khoảng nhiệt độ, v.v.)</li><li>Mô hình toán học phức tạp (như tọa độ, vector, v.v.)</li><li>Bất kỳ tập hợp thuộc tính nào khác cần được đóng gói.</li></ol></li><li><p><strong>Phương pháp triển khai</strong>:</p><ol><li><strong>Định nghĩa lớp bất biến</strong>: Đảm bảo tất cả các thuộc tính của lớp là private và chỉ có thể được thiết lập thông qua hàm tạo.</li><li><strong>Ghi đè phương thức equals và hashCode</strong>: Điều này đảm bảo rằng tính đồng nhất của Value Object dựa trên các giá trị thuộc tính của chúng, chứ không phải tham chiếu đối tượng.</li><li><strong>Cung cấp bộ đọc chỉ đọc</strong>: Chỉ cung cấp các phương thức truy cập giá trị thuộc tính, không cung cấp phương thức sửa đổi giá trị thuộc tính.</li><li><strong>Sử dụng factory method hoặc constructor để tạo phiên bản</strong>: Điều này giúp đảm bảo tính hợp lệ và nhất quán của Value Object.</li><li><strong>Cân nhắc hỗ trợ serialize</strong>: Nếu Value Object cần được truyền qua mạng hoặc lưu trữ vào cơ sở dữ liệu, cần cung cấp hỗ trợ serialize và deserialize.</li></ol></li></ol><h4 id="aggregate" tabindex="-1"><a class="header-anchor" href="#aggregate"><span><strong>Aggregate</strong></span></a></h4><p>Khi bạn thực hiện các thao tác với cơ sở dữ liệu liên quan đến nhiều entity, bạn có thể tạo đối tượng aggregate. Một đối tượng aggregate đại diện cho một giao dịch cơ sở dữ liệu và có tính nhất quán giao dịch. Các entity trong aggregate có thể được tạo ra bởi aggregate và entity này cũng được gọi là aggregate root (đối tượng gốc của tập hợp). Ví dụ, aggregate của một order sẽ bao gồm: đối tượng user entity (người dùng đặt hàng), order entity (đơn hàng), order detail entity (chi tiết đơn hàng) và address value object (địa chỉ giao hàng). Cart entity (giỏ hàng) làm tham số đầu vào sẽ được chuyển đổi thành entity. Tính nhất quán giao dịch bên trong aggregate và tính nhất quán cuối cùng bên ngoài aggregate.</p><ol><li><p><strong>Khái niệm</strong>: Aggregate là một khái niệm quan trọng trong domain model, nó là một tập hợp các đối tượng liên quan có tính kết dính, những đối tượng này cùng làm việc để thực hiện một số quy tắc hoặc thao tác nghiệp vụ nhất định. Aggregate xác định ranh giới của một tập hợp các đối tượng có thể được coi là một đơn vị duy nhất để xử lý.</p></li><li><p><strong>Đặc điểm</strong>:</p><ol><li><strong>Ranh giới nhất quán</strong>: Aggregate đảm bảo sự thay đổi trạng thái của các đối tượng bên trong nó là nhất quán. Khi thực hiện thao tác trên các đối tượng trong aggregate, các thao tác này phải giữ cho tất cả các đối tượng trong tập hợp có sự nhất quán.</li><li><strong>Aggregate Root</strong>: Mỗi tập hợp có một thực thể gốc (Aggregate Root), nó là điểm truy cập của aggregate. Aggregate Root có một định danh duy nhất toàn cục, các đối tượng khác tương tác với tập hợp thông qua aggregate root.</li><li><strong>Ranh giới giao dịch</strong>: Aggregate cũng xác định ranh giới của giao dịch. Trong aggregate, tất cả các thao tác thay đổi phải là nguyên tử, nghĩa là chúng hoặc thành công hoàn toàn hoặc thất bại hoàn toàn, để đảm bảo tính nhất quán của dữ liệu.</li></ol></li><li><p><strong>Ứng dụng</strong>:</p><ol><li><strong>Đóng gói business logic</strong>: Aggregate thông qua việc đóng gói các đối tượng và thao tác liên quan, cung cấp một mô hình business logic rõ ràng, giúp việc thực thi và bảo trì các business rule.</li><li><strong>Đảm bảo tính nhất quán</strong>: Aggregate đảm bảo sự nhất quán của trạng thái nội bộ, thông qua việc định rõ ranh giới và quy tắc, aggregate có thể thực thi các quy tắc kinh doanh nội bộ, đảm bảo tính nhất quán của dữ liệu.</li><li><strong>Đơn giản hóa sự phức tạp</strong>: Aggregate thông qua việc tổ chức các đối tượng liên quan, đơn giản hóa sự phức tạp của domain model. Điều này giúp các nhà phát triển dễ dàng hiểu và mở rộng hệ thống.</li></ol></li><li><p><strong>Phương pháp triển khai</strong>:</p><ol><li><strong>Định nghĩa aggregate root</strong>: Lựa chọn root entity phù hợp là bước đầu tiên để thực hiện tập hợp. Thực thể gốc nên là thực thể có thể đại diện cho toàn bộ tập hợp và có định danh duy nhất.</li><li><strong>Hạn chế đường dẫn truy cập</strong>: Chỉ có thể sửa đổi các đối tượng bên trong aggregate thông qua root entity, không được phép sửa đổi trực tiếp trạng thái của các đối tượng bên trong aggregate, để duy trì ranh giới và tính nhất quán.</li><li><strong>Thiết kế chiến lược giao dịch</strong>: Thực hiện tính nhất quán giao dịch trong aggregate, đảm bảo các thao tác hoặc hoàn thành toàn bộ hoặc quay lại toàn bộ. Đối với tương tác giữa các tập hợp, có thể sử dụng domain event hoặc cơ chế khác để thực hiện tính nhất quán cuối cùng.</li><li><strong>Đóng gói business rule</strong>: Thực hiện các quy tắc và business logic trong aggregate, đảm bảo tất cả các thao tác nghiệp vụ tuân theo các quy tắc này.</li><li><strong>Duy trì tính nhất quán</strong>: Root entity của aggregate thường tương tác với lớp repository để lưu trữ trạng thái của aggregate. Điều này thường liên quan đến ánh xạ Object-Relation (ORM) hoặc các kỹ thuật ánh xạ dữ liệu khác.</li></ol></li></ol><h3 id="_2-4-repository-va-adapter" tabindex="-1"><a class="header-anchor" href="#_2-4-repository-va-adapter"><span><strong>2.4. Repository và Adapter</strong></span></a></h3><p>Trong phương pháp thiết kế DDD, tầng domain chỉ quan tâm đến việc thực hiện các domain service. Điều này thể hiện rõ nhất qua thiết kế của repository và adapter. Thông thường, trong thiết kế Service + data model, các dịch vụ ngoài như Redis, RPC, configuration center, v.v., sẽ được đưa vào Service. Nhưng trong DDD, thông qua việc định nghĩa repository và adapter cũng như tầng infrastructure, phần này đã được tách rời.</p><figure><img src="https://article-images.zsxq.com/FvLgpxTQ7zUfH-3FT4PA77wOfalR" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><ol><li><p><strong>Đặc điểm</strong>:</p><ol><li><strong>Đóng gói các thao tác lưu trữ</strong>: Repository chịu trách nhiệm đóng gói tất cả các thao tác tương tác với nguồn dữ liệu, như các thao tác tạo, đọc, cập nhật và xóa (CRUD). Bằng cách này, mã nguồn của tầng domain có thể tránh được sự phức tạp khi xử lý cơ sở dữ liệu hoặc các cơ chế lưu trữ khác.</li><li><strong>Quản lý tập hợp các đối tượng domain</strong>: Repository thường được coi là tập hợp các đối tượng domain, cung cấp các phương thức truy vấn và lọc các đối tượng này, làm cho việc lấy và quản lý các đối tượng domain trở nên thuận tiện hơn.</li><li><strong>Giao diện trừu tượng</strong>: Repository định nghĩa một giao diện không phụ thuộc vào cơ chế lưu trữ, điều này cho phép mã nguồn của tầng domain có thể chuyển đổi giữa các cơ chế lưu trữ khác nhau mà không cần sửa đổi logic nghiệp vụ.</li></ol></li><li><p><strong>Ứng dụng</strong>:</p><ol><li><strong>Trừu tượng hóa truy cập dữ liệu</strong>: Repository cung cấp một giao diện truy cập dữ liệu rõ ràng cho tầng domain, giúp các đối tượng domain có thể tập trung vào việc thực hiện logic nghiệp vụ mà không cần quan tâm đến chi tiết truy cập dữ liệu.</li><li><strong>Truy vấn và quản lý đối tượng domain</strong>: Repository làm cho việc truy vấn và quản lý các đối tượng domain trở nên thuận tiện và linh hoạt hơn, hỗ trợ các logic truy vấn phức tạp.</li><li><strong>Phân tách logic nghiệp vụ và lưu trữ dữ liệu</strong>: Thông qua mô hình Repository, logic nghiệp vụ và logic lưu trữ dữ liệu được phân tách, nâng cao tính thuần túy và khả năng kiểm tra của domain model.</li><li><strong>Tối ưu hóa truy cập dữ liệu</strong>: Việc thực hiện Repository có thể bao gồm các chiến lược tối ưu hóa truy cập dữ liệu, như bộ nhớ đệm, thao tác hàng loạt, v.v., để cải thiện hiệu suất của ứng dụng.</li></ol></li><li><p><strong>Phương pháp thực hiện</strong>:</p><ol><li><strong>Định nghĩa giao diện Repository</strong>: Định nghĩa một hoặc nhiều giao diện Repository trong tầng domain, các giao diện này khai báo các phương thức truy cập dữ liệu cần thiết.</li><li><strong>Thực hiện giao diện Repository</strong>: Thực hiện các giao diện này trong tầng infrastructure hoặc tầng truy cập dữ liệu, việc thực hiện cụ thể có thể sử dụng các khung ORM (Object-Relational Mapping) như MyBatis, Hibernate, hoặc sử dụng trực tiếp API truy cập cơ sở dữ liệu như JDBC.</li><li><strong>Tiêm phụ thuộc</strong>: Sử dụng tiêm phụ thuộc (DI) trong ứng dụng để tiêm các triển khai cụ thể của Repository vào các domain service hoặc dịch vụ ứng dụng cần chúng. Cách làm này giúp tách rời thêm tầng domain và tầng truy cập dữ liệu, đồng thời thuận tiện cho việc kiểm tra đơn vị.</li><li><strong>Sử dụng mẫu quy định (Specification Pattern)</strong>: Đôi khi, để xây dựng các truy vấn phức tạp, có thể kết hợp sử dụng mẫu quy định, đây là một mẫu cho phép đóng gói các quy tắc nghiệp vụ thành các đơn vị logic nghiệp vụ riêng biệt, các đơn vị này có thể được Repository sử dụng để xây dựng truy vấn.</li></ol></li></ol><p>Mô hình Repository là một khái niệm cốt lõi trong DDD (Domain-Driven Design), nó giúp duy trì sự tập trung và rõ ràng của domain model, đồng thời cung cấp các chiến lược truy cập dữ liệu linh hoạt, có thể kiểm tra và bảo trì.</p><p>Repository tách rời sử dụng thiết kế đảo ngược phụ thuộc (Dependency Inversion), tất cả các dịch vụ ngoài cần thiết của domain không được đưa trực tiếp vào dịch vụ ngoài mà thông qua việc định nghĩa các interface, để tầng infrastructure thực hiện các interface của tầng domain (repository/adapter).</p><p>Tầng infrastructure chịu trách nhiệm kết nối với Database, Cache, Configuration Center, RPC Interface, HTTP, Push MQ, ... và thực hiện các cuộc gọi domain service interface để cung cấp khả năng truy cập dữ liệu cho tầng domain.</p><p>Điều này cũng thể hiện rằng, việc triển khai của tầng domain có ý nghĩa nghiệp vụ, còn tầng infrastructure thì không có ý nghĩa nghiệp vụ, tất cả đều là các phương thức nguyên tử. Bằng cách kết hợp các phương thức nguyên tử này để cung cấp hỗ trợ cho ý nghĩa business domain.</p><h3 id="_2-5-đieu-phoi-domain" tabindex="-1"><a class="header-anchor" href="#_2-5-đieu-phoi-domain"><span><strong>2.5. Điều phối Domain</strong></span></a></h3><p>Trong DDD (Domain-Driven Design), mỗi domain là kết quả của việc phân chia các ngữ cảnh có giới hạn độc lập, và để triển khai các chức năng của quy trình nghiệp vụ, cần phải kết nối các domain module khác nhau để cung cấp một dịch vụ hoàn chỉnh từ đầu đến cuối. Do đó, người ta thường nói về tính nhất quán của giao dịch trong domain và tính nhất quán cuối cùng ngoài domain.</p><p>Vì các domain module là độc lập, nên chúng có thể được tái sử dụng. Trong các kịch bản và yêu cầu chức năng khác nhau, bạn có thể chọn các domain module khác nhau để lắp ráp, quá trình này giống như xây dựng một tòa nhà từ các khối lego.</p><p>Tuy nhiên, cần phải có sự đánh đổi. Nếu dự án không quá lớn và không cần nhiều xử lý điều phối, bạn có thể để tầng kích hoạt tương tác trực tiếp với tầng domain, bỏ qua tầng điều phối, giúp cho mã nguồn trở nên đơn giản và thuận tiện hơn.</p><h3 id="_2-6-tang-kich-hoat" tabindex="-1"><a class="header-anchor" href="#_2-6-tang-kich-hoat"><span><strong>2.6. Tầng kích hoạt</strong></span></a></h3><p>Sau khi tất cả các mô hình đã được định nghĩa và liên kết với nhau, bước tiếp theo là sử dụng chúng. Cách sử dụng có thể bao gồm: interface (HTTP/RPC), lắng nghe tin nhắn (message queue), tác vụ định kỳ (cron job), v.v. Những phương pháp này được gọi chung là hành động kích hoạt.</p><p>Hành động kích hoạt này sẽ khởi động việc gọi và xử lý chức năng điều phối. Ví dụ: tác vụ định kỳ để tính lãi cho tín dụng, thông báo thành công mở tài khoản và cấp mã giảm giá, cung cấp interface để bên ngoài gọi đến logic cấp tín dụng, v.v. Tất cả đều là các hành động kích hoạt.</p><h2 id="tom-tat" tabindex="-1"><a class="header-anchor" href="#tom-tat"><span><strong>Tóm tắt</strong></span></a></h2><p>Phương pháp thiết kế phần mềm là một lĩnh vực phức tạp, liên quan đến nhiều khái niệm và thực hành. Các mô hình cung cấp triết lý thiết kế, các mô hình giúp chúng ta hiểu và trừu tượng hóa hệ thống, các framework cung cấp cấu trúc cơ bản cho phát triển, và các phương pháp luận hướng dẫn quá trình phát triển toàn diện. Các hoạt động chính trong thiết kế phần mềm như mô hình hóa, kiểm thử, kỹ thuật, phát triển, triển khai và bảo trì là các bước quan trọng đảm bảo thành công của dự án phần mềm. Mỗi hoạt động đòi hỏi kiến thức chuyên môn, kỹ năng, cùng với sự hỗ trợ của các công cụ và kỹ thuật tương ứng. Thông qua sự phối hợp của các hoạt động này, các kỹ sư phần mềm có thể cung cấp sản phẩm phần mềm chất lượng cao, đáp ứng nhu cầu của người dùng.</p><h2 id="tham-khao" tabindex="-1"><a class="header-anchor" href="#tham-khao"><span>Tham khảo</span></a></h2><ol><li><strong><a href="https://en.wikipedia.org/wiki/Domain-driven_design" target="_blank" rel="noopener noreferrer">https://en.wikipedia.org/wiki/Domain-driven_design</a></strong></li><li><strong><a href="https://en.wikipedia.org/wiki/Software_design" target="_blank" rel="noopener noreferrer">https://en.wikipedia.org/wiki/Software_design</a></strong></li></ol></div><!----><footer class="vp-page-meta"><div class="vp-meta-item edit-link"><a class="auto-link external-link vp-meta-label" href="https://github.com/vanhung4499/my-wiki/edit/main/src/design/software-design/ddd/ddd-theory-01.md" aria-label="Edit this page on GitHub" rel="noopener noreferrer" target="_blank"><!--[--><svg xmlns="http://www.w3.org/2000/svg" class="icon edit-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="edit icon" name="edit"><path d="M430.818 653.65a60.46 60.46 0 0 1-50.96-93.281l71.69-114.012 7.773-10.365L816.038 80.138A60.46 60.46 0 0 1 859.225 62a60.46 60.46 0 0 1 43.186 18.138l43.186 43.186a60.46 60.46 0 0 1 0 86.373L588.879 565.55l-8.637 8.637-117.466 68.234a60.46 60.46 0 0 1-31.958 11.229z"></path><path d="M728.802 962H252.891A190.883 190.883 0 0 1 62.008 771.98V296.934a190.883 190.883 0 0 1 190.883-192.61h267.754a60.46 60.46 0 0 1 0 120.92H252.891a69.962 69.962 0 0 0-69.098 69.099V771.98a69.962 69.962 0 0 0 69.098 69.098h475.911A69.962 69.962 0 0 0 797.9 771.98V503.363a60.46 60.46 0 1 1 120.922 0V771.98A190.883 190.883 0 0 1 728.802 962z"></path></svg><!--]-->Edit this page on GitHub<!----></a></div><div class="vp-meta-item git-info"><div class="update-time"><span class="vp-meta-label">Last update: </span><!----></div><div class="contributors"><span class="vp-meta-label">Contributors: </span><!--[--><!--[--><span class="vp-meta-info" title="email: vanhung4499@gmail.com">Hung Nguyen Van</span><!--]--><!--]--></div></div></footer><!----><!----><!----><!--]--></main><!--]--><footer class="footer-wrapper" style="display:none;--1ea755b8:;"><div class="footer-content"><div class="footer">Made with ❤️ by Hung Nguyen</div><div class="copyright">Copyright © 2016-2024 Hung Nguyen</div></div><span id="runtime_span"></span></footer></div><!--]--><!--[--><!----><!----><!----><!----><!--]--><!--]--></div>
    <script type="module" src="/assets/app-5QVbWi7Z.js" defer></script>
  </body>
</html>
